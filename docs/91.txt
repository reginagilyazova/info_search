Исследование кортежей в C# 7
JosefDzeranov
Типы   были введены в .NET 4.0 с двумя существенными недостатками:  
 
 
Чтобы решить эти проблемы, в C# 7 представлена новая возможность языка, а также новое семейство типов (*).  
 
Сегодня, если вам нужно склеить два значения, чтобы вернуть их из функции или поместить два значения в хэш-набор, вы можете использовать типы   и создать их с помощью удобного синтаксиса: 
 
 
(*) Типы   представлены в .NET Framework 4.7. Но вы можете использовать их в более ранних версиях фреймворка, в этом случае вам нужно добавить в проект специальный пакету nuget:  . 
 
 
(**) Мы скоро увидим, что это не всегда так. 
 
 
Отсутствие пользовательских имен делает типы   не очень полезными. Я могу использовать   как часть реализации небольшого метода, но если мне нужно передать его экземпляр, я предпочитаю именованный тип с описательными именами свойств. Кортежи в C# 7 довольно элегантно решают эту проблему: вы можете указать имена для элементов кортежа и, в отличие от анонимных классов, эти имена доступны даже в разных сборок. 
 
Компилятор C# генерирует специальный атрибут   (***) для каждого типа кортежа, используемого в сигнатуре метода: 
 
(***) Атрибут TupleElementNamesAttribute является специальным и не может использоваться непосредственно в коде пользователя. Компилятор выдает ошибку, если вы попытаетесь его использовать. 
 
 
Данный атрибут помогает IDE и компилятору «видеть» имена элементов и предупреждать, если они используются неправильно: 
 
 
У компилятора более высокие требования к унаследованным членам: 
 
 
Обычные аргументы метода могут быть свободно изменены в переопределенных членах, но имена элементов кортежей в переопределенных членах должны точно совпадать с именами из базового типа. 
 
 
C # 7.1 появилось одно дополнительное усовершенствование: вывод имени элемента кортежа аналогичен тому, что C# делает для анонимных типов.  
 
 
 
Кортежи являются изменяемыми значимыми типами. Мы знаем, что изменяемые значимые типы считаются вредными. Вот небольшой пример их злой природы: 
 
 
Если вы запустите этот код, вы получите… бесконечный цикл. Список List .Enumerator — это изменяемый значимый типа, а   свойство. Это означает, что   возвращает копию исходного итератора на каждой итерации цикла, вызывая бесконечный цикл. 
 
Но изменяемые значимые типы опасны только тогда, когда данные смешиваются с поведением: Enumerator содержит состояние (текущий элемент) и имеет поведение (возможность продвижения итератора путем вызова метода  ). Эта комбинация может вызывать проблемы, потому что легко вызвать метод на копии, вместо исходного экземпляра, что приводит к эффекту no-op (No Operation). Вот набор примеров, которые могут вызвать неочевидное поведение из-за скрытой копии типа значения:  . 
 
Кортежи обладают состоянием, но не поведением, поэтому приведенные выше проблемы к ним не применимы. Но одна проблема с изменчивостью все же остается: 
 
 
Кортежи являются очень полезными в качестве ключей в словарях и могут использоваться в качестве ключей благодаря семантики значений. Но не следует изменять состояние переменной ключа между различными операциями с коллекцией. 
 
 
Несмотря на то, что язык C# обладает специальным синтаксисом для создания экземпляров кортежей, деконструкция является более общей возможностью и может использоваться с любым типом. 
 
 
Разбор (деконструкция) кортежа использует подход «утиной типизации»: если компилятор может найти метод  для данного типа – экземплярный метод или метод расширения — тип является разбираемым. 
 
 
После того, как вы начнете использовать кортежи, вы быстро поймете, что хотите «повторно использовать» тип кортежа с именованными элементами в нескольких местах исходного кода. Но с этим не все так просто.  
 
Во-первых, C # не поддерживает глобальные псевдонимы для заданного типа. Вы можете использовать 'using' alias директиву, но она создает псевдоним, видимый в одном файле. 
 
Во-вторых, вы даже не можете использовать эту возможность совместно с кортежами: 
 
 
Сейчас на github в теме   идет обсуждение этой проблемы. Поэтому, если вы обнаружите, что используете один тип кортежа в нескольких местах, у вас есть два варианта: либо копировать во типы по всей кодовой базе либо создать именованный тип. 
 
 
Pascal case, например  , или camel case, например  ? С одной стороны, элементы кортежей должны следовать правилу именования для публичных членов (т.е.  ), но, с другой стороны, кортежи — это просто хранилище для переменных, а переменные именуются с  . 
 
Вы можете использовать следующий подход:  
 
 
Но я предпочитаю использовать camelCase все время. 
 
 
Я нашел кортежи очень полезными в повседневной работе. Мне нужно больше одного возвращаемого значения из функции, или мне нужно поместить пару значений в хэш-набор, или мне нужно изменить словарь и сохранить не одно значение, а два, или ключ становится более сложным, и мне нужно расширить его другим полем. 
 
Я даже использую их, чтобы избежать аллокации замыкания с помощью таких методов, как  , который теперь принимает дополнительный аргумент. И во многих случаях, состояние также является кортежем.  
 
Эти фичи очень полезны, но я действительно хочу увидеть несколько улучшений: 
 
 
(****) Я знаю, что эта функция спорная, но я думаю, что это будет очень полезно. Мы можем дождаться типов  , но я не уверен, будут ли записи значимыми типами или ссылочными типами.
