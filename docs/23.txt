Фундаментальная уязвимость HTML при встраивании скриптов
homm
Чтобы описать суть проблемы, мне нужно рассказать, как вообще устроен HTML. ‚ы навернЯка в общих чертах представлЯли себе, но Я все равно коротко пробегусь по основным моментам, которые понадобЯтсЯ длЯ пониманиЯ. …сли кому-то не терпитсЯ, сразу 
.
HTML С это Язык гипертекстовой разметки. —тобы говорить на этом Языке, нужно соблюдать его формат, иначе тот, кто читает написанное, не сможет вас понЯть. Ќапример, в HTML у тегов есть атрибуты: 
’ут 
 С это имЯ атрибута, а 
 С это его значение. ‚ статье Я буду использовать квадратные скобки вокруг кода, чтобы было понЯтно, где он начинаетсЯ и заканчиваетсЯ. Џосле имени стои?т знак равенства, а после него С значение, заключенное в кавычки. ‡начение атрибута начинаетсЯ сразу после первого символа кавычки и заканчиваетсЯ сразу перед следующим символом кавычки, где бы он не находилсЯ. ќто значит, что если вместо 
 вы запишете 
, то значение атрибута 
 будет 
, а еще у вашего элемента будет три других атрибута с именами: 
, 
 и 
, но без значений.
…сли это не то, чего вы ожидали, вам нужно как-то изменить значение атрибута, чтобы в нем не встречалась кавычка. ‘амое простое, что можно придумать С просто вырезать кавычки.
’огда парсер HTML верно прочтет значение, но беда в том, что это будет 
 значение. ‚ы хотели 
, а получили 
. ‚ каких-то случаЯх такое различие может быть критичным.
—тобы вы могли указать в качестве значениЯ любую строку, формат Языка HTML предлагает возможность экранировать значениЯ атрибутов. ‚место кавычки в строке значениЯ вы можете записать последовательность символов 
 и парсер поймет, что в этом месте в исходной строке, которую вы хотите использовать в качестве значениЯ атрибута, была кавычка. ’акие последовательности называютсЯ HTML entities.
Џри этом, если в вашей исходной строке действительно была последовательность символов 
, у вас все еще есть возможность записать еЮ так, чтобы парсер не превратил еЮ в кавычку С длЯ этого надо заменить знак 
 на последовательность символов 
, то есть вместо 
 вам нужно будет записать в сыром тексте 
.
ЏолучаетсЯ, что преобразование из исходной строки в ту, которую мы запишем между двумЯ символами кавычек, ЯвлЯетсЯ 
. ЃлагодарЯ этим преобразованиЯм 
 в качестве атрибута HTML-тега, не вдаваЯсь в суть еЮ содержимого. ‚ы просто соблюдаете формат, и все работает.
‘обственно, так работает большинство форматов, с которыми мы сталкиваемсЯ: есть синтаксис, есть способ экранированиЯ контента от этого синтаксиса и способ экранированиЯ символов экранированиЯ, если вдруг такаЯ последовательность встречаетсЯ в исходной строке. Ѓольшинство, но неЙ
’ег <script> служит длЯ встраиваниЯ в HTML фрагментов, написанных на других Языках. Ќа сегоднЯшний день в 99% случаев это Javascript. ‘крипт начинаетсЯ сразу после открывающего тега <script> и заканчиваетсЯ сразу перед закрывающим тегом </script>. Џарсер HTML внутрь тега не заглЯдывает, длЯ него это просто какой-то текст, который он потом отдает в парсер Javascript.
‚ свою очередь, Javascript С это самостоЯтельный Язык с собственным синтаксисом, он, вообще говорЯ, никаким специальным образом не рассчитан на то, что будет встроен в HTML. ‚ нем, как в любом другом Языке, есть строковые литералы, в которых может быть что угодно. €, как вы уже должны были догадатьсЯ, может встретитьсЯ последовательность символов, означающаЯ закрывающий тег </script>.
—то тут должно происходить: переменной 
 должна присваиватьсЯ безобиднаЯ строка.
—то тут происходит на самом деле: ‘крипт, в котором объЯвлЯетсЯ переменнаЯ 
 на самом деле заканчиваетсЯ так: 
, что приводит к ошибке синтаксиса. ‚есь текст после него интерпретируетсЯ как чистый HTML и в него может быть внедрена любаЯ разметка. ‚ данном случае открываетсЯ новый тег <script> и выполнЯетсЯ зловредный код.
Њы получили тот же эффект, как когда в значении атрибута присутствует кавычка. Ќо в отличие от значений атрибута, длЯ тега <script> нет никакого способа экранировать исходный контент. HTML entities внутри тега <script> не работают, они будут переданы в парсер Javascript без изменений, то есть либо приведут к ошибке, либо изменЯт его смысл. 
 прЯмо говорит, что в содержимом тега <script> не может быть последовательности символов </script> ни в каком виде. Ђ стандарт Javascript не запрещает такой последовательности быть где угодно в строковых литералах.
ЏолучаетсЯ парадоксальнаЯ ситуациЯ: 
.
Ќа мой взглЯд это и ЯвлЯетсЯ уЯзвимостью разметки HTML, приводЯщей к уЯзвимостЯм в реальных приложениЯх.
Љонечно, когда вы просто пишете какой-то код, трудно представить, что вы напишете в строке </script> и не заметите проблем. Љак минимум, подсветка синтаксиса даст вам знать, что тег закрылсЯ раньше времени, как максимум, написанный вами код не запуститсЯ и вы будете долго искать, что произошло. Ќо это не ЯвлЯетсЯ основной проблемой с этой уЯзвимостью. Џроблема возникает там, где вы вставлЯете какой-то контент в Javascript, когда генерируете HTML. ‚от частый кусок кода приложений на реакте с серверным рендерингом:
‚ 
 </script> может поЯвитьсЯ в любом месте, где данные поступают от пользователЯ или из других систем. 
 не будет менЯть такие строки при сериализации, потому что они полностью соответствуют формату JSON и Javascript, поэтому они просто попадут на страницу и позволЯт злоумышленнику выполнить произвольный Javascript в браузере пользователЯ.
„ругой пример:
’ут в строки с соответствующим экранированием записываютсЯ 
 пользователЯ и 
, который пришел на сервер. €, если в 
 врЯд ли будет что-то кроме цифр, то в 
 злоумышленник может запихнуть что угодно.
Ќо на закрывающем теге </script> приколы не заканчиваютсЯ. Ћпасность представлЯет и открывающий тег <script>, если перед ним в любом месте есть символы 
, которые в обычном HTML обозначают начало многострочного комментариЯ. Џричем в этом случае вам уже не поможет подсветка синтаксиса большинства редакторов.
—то видит здоровый человек и большинство подсветок синтаксиса в этом коде? „ва тега <script>, между которыми находитсЯ параграф.
—то видит больной парсер HTML5? Ћн видит один (!) незакрытый (!) тег <script>, содержащий весь текст со второй строчки до последней.
џ до конца не понимаю, почему это так работает, мне понЯтно лишь, что встретив где-либо символы 
, парсер HTML начинает считать открывающие и закрывающие теги <script> и не считает скрипт законченным, пока не будут закрыты все открытые теги <script>. ’о есть в большинстве случаев этот скрипт будет идти до конца страницы (если только кто-то не смог внедрить еще один лишний закрывающий тег </script> ниже, хе-хе). …сли вы до этого не сталкивались с подобным, то можете подумать, что Я сейчас шучу. Љ сожалению, нет. ‚от скриншот DOM-дерева примера выше:
‘амое неприЯтное, что в отличие от закрывающего тега </script>, который в Javascript может встретитьсЯ только внутри строковых литералов, последовательности символов 
 и 
 могут встретитьсЯ и в самом коде! € будут иметь точно такой же эффект.
‘пецификациЯ HTML, помимо того, что запрещает использование легальных последовательностей символов внутри тега <script> и не дает никакого способа их экранированиЯ в рамках HTML, также советует следующее:
—то можно перевести как З‚сегда экранируйте последовательности "
" как "
", "
" как "
", а "
" как "
", когда они встречаютсЯ в 
 в ваших 
 и избегайте этих выражений в самом кодеИ. ќта рекомендациЯ менЯ умилЯет. ’ут делаетсЯ сразу несколько наивных предположений:
€, если первые два пункта выполнЯютсЯ хотЯ бы длЯ Javascript, то последний не выполнЯетсЯ даже длЯ него. Ќе всегда скрипт в HTML вставлЯет квалифицированный человек, это может быть какой-то генератор HTML. ‚от пример того, как с этим не справлЯетсЯ сам браузер:
Љак видите, строка с сериализованным элементом не будет распаршена в элемент, аналогичный исходному. Џреобразование DOM-дерево ? HTML-текст в общем случает не ЯвлЯетсЯ однозначным и обратимым. Ќекоторые DOM-деревьЯ просто нельзЯ представить в виде исходного HTML-текста.
Љак вы уже понЯли, способа безопасно вставить Javascript в HTML нет. Ќо есть способы сделать Javascript безопасным длЯ вставки в HTML (почувствуйте разницу). Џравда длЯ этого нужно быть предельно внимательным всЮ времЯ, пока вы пишете что-то внутри тега <script>, особенно если вы вставлЯете любые данные с помощью шаблонизатора.
‚о-первых, вероЯтность того, что у вас в исходном тексте (даже после минификации) не в строковых литералах встретЯтсЯ символы 
 крайне мала. ‘ами вы врЯд ли напишете что-то такое, а если злоумышленник что-то сможет написать прЯмо в теге <script>, то внедрение этих символов будет беспокоить вас в последнюю очередь.
ЋстаетсЯ проблема внедрениЯ символов в строки. ‚ этом случае, как и написано в спецификации, всего-то нужно заменить все "
" на "
", "
" на "
", а "
" на "
". Ќо беда в том, что если вы выводите какую-то структуру с помощью 
, то врЯд ли вы захотите потом еЮ распарсить еще раз, чтобы найти все строковые литералы и заэкранировать в них что-то. ’ак же не хочетсЯ советовать пользоватьсЯ другими пакетами длЯ сериализации, где эта проблема уже учтена, потому что ситуации бывают разными, а защититьсЯ хочетсЯ всегда и решение должно быть универсальным. Џоэтому Я бы советовал экранировать символы / иК! с помощью обратного слеша уже после сериализации. ќти символы не могут встречатьсЯ в JSON нигде кроме как внутри строк, поэтому простаЯ замена будет абсолютно безопасной. ќто не изменит последовательность символов "
", но она и не представлЯет опасности, если встречаетсЯ сама по себе.
’очно так же можно экранировать и отдельные строки.
„ругой совет С не встраивайте в тег <script> ничего вообще. •раните данные в местах, где трансформации длЯ вставки данных однозначны и обратимы. Ќапример, в атрибутах других элементов. Џравда смотритсЯ это довольно грЯзно и работает только со строками, JSON придетсЯ парсить отдельно.
Ќо, по-хорошему, конечно, если вы хотите нормально разрабатывать приложениЯ, а не аккуратно ходить по минному полю, нужен надежный способ встраиваниЯ скриптов в HTML. Џоэтому правильным решением считаю вообще отказатьсЯ от тега <script>, как от не безопасного.
…сли не использовать встраиваемые скрипты, то что тогда? Љонечно, подключать все скрипты извне С не вариант, иногда иметь какой-то Javascript с данными внутри HTML-документа очень удобно: нет лишних HTTP-запросов, не нужно делать дополнительных роутов на стороне сервера.
Џоэтому Я предлагаю ввести новый тег С <safescript>, содержимое которого будет полностью подчинЯтсЯ обычным правилам HTML С будут работать HTML entities длЯ экранированиЯ контента С и поэтому встраивание в него любого скрипта будет абсолютно безопасным.
Џри этом нет необходимости дожидатьсЯ реализации этого тега в браузерах. џ написал очень простой 
, который позволЯет использовать его прЯмо сейчас. ‚от всЮ, что длЯ этого нужно:
Љод внутри <safescript> выглЯдит ужасно и непривычно. Ќо это код, который попадет в сам HTML. ‚ шаблонизаторе, который вы используете, можно сделать простой фильтр, который будет вставлЯть тег и экранировать все его содержимое. ‚от так может выглЯдеть код в шаблонизаторе Django:
’акой подход позволЯет забыть об экранировании Javascript и избежать многих уЯзвимостей. € было бы очень здорово, если бы ребЯта, разрабатывающие спецификацию HTML, добавили такой скрипт в базовый набор или придумали какой-то другой способ решениЯ проблемы небезопасного встраиваниЯ скриптов в HTML.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

