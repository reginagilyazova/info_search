Научиться перехватывать необработанные сообщения или пример того, как SObjectizer обрастает новыми фичами…
eao197
Нам очень приятно, когда в   добавляются новые возможности, возникшие в результате подсказок и/или пожеланий пользователей SObjectizer-а. Хотя далеко  . Ведь, с одной стороны, у нас, как у команды разработчиков и старых пользователей SObjectizer-а, уже есть собственные стереотипы о том, как SObjectizer принято использовать. И не всегда получается сразу оценить «свежий взгляд со стороны», понять что реально хочет видеть пользователь во фреймворке и почему он не удовлетворен имеющимися средствами. С другой стороны, SObjectzer не такой уж и маленький фреймворк, добавление новых возможностей требует определенной осмотрительности. Нужно, чтобы новая функциональность не конфликтовала с уже имеющимися фичами. И, тем более, чтобы после добавления чего-то нового не сломалось то, что уже есть и давно работает. Плюс к тому, у нас есть пунктик по поводу сохранения совместимости между версиями SObjectizer-а, поэтому мы сильно против кардинальных изменений… 
 
В общем, добавление нового в SObjectizer — это всегда приятно с точки зрения увеличения возможностей фреймворка и повышения удобства его использования. Но далеко не всегда это так же приятно и просто с точки зрения реализации. 
 
Под катом небольшой рассказ о том, как в SObjectizer добавлялась одна новая фича. Может быть кому-то из читателей будет интересно посмотреть, как старый фреймворк адаптируется под запросы новых пользователей. 
 
 
Итак, все началось с того, что один из пользователей SObjectizer-а,  , обратил наше внимание на то, что в SObjectizer нет готовых удобных средств для выполнения эпизодических однократных взаимодействий между агентами. 
 
Оказалось, что имеется в виду вот что. Допустим, агент A хочет отослать запрос агенту B и хочет получить ответное сообщение от агента B. Но при этом агент A не хочет ждать ответа дольше, чем 5 секунд. Тривиальное решение «в лоб», которое сразу же приходит в голову, может выглядеть так: 
 
 
К сожалению, эта простая версия лишь является наглядной демонстрацией правдивости афоризма о том, что «любая сложная задача имеет простое, легкое для понимания неправильное решение». Здесь есть сразу несколько проблем. 
 
Первая проблема связана с отложенным сообщением A::reply_timed_out. Если ответ от агента B вовремя не пришел, то с reply_timed_out у нас все нормально. Мы его получаем, обрабатываем и забываем о нем. А вот что будет, если ответ от агента B пришел вовремя? Что произойдет с reply_timed_out? 
 
Оно все равно придет к агенту A. Ведь никто reply_timed_out не отменял. Значит, как только нить таймера SObjectizer-а отсчитает 5 положенных секунд, сообщение reply_timed_out будет доставлено агенту A. И мы его получим и обработаем не смотря на то, что нам оно уже не нужно. Что неправильно. Правильно было бы сделать так, чтобы сообщение reply_timed_out к нам не попадало после того, как мы получили reply от агента B. 
 
Самый надежный способ сделать это — это отменить подписку на reply_timed_out. Почему именно так — это тема отдельного большого разговора. Если кому-то интересно, можно отдельно поговорить на эту тему. Пока же ограничимся тем, что отписка от отложенного сообщения является «железобетонным» вариантом решения проблем с отложенным сообщением. 
 
Вторая проблема связана с тем, что вряд ли агенту A нужно будет подобным образом общаться только с агентом B. Скорее всего агент A обменивается сообщениями request/reply сразу с несколькими агентами. Соответственно, когда request улетает одновременно агентам B и C, то агенту A нужно как-то понимать, от кого прилетел ответ. Или чей ответ не был получен в течении 5 секунд. 
 
Вторая проблема более-менее удобно решается за счет отказа от использования собственного mbox-а агента A в качестве обратного адреса. Проще создавать новый mbox для каждого нового взаимодействия. И именно этот новый mbox будет использоваться и для получения ответа, и для отложенного сообщения именно для этого запроса. 
 
Однако, как только мы вводим новый mbox, мы должны позаботиться о том, чтобы mbox был удален после того, как он перестает быть нужным. Для этого мы должны удалять подписки на этот mbox. Если подписки не будут удалены, то mbox останется жить, а это приведет к постоянному росту потребляемой памяти — мы же будем создавать новые mbox-ы на каждый новый запрос, а удаляться эти mbox-ы не будут. 
 
В общем, если учесть эти две проблемы, то простое решение будет преобразовано в не очень простое: 
 
 
Получается уже не так просто и компактно, как хотелось бы. Но и это еще далеко не все. Так, в этом решении нет никакой exception safety. Нет явной отмены отложенного сообщения тогда, когда оно уже не нужно. Но, что еще важнее, если агент A захочет иметь не одно дефолтное состояние, как в примере выше, а несколько состояний, в каждом из которых ему нужно реагировать на сообщения по-разному, то все станет еще страшнее. Ну и еще страшнее все станет, если обмен между A и B будет требовать не одно ответное сообщение, а несколько. Скажем, если вместо reply будет successful_reply и failed_reply, то объем работы для разработчика агента A заметно увеличится. 
 
 
Маленькое отступление в сторону. Когда нам стало понятно, о чем нам говорит  , мы сами удивились. Ведь проблема действительно очевидна. Но почему же мы сами с ней не сталкивались? По крайней мере не сталкивались настолько часто, чтобы обратить на нее внимание и включить решение для этой проблемы в SObjectizer. 
 
Вероятно, здесь имели место два фактора. 
 
Во-первых, мы довольно быстро  . Там количество агентов невелико, между ними установлены стабильные связи, поэтому там таких проблем нет в принципе. 
 
Во-вторых, наверное, однократное разовое взаимодействие у нас чаще всего применяется между коротко живущими агентами. И для агента, который живет всего лишь для обработки одной-единственной операции, эти проблемы не актуальны. 
 
Как бы то ни было, невозможно не отметить тот факт, что как только твоим инструментом начинают пользоваться новые люди, так сразу же выясняется, что они хотят использовать инструмент совсем не так, как привык это делать ты сам. 
 
 
В итоге мы расширили свою надстройку над SObjectizer под названием  , добавив в нее поддержку т.н.  . Посредством асинхронных операций приведенный выше пример может быть переписан следующим образом: 
 
 
Подробнее о новых асинхронных операциях в so_5_extra можно прочитать  . 
 
Но речь сегодня пойдет не о том, как сделаны сами асинхронные сообщения. А о том, что потребовалось сделать в SObjectizer для того, чтобы асинхронные сообщения заработали в so_5_extra. 
 
 
В so_5_extra вошло две реализации асинхронных операций: time_unlimited, когда на время выполнения операции не накладывается вообще никаких ограничений, и time_limited, когда операцию нужно завершить за отведенное время. Выше как раз речь шла именно о time_limited-операциях, т.к. именно с их реализацией и была одна из основных загвоздок. 
 
Суть в том, что когда мы начинаем time_limited-операцию, то мы должны обязательно получить и обработать отложенное сообщение, которое и ограничивает время асинхронной операции. И вот с этим «обязательно» как раз-то было не все просто. 
 
Дело в том, что одной из ключевых фич SObjectizer-а являются  . Состояния позволяют агентам обрабатывать разные наборы сообщений в каждом из состояний. Или же обрабатывать одни и те же сообщения в разных состояниях по-разному. Но есть и оборотная сторона: если какое-то сообщение нужно обработать во всех состояниях, то нужно явно подписывать обработчик этого сообщения для каждого из состояний. Т.е. писать что-то вроде: 
 
 
Естественно, что это не самое хорошее и удобное решение. 
 
За счет использования возможностей иерархических конечных автоматов можно сделать проще, удобнее и надежнее: 
 
 
Теперь обработчик «по умолчанию» будет вызваться вне зависимости от того, в каком из состояний находится агент. 
 
Но, к сожалению, такой подход требует, чтобы агент изначально был спроектирован с использование иерархических конечных автоматов. Вряд ли асинхронными операциями из so_5_extra было бы удобно пользоваться, если бы они накладывали столь жесткое требование на пользователей: мол, хотите пользоваться асинхронными операциями — извольте создать в своем агенте родительское состояние. 
 
Да и не всегда это в принципе возможно сделать. Допустим, кто-то написал вам библиотеку агентов, в которой есть базовый тип basic_device_manager. Вы делаете свой собственный класс-наследний my_device_manager и вам в my_device_manager нужно использовать асинхронные операции. Если в basic_device_manager разработчик не сделал что-то вроде st_parent, то вы туда свой st_parent уже не добавите. 
 
В общем, требовалось сделать что-то, что позволило бы ловить сообщения, которые адресовались агенту, но которые агентом не были обработаны. Такие сообщения еще иногда называют  . 
 
 
 
Мы сделали так, что теперь разработчик может повесить собственный обработчик на сообщение, которое не было обработано «нормальным» обработчиком. Например: 
 
 
Теперь, если агент получает сообщение some_msg из почтового ящика some_mbox находясь в состояние st_first, то для обработки сообщения будет вызван normal_handler. А вот если агент будет находится в любом другом состоянии, то для обработки этого сообщение вызовется deadletter_handler. 
 
Эту фичу как раз и используют time_limited-операции. При активации операции вешается deadletter_handler на сообщение об истечении тайм-аута. И в каком бы состоянии агент не находился в момент прихода этого сообщения, сообщение будет получено и обработано. Что и позволяет завершить асинхронную операцию. Даже в случае, когда разработчик ошибся и не определил все нужные ему обработчики тайм-аутов. 
 
 
Первая мысль, которая возникла как только сформулировалась проблема deadletter handler-ов, была в том, чтобы снабдить каждого агента неким родительским состоянием. А все остальные состояния чтобы автоматически становились дочерними к нему. Т.е. была идея насильно впихнуть в каждого агента некое суперсостояние. Которое просто есть и с этим ничего не сделать :) 
 
Эта идея была очень привлекательной с точки зрения текущего механизма хранения и поиска подписок (этот механизм не так уж и прост). 
 
Так же эта идея очень красива с идеологической точки зрения. Иерархические конечные автоматы как они есть. 
 
Но пришлось от нее отказаться (может быть на время?). 
 
Главная причина отказа в том, что объект state_t является довольно-таки тяжеловесным. В зависимости от компилятора, стандартной библиотеки и параметров компиляции, state_t в 64-х битовом режиме может занимать от 150 до 250 байт. Если насильно добавлять суперсостояние каждому агенту, то «вес» каждого агента увеличивается на полторы-две сотни байт. Вот просто так, на ровном месте. Даже если этому агенту суперсостояние вообще не нужно. 
 
Была, да и есть, на самом деле, еще и другая причина. Суперсостояние для каждого агента — это слишком большое нововведение для SObjectizer-а, чтобы сделать его с бухты-барахты, 
 не взвесив тщательно все последствия. Есть у меня лично большие подозрения на тему того, 
 что стоит добавить суперсостояния в SObjectizer и ими начнут злоупотреблять. 
 
В общем, идея с суперсостоянием в работу над версией 5.5.21 не пошла. Но зарубка на память осталась. Возможно, она еще найдет свое воплощение. Если у кого-то есть соображения на этот счет, то интересно было бы услышать и пообсуждать. 
 
 
От идеи с суперсостоянием отказались, но текущий механизм хранения подписок все-таки менять не хотелось. Поэтому было найдено решение, в котором все-таки дополнительный объект state_t потребовался. Но   и все агенты ссылаются на него. 
 
Благодаря этому удалось использовать те же самые инструменты для регистрации deadletter handler-ов и для их поиска. Фактически, so_subscribe_deadletter_handler есть ни что иное, как  . Ну а поиск deadletter handler-а для сообщения — это всего лишь  , но не для текущего состояния агента, а для этого специального, невидимого состояния. Там, правда, есть   для случая, когда включен режим трассировки механизма доставки сообщений, но это совсем уже скучные детали. 
 
 
Когда я вычитывал эту статью перед публикацией, то ловил себя на мысли о том, что рассказывается какая-то тривиальщина. Ну вроде бы все просто и понятно. Только вот путь к этому «просто и понятно» оказался совсем не быстрым, не прямым и не очевидным. Если кому-то интересно, то следы эволюции идеи асинхронных операций можно найти в этой мини-серии блог-постов:  ,   и  . Хотя, как оказалось, даже в заключительном посте этой серии было описано отнюдь не результирующее решение. Пришлось еще наткнуться на серьезный собственный просчет и поломать голову над тем, как воспрепятствовать утечкам памяти при наличии циклических ссылок между объектами. Но это уже совсем другая история… 
 
 
 
Хочется поблагодарить всех, кто помогает нам развивать SObjectizer: тем кто пользуется SO-5 и высказывает свои соображения и предложения (отдельное спасибо здесь  ), тем, кто еще не пользуется SO-5, но помогает советами и не только (большущая благодарность, в частности,  ), да и просто тем, кому не лень ставить +1 в новостях о SObjectizer на различных ресурсах и звездочки   :) Большое вам всем спасибо! 
 
 
Мы собираемся начать работы над следующей версией SObjectizer-а под номером 5.5.22 уже в ближайшее время. Главная новая фича, которую мы хотим увидеть в 5.5.22 — это поддержка параллельных состояний для агентов. Агенты уже могут использовать продвинутые возможности иерархических состояний. Как то: вложенность состояний, shallow и deep-history для состояний, обработчики входа-выхода, временные лимиты на пребывании в состоянии. Но вот чего пока еще в SObjectizer не было, так это параллельных состояний. 
 
В свое время мы не стали их делать по каким-то причинам. Но практика показала, что кому-то из пользователей параллельные состояния нужные и облегчают им жизнь. Так что будем их делать. Все желающие приглашаются к обсуждению: любые конструктивные соображения, а особенно, примеры из практики и личного опыта будут нам очень полезны. 
 
Ну и вообще было бы интересно узнать какие у вас впечатления о SObjectizer-е, что нравится, что не нравится, что хотелось бы иметь в SO-5, что мешает… Ну и, естественно, мы готовы ответить на любые вопросы о SObjectizer-е.
