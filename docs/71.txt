Dive into Ethereum
Pavlov_dog
Сегодня платформа Ethereum стала одним из самых узнаваемых брендов блокчейн сферы, вплотную приблизившись по популярности (и капитализации) к Bitcoin. Но из-за отсутствия "полноценного" рускоязычного гайда, отечественные разработчики все еще не очень понимают, что это за зверь и как с ним работать. Поэтому в данной статье я попытался максимально подробно охватить все аспекты разработки умных контрактов под Ethereum.
Я расскажу про инструменты разработки, сам ЯП, процесс добавления UI и еще много интересного. В конечном итоге мы получим обычный сайт-визитку, но "под капотом" он будет работать на умных контрактах Ethereum. Кого заинтересовало — прошу под кат.
Эта статья не расчитана на тех, кто совсем не знаком с Ethereum (или технологией блокчейн вообще), поэтому объяснений базовых вещей вроде 
, 
 или 
 здесь не будет. Я подразумеваю, что вы хотя бы чуть-чуть в курсе происходящего. В противном случае полистайте статьи из списка ниже, а потом возвращайтесь :)
Больше ссылок на интересные статьи вы найдете в конце.
 Я работаю под Ubuntu 16.04, так что весь процесс установки, разработки и деплоя будет описан под эту ОС. Тем не менее все используемые инструменты кроссплатформенны (скорее всего, не проверял), так что при желании можете поэкспериментировать на других ОС.
Работа с Ethereum возможна через огромное число клиентов, часть из которых terminal-based, часть GUI и есть несколько гибридных решений. Своего рода стандартом является [Geth](), который разрабатывается командой Ethereum. Про него я уже писал в 
, но на всякий случай повторюсь.
Клиент написан на Go, устанавливается 
:
Сам Geth не имеет GUI, но работать с ним из терминала довольно приятно. 
 описан весь набор аргументов командной строки, я же опишу несколько самых популярных.
Вот команда, которую я чаще всего использую в работе: 
Geth довольно хорош, но в последнее время все чаще можно встретить другой клиент — Parity, написанный на Rust. Главным его отличием от Geth является встроенный web интерфейс, на мой взгляд, самый удобный среди всех ныне существующих. Установка:
По окончании загрузки запустите в консоли 
 и по адресу 
 можете найти сам кошелек.
Еще один плюс: Parity быстрее своих конкурентов. По крайней мере так утверждают авторы, но по моим ощущениям это действительно так, особенно в плане синхронизации блокчейна.
Единственный нюанс — своей консоли в parity нет. Но можно без проблем использовать для этих целей Geth:
Этот инструмент, в отличие от предыдущих, будет полезен только разработчикам. Он позволяет одной командой 
 поднять приватный блокчейн с включенным RPC протоколом, десятком заранее созданных аккаунтов с этерами на счету, работающим майнером и так далее. Весь список 
. По сути, 
 — это тот же 
, только на этот раз не надо тратить время на создание аккаунтов, включение / выключение майнера и прочие рутинные действия.
Установка — 
.
Самый популярный кошелек для Ethereum, хотя на самом деле он умеет намного больше. Вот 
, где step-by-step объясняется весь процесс работы с Mist. Скачать самую свежую версию можно со 
. Помимо работы с кошельком, есть возможность работы с контрактами.
Самая популярная IDE для разработки контрактов. Работает в браузере по адресу 
, поддерживает огромное число функций:
При этом нет автокомплита, что очень печально.
Еще одна IDE для разработки умных контрактов, написана на Meteor, работает из коробки. Для начала откройте новый терминал и поднимите ноду с включенным RPC интерфесом 
. После этого можете запускать саму IDE:
Далее открываете 
 и можете начинать работать:
Последний на сегодня инструмент для ускорения разработки умных контрактов. Это плагин для редактора Atom, устанавливается с помощью 
. Штука удобная, сам пользуюсь. Позволяет работать c JS EVM или подключиться к ноде через RPC. Компилирует контракт на 
, деплоит в сеть на 
. Ну и предоставляет неплохой интерфейс для работы с самим контрактом.
Если вам не нужен такой навороченный функционал внутри редактора, то для Atom есть отдельный плагин с подсветкой синтаксиса Solidity — 
. Последний по сути является 
, только конвертированный для работы в Atom.
Возможно, вы слышали про то, что можно писать контракты не только на Solidity, но и на других языках, например 
 (внешне напоминает Python). Но последний комит в develop ветке 
 был примерно полгода назад, так что, по-видимому, язык, увы, deprecated.
Поэтому писать будем только на Solidity. Пока что язык находится на относительно раннем этапе развития, так что никаких сложных конструкций или уникальных абстракций в нем нет. Поэтому отдельно рассказывать про него я не вижу смысла — любой человек с опытом в программировании сможет свободно писать на нем после 20 минут чтения 
. На случай, если у вас такого опыта нет, — ниже я довольно подробно прокомментировал весь код контракта.
Для самостоятельного обучения есть несколько очень хороших примеров с максимально подробными описаниями:
Еще раз отмечу (отличную!) 
 языка, 
 даже переведена на русский язык.
Самое время создать наш контракт. В конечном итоге это будет приложение-визитка, на которую мы поместим само "резюме":
Первым делом создадим шаблон контракта и 
. Она должна называться также как и сам контракт и вызывается лишь однажды — при загрузке контракта в блокчейн. Мы будем использовать ее для инициализации одной единственной переменной — 
. Как вы уже наверное догадались, в нее будет записан адрес того, кто залил контракт в сеть. А использоваться она будет для реализации функций администратора контракта, но об этом позже.
Следующим шагом добавим возможность указывать базовую информацию об авторе — имя, почту, адрес и так далее. Для этого будем использовать самый обычный 
, который нужно объявить в начало контракта:
Для того, чтобы иметь возможность "получать" от контракта эти данные, создадим следующую функцию:
Здесь все просто, стоит только отметить модификатор 
 — его можно (и нужно) использовать для тех функций, которые не изменяют 
 приложения. Главный плюс таких функций (sic!), в том что их можно использовать как обычные функции.
Теперь стоит задуматься о наполнении своего резюме контентом. В самом простом случае мы могли бы обойтись функцией вроде
Но в этом случае любой при желании смог бы изменить, например, наше имя, вызвав 
. К счастью, есть способ всего в одну строку пресечь любые такие попытки:
Так как нам еще не раз придется использовать подобную конструкцию (при добавлении нового проекта, например), то стоит создать специальный 
:
При желании, можно использовать другие способы авторизации, например по паролю. Хэш будет храниться в контракте и сравниваться с введенным при каждом вызове функции. Но понятно, что этот способ не такой безопасный, благо радужные таблицы и атаки по словарю никто не отменял. С другой стороны, наш способ тоже не идеален, так как если вы потеряете доступ к адресу 
, то ничего редактировать вы уже не сможете.
Следующим шагом создадим несколько 
 для описания проектов, образования, навыков и публикаций. Здесь все просто, структуры описываются точно так же как в Си. Но вместо того, чтобы описывать их в текущем контракте, вынесем их в отдельную блиблиотеку (в новом файле). Тем самым мы сможем избежать огромных простыней кода и структурировать наш проект.
Для этого в той же директории создадим новый файл 
 и библиотеку 
. А уже внутри нее опишем каждую из структур:
Теперь осталось только импортировать полученный файл
Самые сообразительные уже догадались, что нотация 
 означает создание динамического массива с элеметнами типа 
. А вот с 
 
 уже сложнее. По сути, он заменяет нам написание функции вроде 
 — компилятор сам создаст такую функцию. Называться она будет так же как и переменная, в нашем случае — 
.
Вы можете спросить — почему мы в самом начале не написали 
, а вместо этого сами создавали такую функцию? Причина банальна — 
 пока что не умеет работать c переменными, для которых ключом является динамический тип данных (
 именно такой тип).
Для этого нужно объявлять 
 как например 
.
 На всякий случай отмечу, что кроме локального файла, 
 умеет импортировать 
 файлы по ссылке на Github и даже 
 (это что-то вроде распределенного хранилища для Ethereum, подробнее 
)
Думаю многие из вас уже сами догадались, как стоит реализовать работу с новыми данными. Покажу на примере списка публикаций, в остальных случаях все аналогично:
С помощью параметра 
 мы избавились от написания отдельной функции для удаления последней публикации (костыльно, но мы ведь только учимся). Хотя нужно отметить, что такой способ избавления от элемента в массиве на самом деле не совсем корректный. Сам элемент конечно будет удален, но на месте индекса останется пустое место. В нашем случае это не смертельно (мы будем проверять пустоту отдельных элементов на стороне клиента), но, вообще говоря, про это не стоит забывать. Тем более что сдвинуть весь массив и уменьшить счетчик длины 
.
Как я уже сказал, модификатор 
 в строке 
 обеспечил нас функцией которая по индексу 
 вернет проект 
. Но мы не знаем, сколько у нас всего проектов, и здесь есть два пути. Первый — итерироваться по 
 до того момента, пока мы не получим ошибку о несуществующем элементе. Второй — написать отдельную функцию, которая вернет нам размер 
. Я пойду вторым путем, чуть позже скажу почему:
Заметьте, что мы не можем сравнить две строки привычным способом 
. Причина все та же, 
 — это динамический тип данных, работа с ними довольно болезненна. Так что остается либо сравнивать хэши, либо использовать функцию для посимвольного сравнения. В этом случае можете использовать популярную библиотеку 
, в ней есть такая функция.
В разных средах разработки процесс компиляции и деплоя разумеется отличается, поэтому я ограничусь Remix, как самым популярным.
Сначала, само собой, заливаем весь код (финальную версию можете найти в 
). Далее в выпадающем списке 
 выберите 
 — пока что протестируем контракт на JS эмуляторе блокчейна, чуть позже научимся работать и с настоящим. Если с контрактом все в порядке, то вам будет доступна кнопка 
 — нажимаем и видим:
Теперь, когда контракт залит в блокчейн (его эмуляцию, но не суть), можем попробовать вызвать какую-нибудь функцию и посмотреть, что из этого выйдет. Например можно сохранить в контракте email — для этого найдите функцию 
, заполните поле и нажмите кнопку с именем функции:
Функция ничего не возвращает, поэтому 
. Теперь можно запросить у контракта email: ищем функцию 
 и пробуем:
С остальными функциями предлагаю вам поэксперементировать самим.
Ниже я расскажу про самый распостраненный способ добавить UI к вашему контракту. Он позволяет с помощью JS и HTML создавать интерфейсы любой сложности, достаточно иметь доступ к рабочей ноде Ethereum (или ее аналогам).
Это JS библиотека, позовляющая использовать API Ethereum с помощью обычного JS. По сути с ее помощью вы просто подключаетесь ноде и у вас появляется что-то вроде консоли geth в браузере. Устанавливается через 
 или 
:
Вот пример работы с web3 через node.js (предварительно запустите 
или любую другую ноду с RPC интерфейсом):
Тоже самое, только из JS консоли браузера (не забудьте про 
)
То есть мы уже на этом моменте можем запустить ноду, синхронизировать ее с текущей цепочкой и останется только сверстать наше приложение. Но тут есть два тонких момента: во-первых, вам нужно синхронизировать блокчейн Ethereum, а вы этого скорее всего до сих пор не сделали.
Второй нюанс — RPC не имеет никакого встроенного механизма авторизации, поэтому любой желающий может узнать адрес вашей ноды из исходников JS и пользоваться ей в свое удовольствие. Тут конечно можно писать какую-нибудь обертку на Nginx с простейшей HTTP basic auth, но это как-нибудь в другой раз.
Поэтому сейчас мы воспользуемся плагином Metamask (увы, только для Chrome). По сути это и есть та прослойка между нодой и браузером, которая позволит вам использовать web3 в браузере, но без своей ноды. Metamask работает очень просто — в каждую страницу он встраивает web3.js, который автоматически подключается к RPC серверам Metamask. После этого вы можете использовать Ethereum на полную катушку.
После установки плагина, в левом верхнем углу выберите 
 и получите несколько эфиров на 
. На этом моменте вы должны получить что-то вроде такого (с чистой историей разумеется):
С Metamask задеплоить контракт в сеть так же просто, как и в случаем с JS EVM. Для этого снова открываем Remix и в списке 
 выбираем пункт 
 (скорее всего он выбран автоматически). После этого нажимаем Create и видим всплывающее окно:
Чуть позже надпись 
. сменится на информацию об опубликованном контракте — это значит что он попал в блокчейн. Адрес контракта можете узнать, открыв Metamask и нажав на запись вида:
Однако теперь, если вы захотите, например, вызвать функцию 
, то вам так же придется подтвержать транзакцию и ждать, пока она будет замайнена в блок.
Теперь дело за малым — надо научиться получать данные от контракта через Web3. Для этого, во-первых, надо научиться определять наличие web3 на странице:
Внутри 
 я определелил всю логику работы с контрактом, тем самым избегая ложных срабатываний и ошибок.
Теперь, когда вы со всем разобрались, можно браться за верстку и JS. Я использовал 
 и 
, для визуализации навыков добавил 
. Результат можете увидеть на 
:
Только что вы увидели, как можно довольно быстро создать приложение, которое самым непосредственным образом использует технологию blockchain. Хотя в погоне за простотой (все таки это обучающая статья) я допустили некоторые упрощения, которые по-хорошему допускать нельзя.
Например, мы используем чей-то шлюз (я про Metamask), вместо того, чтобы работать со своей нодой. Это удобно, но технология блокчейн в первую очередь — децентрализация и отсутствие посредников. У нас же всего этого нет — мы 
 парням из Metamask.
Другая, не такая критичная проблема, — мы забыли про стоимость деплоя контрактов и транзакций к ним. На практике, стоит десять раз подумать, прежде чем использовать 
 вместо 
, потому как такие вещи прежде всего влияют на затраты при работе с контрактом. Опять же, в примере я использовал 
, так что никаких денег мы не потратили, но при работе с 
 не стоит быть такими расточительными.
В любом случае, я надеюсь что статья оказалась полезной, если есть вопросы — задавайте в комментариях или пишите мне на почту.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

