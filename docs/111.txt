FPGA для программиста, конечные автоматы (verilog)
GolikovAndrey

Когда нужно преодолеть врожденную параллельность FPGA, и появляется желание заставить схему работать последовательно, по алгоритму, на помощь приходят конечные автоматы, про которые написано не мало академических и практических трудов.  
 
Например, очень популярной является работа:  . Всякий раз, когда специалисты решают обсудить, как   писать конечные автоматы, кто-то обязательно достает эту публикацию.  
 
Статья стала настолько авторитетной, что многие даже не стараются анализировать аргументы автора. В частности, бытует мнение, что профессионалы всегда используют двухчастный способ описания конечных автоматов, имеется ввиду, описание конечных автоматов в 2   блока. Это утверждение продолжает вызывать жаркие споры, и я хочу пояснить различия в описаниях конечного автомата с разным количество   блоков.  
 
В беседах с коллегами я понял, что споры о том, как надо писать конечные автоматы в 1 или 2, 3 always блока, связаны с разным представлением (осознанием) реализуемого алгоритма, разным типом мышления. Попробую показать это на примере.  
 
Я полагаю, что эта статья не первая статья о FSM и Verilog в вашей жизни, поэтому я не буду объяснять ни что такое конечный автомат, ни как он описывается на Verilog, а перейду сразу к делу. 
 
Представьте, вы сидите дома, вам нужно сходить в магазин, купить хлеба, и вернуться обратно. Реализовать такое поведение просто — это алгоритмическая последовательность действий, ее можно описать так:  
 
   
Для многих такое описание покажется естественным. Четкая последовательность действий, похожа на строки программы. Однако, тот же алгоритм можно описать и по другому: 
 
 
при этом 
 
 
Интересно, хоть кто-то сейчас подумал, что последний вариант логичнее, чем первый?  
 
Так или иначе, оба этих описания имеют представление в виде конечного автомата. Первое в виде описания с одним   блоком, а второе — с двумя или тремя. Оговорюсь, что описание в 2 и 3   блока — это близнецы-братья, отличаются только техническими нюансами, которые нам сейчас не важны. 
 
Покажем, как описания представляются в виде автомата: 
У нас есть состояния автомата: HOME_STATE, STREET_STATE, MARKET_STATE, CASHIER_STATE, есть выходы автомата (наши действия): GET_DRESSED_ACT, UNDRESS_ACT, TAKE_BREAD_ACT, PAY_MONEY_ACT  
 
Описание с 1   блоком, выглядит так: 
 
 
Теперь описание с 2  блоками: 
 
 
 
Хочу обратить внимание на особенности этих 2 описаний, которые и являются причиной священной войны за число блоков  .  
1   блок 
 
2   блока 
 
 
Автомат с 1   блоком в текущем состоянии определяет, какие действия он собирается делать дальше, не заботясь о том, что он делает сейчас. А автомат с 2   блоками, в текущем состояние определяет, что он делает сейчас, и его не заботит, что он будет делать дальше или делал до этого.  
 
Нельзя однозначно сказать какое поведение лучше или правильнее. Все сильно зависит от задачи, от реализуемого автоматом алгоритма. Для демонстрации изменим ситуацию. Теперь у вас есть  ,  ,  . Вы ходите на работу —  , в бар —  . В   вы ходите как из   по выходным, так и с   в пятницу.  
 
В первой реализации, с 1  , вам надо внимательно следить куда вы собираетесь идти чтобы случайно не начать   или  . Во второй реализации, с 2   блоками, вы защищены от этого. Тут все четко определено: состояние  , состояние  .  
 
С другой стороны, в описании с 2   блоками, придя в бар с работы, вы не сможете не пить пиво. Состояние в этой реализации жестко фиксирует действие  . А в описании с 1   блоком, ваши действия   определяются в момент выхода из прошлого состояния. С   вы можете пойти   и  . Каждый второй поход из   в   может заканчиваться  . Текущее состояние   никак вас не ограничивает. 
 
Оба автомата имеют свое место в проектах, просто нужно правильно определить, какие особенности будут полезны в конкретной ситуации.  
 
Если у вас сложная сеть переходов и в разные состояния вы попадаете многими путями, имеет смысл использовать схему с 2   блоками. У вас не будет шанса забыть задать какой то из выходов автомата при очередном переходе.  
 
С другой стороны, если вы пишите простой автомат с практически линейной структурой, можно использовать описание с 1   блоком. Фактически вы задаете последовательность на выходе, а состояния используете просто для организации последовательного выполнения. Так как выходы автомата не зависят от текущего состояния, не надо будет прописывать их значение в каждом состоянии, описание будет короче и логичнее.  
 
В статье, с которой мы начали, хорошо показано почему надо использовать описания с 2 и 3   блоками, а описание с 1   блоком отмечено как самое плохое. Автор рекомендует избегать такого описания. Поэтому хочется привести пример реального интерфейса удобного для описания в 1   блок и защитить данный вид описания. Для сравнения я приведу тот же автомат описанный в 3   блока. Необходимо 3, а не 2 блока, потому, что мы будем использовать регистровые выходные сигналы.  
 
И так, у нас есть модуль, который реализует запись в асинхронную память. На вход модуль принимает строб чтения либо записи, данные и адрес для записи, адрес для чтения. На выход модуль выдает сигнал завершения чтения или записи и считанные данные. Модуль управляет простой асинхронной памятью, имеющей следующие временные диаграмы работы. 
 
 
 
Основной смысл модуля по стробу чтения либо записи «развернуть времянку», выдержать заданные интервалы, а по завершению выдать 1 тактовый сигнал готовности. Нам необходимо соблюдать следующие интервалы 
 
 
Интервалы мы будем измерять в количестве тактов входной частоты и зададим интервалы константами READ_SETUP, READ_PULSE, READ_HOLD и WRITE_SETUP, WRITE_PULSE, WRITE_HOLD. 
 
Описание с 1   блоком: 
 
 
 Описание с 3   блоками: 
 
 
Вот результат моделирования работы описаний 
 
 
 
Как мы видим, ведут они себя одинаково и соответствую желаемым временным диаграммам памяти. Описание в 3   блока получилось в большее число блоков, иначе блок задания выходов сильно бы усложнился. Заряжать счетчик, сохранять данные для записи в память и обратно нам надо в одном конкретном такте. Для этого нужно либо добавлять однотактные состояния в автомат, либо создавать конструкции выделения этих тактов. Я предпочел второй вариант и вынес конструкции в отдельные блоки, чтобы не усложнять блок задания выходов. 
 
Так или иначе, в этом примере мы видим насколько больше получается описание в 3   блока (брутто 287 строк против 181). В нем больше мест, где можно совершить ошибку. Отлаживается оно тоже сложнее. Если вы просматривали эти два описания, то могли заметить, что в первом описании вся картина работы видна сразу, а во втором мы всегда видим какую то часть. Полная картина разнесена по всему файлу.  
 
Разбирать так описанный чужой автомат отдельное «удовольствие». Особенно, если условия переходов зависит от выходов автомата (в нашем случает состояние задает счетчик, а счетчик задает условие перехода). Сначала смотришь значение выходов в текущем состоянии, потом летишь в блок переходов и смотришь, куда мы переходим в данном состоянии и при таком значении выходов. Потом опять мотаешь в блок задания выходов, смотришь их изменения от нового состояния.  
 
Автомат описанный в 2   блока анализируется чуть проще, у него выходы и переходы часто лежат рядом в одном блоке, но ровно до момента, пока мы не захотим защелкнуть состояние выхода в регистр. Тут начинают появляться регистры с парными комбинаторными значениями их следующего состояния, потом начинают добавляться условия защелкивания и мы возвращаемся к исходному упражнению.  
 
Надеюсь теперь описание с 1   блоком, потеряет титул «самое плохое описание, старайтесь его избегать». Конечно не стоит всегда использовать только этот вид описания. При ветвистых сетях переходов 1 блоковое описание правда неудобно. Быстро разрастается по объему кода и перестает управляться. Однако выкидывать его из арсенала разработки однозначно не стоит.
