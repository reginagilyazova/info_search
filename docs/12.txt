Задействовать для простых тестов наследование, полиморфизм и шаблоны? Почему бы и нет…
eao197
Язык C++ сложен. Но его сложность проистекает из сложности задач, которые решаются с помощью C++. Каждая фича, которая была добавлена в C++, была добавлена не просто так, а для того, чтобы дать возможность справиться к какой-то проблемой. Ну а уж сочетание существующих в C++ фич делает язык чрезвычайно мощным инструментов. Конкретному примеру того, как это происходит на практике, и посвящена данная статья. 
 
Добавлю еще, что одним из мощных стимулов к написанию данной статьи стало то, что очень часто на глаза попадаются объемные  обсуждения на тему «ООП не нужно» и, особенно, «шаблоны-дженерики на практике почти никогда не нужны». Мне, как далеко не молодому программисту, начинавшему в 1990-ом как раз с инструментов, в которых не было ни ООП, ни шаблонов-дженериков, странно сталкиваться с подобными точками зрения. Но, чем дальше, тем чаще с ними сталкиваешься. Особенно со стороны приверженцев новых языков программирования, вроде Go или Rust-а. 
 
Сложно сказать, чем это вызвано. Может быть людей перекормили ООП (а это так и было)… Может быть задачи за несколько минувших десятилетий сильно поменялись (а это так и есть)… Может быть и просто «вот и выросло поколение»… Как бы то ни было, можно попробовать на примере из реальной жизни показать, что все не так однозначно ©. 
 
Итак, о чем пойдет речь? 
 
 
Мы недавно выпустили новую версию своего OpenSource-фреймворка, где добавили  . И эту новую фичу нужно было протестировать. Совсем несложными тестами. В одном тесте нужно было проверить, что программист может установить deadletter handler, в другом — что пользователь может отменить deadletter handler. 
 
Тесты простые, но в них есть одна сложность: нужно было проверять одну и ту же функциональность в разных условиях. Ну, например, deadletter handler может быть повешен на сообщение из разных типов почтовых ящиков. Сообщение, на которое вешается deadletter handler может быть обычным иммутабельным сообщением, может быть обычным мутабельным сообщением, может быть сигналом (поясню: обычные сообщения отличаются от сигналов, поэтому доставка сообщения отличается от доставки сигнала). Сам deadletter handler может быть представлен как указателем на метод класса-агента, так и лямбда-функцией. 
 
А поскольку в SObjectizer код, реализующий deadletter handler-ы, активно использует шаблоны, то для проверки правильности работы шаблонов нужно было в тестах покрыть все разумные сочетания этих условий. 
 
Поясню для тех, кто не очень хорошо знаком с особенностями C++: если, например, шаблонная функция нигде в коде не вызывается, то некоторые компиляторы (вроде старых версий Visual C++) даже не всегда проверяют исходный код этой функции на наличие элементарных ошибок. Поэтому для того, чтобы быть уверенным, что с реализацией шаблона все нормально, нужно, чтобы шаблонные функция или класс были проинстанциированы явно или неявно. Надежнее всего этого достичь через явное использование шаблонной функции/класса в тесте. 
 
 
Конечно же, есть очень простое решение, которое заключается в том, чтобы создать собственный класс под каждый тестовый случай и выполнить все соответствующие действия внутри этого класса. 
 
Так, для сочетания MPMC-mbox+обычное иммутабельное сообщение+указатель на метод получился бы такой класс: 
 
 
А для сочетания MPMC-mbox+обычное иммутабельное сообщение+лямбда-функция потребовался бы очень похожий класс, но с небольшими изменениями: 
 
 
Тогда как для случая direct_mbox+обычное мутабельное сообщение+лямбда функция изменений потребовалось бы больше, но все равно код был бы довольно похожим: 
 
 
Надеюсь, идея понятна. 
 
Всего таких классов потребовалось бы десять штук. Что сразу же отбивало желание двигаться в этом направлении. Т.к. в таком количестве копипасты очень легко ошибиться. Кстати говоря, когда эти тесты только появились, то была забыта пара возможных тестовых случаев. Но когда об этом вспомнили, то забытые сочетания буквально несколькими строчками были добавлены в соответствующие тесты. А вот если бы пришлось создавать отдельный класс под каждый тестовый случай, то для устранения первоначального просчета потребовалось бы больше кода и внимания. 
 
 
Поскольку у меня есть жесткий пунктик по поводу копипасты в коде и неспроста, то был выбран другой путь. Через использование шаблонов. И, в одном месте, шаблона шаблонов. К чему затем еще добавилось и наследование с полиморфизмом. Но начнем с простого теста, в котором достаточно только шаблонов. 
 
 
Итак, у нас есть три фактора, которые нужно комбинировать между собой. Два из них — тип mbox-а и тип сообщения/сигнала — легко представить в виде параметра шаблона. Не просто с третьим: чем именно реализуется deadletter handler — указателем на функцию или лямбдой. Ну и ладно. Цель же не в том, чтобы избавиться от копипасты совсем. Цель в том, чтобы обойтись самым необходимым ее минимумом. 
 
Поэтому было сделано два шаблонных класса. Первый для случая, когда deadletter handler реализуется указателем на метод: 
 
 
Второй — для случая лямбда функции: 
 
 
Можно заметить, что эти шаблонные классы очень похожи на те примеры кода, которые были показаны выше. Только для простого теста, проверяющего установку deadletter handler-а, теперь достаточно всего двух классов. А не десяти. 
 
Надеюсь, с параметром шаблона под названием Msg_Type все понятно. Это будет тип сообщения или сигнала, которое тестовый агент должен отослать и получить. В тесте для этих целей будут использоваться следующие определения: 
 
 
Ну и при инстанциировании шаблонов pfn_test_case_t и lambda_test_case_t будут использоваться test_message, so_5::mutable_msg<test_message> и test_signal. С этим все просто. 
 
А вот с параметром Mbox_Case немного сложнее (хотя, если C++ вы знаете хорошо, то ничего сложного там нет вообще). Этот параметр определяет, какой именно mbox должен использоваться в тестовом случае: MPMC-mbox, который следует создавать специально, или же direct_mbox, который уже есть у каждого агента. 
 
В наших тестах в качестве Mbox_Case используются два очень простых типа: 
 
 
Экземпляр класса direct_mbox_case_t сохраняет у себя ссылку на агента для того, чтобы в своем методе mbox() возвращать direct_mbox этого агента. А экземпляр класса mpmc_mbox_case_t у себя в конструкторе создает экземпляр MPMC-mbox-а и возвращает ссылку на него в своем методе mbox(). 
 
Получается, что когда, например, класс pfn_test_case_t параметризуется direct_mbox_case_t, то в pfn_test_case_t::m_mbox_holder хранится ссылка на сам экземпляр pfn_test_case_t и при вызове m_mbox_holder.mbox() возвращается direct_mbox() самого агента. 
 
А когда pfn_test_case_t параметризуется mpmc_mbox_case_t, то в pfn_test_case_t::m_mbox_holder лежит экземпляр отдельного MPMC-mbox, который создается при конструировании экземпляра pfn_test_case_t. 
 
Ну и тоже самое получается для lambda_test_case_t. 
 
Итак, мы получаем возможность создавать вот такие сочетания для тестовых случаев: 
 
 
 
Еще по поводу параметра Mbox_Case. У нас используются классы. Хотя можно было параметризовать тестовые классы и функцией, которая бы возвращала mbox_t. Т.е. можно было бы сделать так: 
 
 
Принципиально бы это ничего не поменяло. Но первое, что пришло в голову — это именно классы, они и пошли в реализацию. 
 
 
А вот шаблон шаблонов, о котором упоминалось выше, потребуется лишь для того, чтобы чуть-чуть упростить процедуру создания тестовых агентов. В общем-то, без него вполне можно было бы обойтись и писать что-то вроде: 
 
 
Но лучше ввести вспомогательную шаблонную функцию: 
 
 
И потом уменьшить себе количество работы и сделать код создания тестов более читаемым: 
 
 
И вот introduce_test_agent уже и есть тот самый «шаблон шаблонов», т.е. шаблонная функция, одним из шаблонных параметров которой является другой шаблон. 
 
 
Разобранный выше тест был очень простым, там достаточно было отослать всего одно сообщение, поэтому и тестовые агенты в нем были простыми. А вот следующий тест, проверяющий то, что пользователь может отменить deadletter handler, уже посложнее. Для того, чтобы разобраться с ним для начала посмотрим, как должен работать агент для тестового случая (для простоты берем пока только обычное иммутабельное сообщение test_message): 
 
 
Опять же, чтобы было проще разобраться с последующим кодом, покажем, как бы выглядел агент, написанный «в лоб» для конкретного тестового случая. Самый простой вариант, с direct_mbox-ом и обычным иммутабельным сообщением test_message: 
 
 
Т.е. есть счетчик входов в deadletter_handler (атрибут m_deadletters с нулевым начальным значением). Внутри deadletter_handler() этот счетчик проверяется на ноль и инкрементируется. Если deadletter_handler() будет вызван повторно, то тест провалится. 
 
Метод deadletter_handler отсылает два сообщения. Первое должно быть проигнорировано. Второе должно привести к завершению работы теста (подписка на сигнал finish идет в so_define_agent). 
 
Ну и самый первый экземпляр test_message отсылается в so_evt_start. Т.е. при старте агента. 
 
Однако, это не шаблонный класс. Да еще и заточен под конкретный тестовый сценарий. Как сделать из него шаблон, который можно было бы параметризовать двумя параметрами Mbox_Case и Msg_Type, как в предыдущем простом тесте? 
 
 
Очевидное решение было бы в том, чтобы взять классы pfn_test_case_t и lambda_test_case_t из простого теста и просто переделать каждый из них под новую логику работы. 
 
Но это решение нельзя назвать хорошим по очевидной же причине: слишком большой объем дублирующегося кода оказывается в каждом из классов. Соответственно, если допустить ошибку в первой реализации, то она автоматически распространяется на оба класса, но ее устранение требует модификации не одного класса, а обоих. Так же, если потребуется поменять логику поведения, то так же потребуется модифицировать оба класса, а не один. (А логику работы довелось поменять, т.к. изначально использовалась более сложная логика, но в процессе написания статьи выяснилось, что можно сделать заметно проще. Это изменение логики оказалось элементарным и не потребовалось переделывать два независимых друг от друга класса.) 
 
 
Итак, нам нужно вынести общие части из pfn_test_case_t и lambda_test_case_t в какой-то общий класс. И т.к. классы агентов в SObjectizer-е должны наследоваться от so_5::agent_t, то скорее всего этот общий класс будет базовым и для pfn_test_case_t, и для lambda_test_case_t. 
 
А вот один ли это будет класс? Давайте посмотрим. 
 
Можно обратить внимание на то, что в демонстрационном test_case_specific_agent_t есть как куски кода, которые зависят от параметров шаблона, так и куски кода, которые от параметров шаблона не зависят. Скажем, наличие состояния st_test и обработчик сигнала finish от параметров шаблона не зависят. А вот установка и отмена deadletter handler-а, отсылка тестового сообщения — зависят. 
 
Это дает нам возможность разбить общий код на две части. Первая часть не будет шаблонной. Для реализации этой части нам потребуется вот такой класс: 
 
 
Можно увидеть, что здесь сосредоточена изрядная часть прикладной логики тестового агента. И нет ничего, что зависело бы от параметра шаблона. 
 
Однако, уже в nontemplate_basic_part_t нужно выполнить два действия, которые зависят от Msg_Type — это отмена deadletter handler-а и отсылка еще одного экземпляра Msg_Type. Внутри nontemplate_basic_part_t мы знаем, где и когда эти действия должны быть выполнены, но не можем их выполнить. 
 
Поэтому мы делегируем выполнение этих действий наследнику через чистый виртуальный метод do_next_step(), который и должен быть переопределен в каком-то из классов-наследников. 
 
Наследником же, в котором do_next_step() определяется, будет уже шаблонный класс следующего вида: 
 
 
Тут мы уже видим привычный трюк с атрибутом m_mbox_holder типа Mbox_Case. А так же мы видим реализации виртуальных методов do_next_step (отмена deadletter handler-а и отсылка второго экземпляра Msg_Type) и so_evt_start (отсылка первого экземпляра Msg_Type). 
 
Получается, что nontemplate_basic_part_t и template_basic_part_t уже содержат 95% нужной тестовому агенту функциональности. Осталось всего ничего — сделать pfn_test_case_t и lambda_test_case_t в которых бы устанавливался deadletter handler нужного вида. 
 
Вот так это будет выглядеть: 
 
 
Тут просто классическое наследование с перекрытием виртуального метода предка для того, чтобы расширить его поведение: в so_define_agent() сперва вызывается so_define_agent() из базового класса, после чего устанавливается deadletter handler должного вида. 
 
Вот в итоге и получается старое доброе ООП, с наследованием (реализации) и полиморфизмом. Да еще и обильно сдобренное обобщенным программированием. 
 
 
Не хочу, чтобы у читателей возникло ощущение, будто описанный подход является единственно верным в данной ситуации. И что нельзя было сделать по-другому. Наверняка можно было. И, наверняка, даже в этом подходе что-то можно было бы сделать еще проще и лаконичнее. В конце-концов, то, что было показано в статье, было написано буквально на коленке за полчаса, проверено, исправлено и забыто. А потом еще раз исправлено и еще раз забыто. Что лично меня убеждает в том, что подобный подход к реализации тестов вполне себе оправдан. 
 
Смысл статьи должен был быть в том, чтобы показать, как возможности, которые некоторыми разработчиками считаются слишком сложными и от использования которых стараются держаться подальше, могут облегчить жизнь буквально на ровном месте. 
 
 
ООП — это всего лишь инструмент. Не религия, не болезнь. Всего лишь инструмент. Где-то он уместен, где-то нет. Скажем, если вам нужно делать сложную и большую библиотеку, то ООП может вам пригодиться. Если делаете небольшое и несложное приложение, то может и не пригодиться. А может и наоборот. Тут все зависит как от предметной области, так и от ваших знаний и опыта. Ну и от религиозных пристрастий, конечно же. 
 
Аналогично и с обобщенным программированием. Это всего лишь инструмент. Вас никто не заставляет его использовать, когда в этом нет нужды. 
 
Но вот мне лично не очень удобно, когда набор доступных мне инструментов преднамеренно ограничивается. Либо путем изъятия ООП (или превращения ООП в какое-то жалкое подобие оного). Либо путем изъятия шаблонов-дженириков. Еще хуже, когда нет ни того, ни другого. Поскольку эти инструменты были созданы для упрощения работы программиста. Странно от них отказываться по доброй воле. 
 
Ну а C++, при всех своих недостатках, хорош тем, что позволяет использовать и то, и другое. Да еще в самых разных сочетаниях. Другой вопрос, как научиться использовать и то, и другое (и еще кучу возможностей C++) по месту и в меру. Но это уже совсем другая история… :)
