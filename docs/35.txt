Функциональность отношений
vdbms
‚ классических релЯционных базах данных бинарнаЯ свЯзь кортежей основана на использовании ключей: первичных и внешних. Џри этом, интерпретациЯ этой свЯзи осуществлЯетсЯ за пределами логической структуры базы данных, где она (интерпретациЯ) может иметь достаточно произвольный характер. …стественно, в рамках ограничений, предписанных релЯционной моделью.



‚ объектной же парадигме длЯ реализации свЯзи объектов используют их идентификаторы. Џричем, если свЯзи объектов придать строгую симметричную форму: в виде пары прЯмаЯ | обратнаЯ ссылка, то это позволЯет практически полностью заменить Select естественной навигацией по ссылкам. Ќо что не менее важно, симметричнаЯ форма делает свЯзь объектов полноправным и самостоЯтельным элементом логической структуры базы данных, обладающим собственным поведением и функциональной зависимостью от других действующих свЯзей.



ЌастоЯщаЯ статьЯ посвЯщена рассмотрению самых различных поведенческих аспектов свЯзи объектов, реализациЯ которых позволЯет интегрировать значительную часть бизнес-логики приложениЯ непосредственно в логическую структуру базы данных, тем самым избавлЯЯ разработчика от рутины кодированиЯ.



(Ђвтор позволил себе отклонитьсЯ от общепринЯтых терминологических канонов, желаЯ придать изложению чуть больше образности).



‘ 
 точки зрениЯ свЯзь двух объектов следует понимать исключительно как взаимный обмен идентификаторами, по принципу Р ЗЯ тебЯ вижуИ, и не более того. Џри этом сам объект Р это экземплЯр класса данных, а свЯзь объектов класса Р практическаЯ реализациЯ правил, устанавливаемых декларацией 
 С экземплЯра одной из четырех фундаментальных абстрактных сущностей, используемых длЯ моделированиЯ предметной области. 



Љаждый из свЯзываемых отношением классов получает в свое владение ссылочный атрибут, типизированный оппозитным классом отношениЯ, значением которого в объекте класса становитсЯ идентификатор объекта оппозитного класса. Ћтношение классов не только устанавливает правила свЯзи объектов, но и служит естественным контекстом (транспортом и условием) длЯ организации взаимодействиЯ атрибутов, локализованных в разных классах.





’ип отношениЯ устанавливает 
 объектов, производных от свЯзанных отношением классов. Љак известно, вариантов этой меры всего три: 
, 
, и 
.



Ћтношение типа 
, которое удобно именовать 
, имеет Явно выраженный вектор причинности: первичным получателем значениЯ (ссылки) всегда ЯвлЯетсЯ ссылочный атрибут на стороне У
У, а значением атрибута на стороне У
У будет производный список значений (ссылок). Ћтсюда и возникает часто используемое далее терминологическое деление атрибутов этого отношениЯ на 
 и 
.



‚ полностью симметричном отношении 
 (оно же Р 
), каждый из равноправных ссылочных атрибутов может выступить в качестве инициатора созданиЯ свЯзи объектов, и быть первичным получателем значениЯ. „еление на атрибуты прЯмой и обратной ссылки в таком отношении носит чисто ситуационный характер. € это при том, что один из них получит свое значение как следствие присвоение значениЯ оппозитному атрибуту.



ЏонЯтийный смысл отношениЯ 
 весьма неоднозначен, что делает его предметом отдельного рассмотрениЯ.



ѓрафическое представление множественного и унитарного отношений, которое далее будет использовано в иллюстрациЯх, выглЯдит как-то так:



’акаЯ нотациЯ используетсЯ потому, что графический образ стрелки интуитивно ассоциируетсЯ как с образом 
, так и с образом спискового атрибута обратной ссылки. Њаркировка ссылочного атрибута типом и наименованием не ЯвлЯетсЯ обЯзательным элементом изображениЯ. ‘сылочный атрибут типизирован оппозитным классом отношениЯ, и, соответственно, заимствует наименование этого класса.





‘имметриЯ свЯзи объектов обусловлена причинно-следственной зависимостью значений ссылочных атрибутов свЯзываемых объектов. Љак и всЯкаЯ другаЯ зависимость, она реализуетсЯ 
, который далее будем называть 
. ‘сылочный соединитель априори 
, что обеспечивает перманентную логическую 
 и 
 ссылочных значений. ‚ своей работе ссылочный соединитель использует, помимо собственно ссылочных атрибутов, также и 
 
 и 
. „екларациЯ соединителЯ множественного отношениЯ выглЯдит так:


‘лужебный атрибут 
 типизирован собственным классом, и в объекте класса хранит собственный идентификатор этого объекта (
). €менно этот атрибут используетсЯ всеми типами отношений в качестве источника значениЯ, передаваемого соединителем отношениЯ однотипному с ним атрибуту обратной ссылки.



‘лужебный атрибут 
 используетсЯ соединителем отношениЯ в качестве 
. Џри логическом удалении объекта класса 
, его атрибут 
 будет инициализирован, что породит вызов метода 
 в адрес базового сокета соединителЯ, что в свою очередь приведет к вызову в адрес атрибута 
.{A} метода 
 с ЗпустымИ значением и ключом, и в результате соответствующаЯ запись будет изъЯта из списка обратных ссылок 
.{A}.



‚ качестве атрибута 
 (
 соединителЯ) по умолчанию выступает 
 класса. ‡начение этого атрибута используетсЯ соединителем как ключ, в пару к передаваемому значению С 
 атрибута 
. Џолучающий эту пару атрибут обратной ссылки 
.{A} обладает 
, который непосредственно и формирует сам список обратных ссылок.



Ќу а собственно атрибут прЯмой ссылки 
.[B] ЯвлЯетсЯ всего лишь 
, который предоставлЯет соединителю идентификатор 
 целевого объекта. Љогда в процессе реализации ссылки атрибут 
.[B] получит хранимое значение, то он вызывает в адрес базового сокета соединителЯ метод 
, что в свою очередь приведет к вызову в адрес атрибута 
.{A} метода 
 с 
 объекта и ключом, и в результате в список обратных ссылок B.{A} будет добавлена новаЯ запись. „алее, любое последующее изменение значений атрибутов 
 и прЯмой ссылки 
.[B] будет сопровождатьсЯ последовательными вызовами 
 и 
 с соответствующими изменениЯми в списке(ах) обратных ссылок.



‚ унитарном отношении очевидным образом не используетсЯ 
контекст, но зато присутствуют два ссылочных соединителЯ, которыми обеспечиваетсЯ зеркальнаЯ симметриЯ реализации:


Џри пристальном взглЯде на представленную декларацию может показатьсЯ, что имеютсЯ все предпосылки длЯ зацикливаниЯ процесса присвоениЯ ссылочного значениЯ, но это не так. Њетод 
 не порождает производные рекурсивные вызовы, если значение, полученное им извне, эквивалентно уже имеющемусЯ в наличии.





Џомимо двух ссылочных атрибутов, в образовании отношениЯ задействован как минимум один соединитель, объединЯющий набор сокетов с соответствующим образом установленными флагами. •очетсЯ подчеркнуть, что весь этот объем деклараций скрыт за фасадом визуального 
 модели данных, использующего предопределенные методы и формы представлениЯ абстрактного мета-отношениЯ длЯ созданиЯ его экземплЯров. ‚се, что требуетсЯ конструктору длЯ созданиЯ экземплЯра отношениЯ Р это его тип и дескрипторы свЯзываемых классов.



’акже хочетсЯ лишний раз подчеркнуть: ни 
, ни 
, не ЯвлЯютсЯ сущностЯми 
, и никак ею не интерпретируютсЯ. Њодель данных оперирует только классами, атрибутами и сокетами. Ћтношение и соединитель ЯвлЯютсЯ сущностЯми 
, котораЯ в свою очередь ЯвлЯетсЯ 
 (формой представлениЯ) модели данных.





ђассмотрим такую операцию, как передача 
 со 
 на 
: в объекте 
 необходимо адресовать сразу два объекта 
. ђеализуетсЯ такаЯ потребность простым увеличением 
, с заменой атомарной формы хранениЯ производных значений ссылочного атрибута 
.[B] на 
 (массив).


 “величиваЯ мощность множественного отношениЯ (кратность ссылки), конструктор модели создаст у атрибута прЯмой ссылки дополнительный элемент, и к нему еще один соединитель отношениЯ, аналогичный уже существующему, который использует новый элемент в качестве источника адресного указателЯ (
-контекст). Ћбратим внимание С увеличение мощности не повлиЯло на декларации атрибута обратной ссылки 
.{A}, за исключением добавлениЯ еще одного входЯщего сокета. (Ќа этом и последующих рисунках показаны только необходимые по смыслу контексты).



Ђналогичным образом реализуетсЯ увеличение мощности унитарного отношениЯ.


 ’ак как этот тип отношениЯ обладает дополнительной внутренней симметрией, то количество элементов у ссылочных атрибутов на обеих сторонах отношениЯ всегда будет одинаковым.




‚ свою очередь, атрибут обратной ссылки множественного отношениЯ может обеспечить существование более чем одного списка. Џо умолчанию, первый (основной) список использует в качестве ключа базовый атрибут класса (длЯ 
 это будет атрибут 
). Џредположим, что длЯ каких либо целей требуетсЯ еще один список с другим порЯдком сортировки, например, по сумме накладной 
. ‘оздаваЯ декларацию нового списка, конструктор отношениЯ создаст у атрибута обратной ссылки дополнительный элемент (A2), а также дополнительный ссылочный соединитель. Ќовый соединитель аналогичен первичному, но в качестве источника ключа использует уже не 
, а атрибут 
. 
 Ћбратим внимание и подчеркнем: добавление нового списка не изменЯет мощности отношениЯ.



…сли в свойствах списка указать дополнительный логический контекст, то в него попадут только те записи, длЯ которых значением контекста будет 
. ’акаЯ опциЯ будет полезна например, при ведении Убело-серойУ бухгалтерии. Ђ так как все три контекста базового ссылочного соединителЯ уже использованы, то можно воспользоватьсЯ свободным 
-контекстом одного из контекстных сокетов. Ќапример, так: 

Љак видим, в отличие от 
 С и 
 С контекстов, 
-контекст можно наращивать каскадно, создаваЯ дополнительный логический контекст (условие) длЯ уже существующего.





ЏредставлЯетсЯ очевидным, что объект, на который ссылаютсЯ, не может быть произвольным образом удален. ‘оответственно, в целЯх сохранениЯ ссылочной целостности необходим контроль наличиЯ актуальных внешних ссылок на объект.



Љак мы помним, объект логически удалЯетсЯ при инициализации значениЯ служебного атрибута 
. „лЯ того, чтобы обеспечить возможностью контролЯ внешних ссылок, каждый атрибут обратной ссылки, при своем создании автоматически создает отдельный 
 соединитель к атрибуту 
. 


‚ методе 
 специализированный служебный функционал атрибута 
 проверЯет все входЯщие соединители, и как только один из них вернет 
 (список обратных ссылок не пуст), функционал породит исключение, прерывающее транзакцию. Ќо до исключениЯ можно и не доводить. Њетод 
, адресованный атрибуту 
, опросит соединители, и вернет 
, если удаление объекта возможно без конфликтов.



‘уществуют отношениЯ, которые с понЯтийной точки зрениЯ принЯто рассматривать как "
". Ќапример, 
 и ее условно "
" 
, которые могут существовать исключительно в контексте Ќакладной. ’ут ожидаетсЯ прЯмо противоположное поведение: объект 
 не только может быть удален при наличии обратных ссылок от объектов 
, но и должен также, в процессе собственного удалениЯ, удалить все свои 
. ’ребуемаЯ реакциЯ может быть обеспечена установкой виртуального флага 
 в свойствах отношениЯ, после которой в модели данных будут сделаны следующие изменениЯ: 





‚о-первых, будет добавлен активный соединитель, свЯзывающий атрибуты 
 в классах 
 и 
, а во-вторых, сбросом флага 
 будет де-активирован соединитель, свЯзывающий 
 с соответствующим списком обратных ссылок. 





ђассмотрим систему из трех классов, свЯзанных 
:





Ћбъект класса 
 обладает прЯмыми указателЯми на объекты 
 и 
, объект 
 Р указателем на 
. ’ак как никаких дополнительных правил и ограничений нет, то свЯзанные взаимной ссылкой объекты 
 и 
 в самом общем случае могут непротиворечиво адресовать в том числе и 
 объекты класса 
.



‘легка изменим пример, внесЯ в него определенную смысловую нагрузку.



Џусть 
 Р это класс 
, 
 Р 
, 
 Р 
. ЏредставлЯетсЯ очевидным, что 
 числитсЯ исключительно в том учебном заведении, на 
 которого проходит специализированное обучение. €ными словами, длЯ 
 указатель на 
 определЯетсЯ через указатель на 
. ќто правило устанавливаетсЯ созданием соединителЯ, свЯзывающего атрибуты прЯмой ссылки на класс 
 в классах 
 и 
 через отношение 
?
. Ћбратим внимание, свЯзываемые атрибуты имеют одинаковый тип С класс 
.




 

„екларациЯ активной свЯзи ссылочных атрибутов стандартным соединителем автоматически обеспечит требуемую согласованность ссылочных значений 
.[A] = 
.[A] при любых внешних воздействиЯх. ‚ самом деле:





„екларациЯ активной зависимости атрибутов прЯмой ссылки 
.[A] = 
.[A] порождает прЯмое логическое следствие:







Џроизводный 
-соединитель абсолютно пассивен, он не инициируетсЯ изменением атрибута 
.[A], так как соответствующие флаги (
/
) контекстного сокета выключены, и в процессе отработки внешних воздействий он участиЯ не принимает. ќтот соединитель используетсЯ в процессе организации присвоениЯ значениЯ ссылочному атрибуту 
.[A], что будет детально рассмотрено позже. Ђ пока обратим внимание, что адресуемый 
-соединителем список обратных ссылок, если его рассматривать как источник данных, предоставлЯет множество однородных значений, без возможности автоматически выбрать из них единственное.



Њежду тем, существует таки условие, при котором из списка можно выбрать строго определенный и при этом единственный элемент. „лЯ этого список должен обладать свойством 
 по значению ключа, ну и необходим собственно ключ.





ђассмотрим пример из все тех же трех классов, но, длЯ большей наглЯдности, в несколько иной интерпретации: класс 
 Р это некоторый 
, 
 которого (класс 
) следует группировать по календарным 
 (класс 
). Љаждый 
 в 
 уникален по значению календарной даты 
 (
). „анную уникальность обеспечивает назначенный атрибуту обратной ссылки 
.{B} слегка модернизированный 
, который генерирует транзакционное исключение при попытке добавить в список запись с уже существующим в списке значением ключа.



‘оединитель 
 также претерпел некоторые изменениЯ: он использует в качестве 
-контекста атрибут Date (D), и стал 
: его контексты активны (длЯ всех контекстных сокетов соединителЯ установлены флаги 
/
), при сброшенном флаге 
 базового сокета.





Џри активных контекстных сокетах, любое изменение значений атрибутов 
.[A] или 
.D активирует 
-соединитель, который извлечет значение 
.D, и использует его как ключ при обращении к списку 
.{B}, после чего полученное значение (
 объекта B) будет присвоено целевому атрибуту. ’ем самым реализуетсЯ автоматическое позиционирование (иначе С группировка) объектов класса 
 на объекты класса 
.



Ђ что произойдет, если в качестве значениЯ 
.D ввести дату, длЯ которой не существует соответствующего объекта 
? ‚ этом случае 
-соединитель закономерно вернет значение NUL, и ссылка на 
 будет де-инициализирована.



‘тоит отметить, что изредка требуетсЯ и такое поведение, но чаще всего требуемый объект 
, соответствующий введенной дате, должен быть создан автоматически. „лЯ реализации такого поведениЯ атрибуту 
.[B] назначают функционал 
. ќтот функционал (рассматриваетсЯ ниже) при его инициации 
-соединителем автоматически создаст новый объект класса 
, после чего присвоит атрибуту прЯмой ссылки в качестве значениЯ идентификатор созданного объекта. 



Ќо этого недостаточно. „лЯ сохранениЯ ссылочной целостности, атрибуты 
 и {
} нового объекта 
 должны автоматически получить строго определенные значениЯ, а именно С совпадающие с текущими значениЯми аналогичных атрибутов объекта 
. „лЯ этих целей в соединителЯх 
.D?
.D и 
.[A]?
.[A] включаетсЯ 
, а именно: во входЯщих 
-сокетах соединителЯ, принадлежащих атрибутам 
.D и 
.[A], дополнительно устанавливаетсЯ флаг 
. ’огда при присвоении значениЯ атрибуту 
.[B], С транспортному контексту соединителей 
.D?
.D и 
.[A]?
.[A], эти соединители будут инициированы на передачу значений в объект 
. Ћбратим внимание Р приведеннаЯ на схеме декларациЯ зависимостей обеспечивает автоматическое сохранение логической и ссылочной целостности при изменении любого из значений.



ђассмотренный выше набор деклараций, реализующий группировку объектов по значению атрибута, создаетсЯ внутренним конструктором модели в два приема. …сли в некотором общем классе в свойствах атрибута обратной ссылки включить опцию уникальность, то отношение, которому принадлежит данный атрибут становитсЯ уникальным. Џри этом сам целевой класс ссылки теперь может выступать в качестве класса, группирующего ссылки по значению своего базового атрибута. Ћтношение с таким классом любого третьего класса, обладающего при этом также отношением с общим классом, приобретает опцию (в диалоге свойств), позволЯющую выбрать в кортеже третьего класса атрибут, по значению которого реализуетсЯ группировка.





‘легка модернизируем предыдущий пример: пусть место абсолютного атрибута 
 в классах 
 и 
 займет атрибут прЯмой ссылки на класс 
 (списку обратных ссылок в общем-то едино, что будет играть роль ключа к значению: календарнаЯ дата или идентификатор объекта IDO). € длЯ большей наглЯдности изменим смысловое значение классов: класс 
 Р это 
, класс 
 Р 
, класс 
 Р 
 (движение ’овара). ’огда смысловаЯ нагрузка на класс 
 становитсЯ однозначно производной: это 
. …сли заменить 
 на 
 или 
, то класс 
 станет 
.



‘оответствующаЯ сделанным изменениЯм декларациЯ будет выглЯдеть так:





‹юбаЯ 
 при получении конкретных указателей на объекты 
 и 
 автоматически получит указатель на объект 
, а в случае отсутствиЯ такового Р автоматически же его создаст. Ћбратим внимание: свЯзь двух классов, 
 и 
, через третий класс (
) представлЯет собой вариант реализации отношениЯ 
, альтернативный прЯмому обмену значениЯми двух атрибутов обратной ссылки. Џричем этот вариант обладает еще и свойством уникальности. €ными словами, длЯ каждой пары объектов 
 и 
, свЯзывающий их объект 
 существует в единственном экземплЯре. ’акое поведение обусловлено свойством уникальности списка обратных ссылок, длЯ которого в качестве источника ключа используетсЯ атрибут-указатель на оппозитный класс. € совершенно неважно, в каком из двух классов (
 или 
) декларирована уникальность списка, Р такой же список обратных ссылок (с обычным функционалом списка) в оппозитном классе будет по факту содержать уникальный набор ключей.





ЏрЯмаЯ реализациЯ отношениЯ 
 выглЯдит как два взаимодействующих списка обратных ссылок в каждом из свЯзываемых классов. ’акаЯ реализациЯ имеет в общем-то ничтожный практический смысл: только констатациЯ факта свЯзи объектов, без возможности реализовать через это отношение непротиворечивое взаимодействие атрибутов этих классов. Џоэтому на практике желаемое взаимодействие атрибутов реализуют через атрибуты третьего класса, свЯзанного отношениЯми с целевыми классами. ‚ реальных моделЯх приложений такие конструкции встречаютсЯ сплошь и рЯдом, и создаютсЯ самым произвольным образом, не претендуЯ на выделение в отдельный тип отношениЯ.



‘овсем иное дело, когда 
 обладает свойством уникальности, как 
 из примера выше. ‡десь спецификой третьего класса (класса свЯзи) ЯвлЯетсЯ не столько использование атрибутов отношениЯ в качестве источников ключа, сколько его понЯтийнаЯ ЗпроизводностьИ от отношениЯ классов. Џоэтому, такаЯ 
 (по идентификаторам) свЯзь классов через третий класс и будет в дальнейшем рассматриватьсЯ в качестве отношениЯ типа 
. €меновать же такой тип можно как 
, так и 
.




 создаетсЯ в результате исполнениЯ диалога, в ходе которого выбираютсЯ свЯзываемые отношением классы, после чего соответствующий метод-конструктор создает как сам третий класс-проекцию, с присвоением ему соответствующего составного наименованиЯ, так и все прочие необходимые декларации атрибутов отношений и свЯзывающих их соединителей. Џри этом любой класс, образующий отношениЯ с тремЯ классами отношениЯ проекции, автоматически получает полный комплект соединителей из рассмотренного выше примера, что обеспечивает его объектам возможность автоматического же получениЯ указателЯ на объект-проекцию. Ћбратим внимание, в целЯх приданиЯ большей визуальной наглЯдности, отношение проецируемого класса с классом-проекцией на всех схемах выглЯдит как двойнаЯ стрелка.





—то примечательно, комбинацией 
 можно реализовать любую 
 аналитику данных. ‚ самом деле, отношением проекции можно свЯзать любую пару классов, и в том числе уже имеющиесЯ в наличии классы-проекции, после чего в атрибутах всех классов-проекций организовать обобщение численных значений.





“величиваЯ 
 отношениЯ мы тем самым позволЯем объекту одного класса адресовать два и более объекта другого класса, что в свою очередь также может рассматриватьсЯ как логический аналог рассмотренной ранее свЯзи 
.





€сходЯ из этого следует предположить, что у кратной формы отношениЯ должна существовать своЯ проекциЯ С уникальнаЯ форма кратного отношениЯ, указатель на объект которой может быть получен автоматически.



€ такое уникальное отношение действительно будет создано, если в процессе диалога созданиЯ отношениЯ-проекции в качестве целевых классов выбрать один и тот же класс. € после того, как будет создано отношение простого класса на класс-проекцию, декларациЯ атрибутов и соединителей примет следующий вид:



Џри всей странности ее внешнего вида, это логичнаЯ и вполне себе работоспособнаЯ декларациЯ, котораЯ практически используетсЯ, например, в бухгалтерском учете Р длЯ получениЯ объектов взаимной корреспонденции балансовых счетов. ‘обственно говорЯ, отсюда и заимствовано название Р 
, используемое далее длЯ обозначениЯ кратного уникального отношениЯ, реализуемого классом-проекцией.



Ќа что в приведенной декларации следует обратить внимание: в отличие от обычной проекции, свЯзывающей любую пару объектов своим единственным экземплЯром, в 
 такаЯ свЯзь реализуетсЯ двумЯ экземплЯрами, по одному на каждую комбинацию указателей в элементах прЯмой ссылки. „лЯ этих целей во всех взаимодействиЯх, включаЯ формирование списка обратных ссылок, ссылочные указатели, выступающие как в качестве значений, так и в качестве ключей, дополнЯютсЯ индексом элемента, в котором размещены. Љроме того, длЯ блокировки бессмысленной двойной адресации, ссылочному атрибуту в классе-проекции можно назначить специальный функционал, который запрещает присваивать обоим элементам одинаковое значение.





‘уществует ровно один способ реализовать отношение в объекте класса Р присвоить методом 
 атрибуту прЯмой ссылки идентификатор целевого объекта 
. Џричем соответствующий вызов может быть инициирован как извне, так и самой моделью данных. Ќапример, атрибут может получить указатель на объект из другого класса через соединитель, свЯзывающий однотипные ссылочные атрибуты. ’акже, отношение можно реализовать непосредственно при создании объекта, если метод 
 адресовать не целевому классу, а типизированному этим классом атрибуту отношениЯ, причем атрибуту как прЯмой, так и обратной ссылки. ’аким способом удобно создавать новый объект относительно другого объекта (например, новую 
 относительно 
). ’акже атрибут может получить 
, создаваЯ целевой объект отношениЯ функционалом 
.




‚нешний пользователь не может просто так взЯть и присвоить атрибуту ссылочное значение. Џечальные последствиЯ открытиЯ прЯмого доступа к системе внутренней идентификации очевидны и так, без комментариев. Љ тому же, за пределами пространства объектов отдельный дескриптор 
 что называетсЯ ЗтерЯет смыслИ, превращаЯсь в простое число.



Џоэтому, внешний пользователь может реализовать ссылку только опосредованно, в форме диалога, путем выбора элемента из списка, в котором каждый объект представлен своими абсолютными (не ссылочными) значениЯми. ’ребуемый список ему предоставлЯют компоненты слоЯ 
 (сервернаЯ часть интерфейсных ресурсов объектной ‘“Ѓ„ будет рассмотрена впоследствии), которые затем и инициируют присвоение 
 в соответствии со сделанным выбором. „иалог выбора может быть прЯмым или каскадным, что задаетсЯ на основе действующих 
-соединителей. €сточником длЯ формированиЯ диалогового списка выступает соответствующий список обратных ссылок.





„анный функционал назначают атрибуту прЯмой ссылки в целЯх реализации отношениЯ путем автоматического созданиЯ производного объекта целевого класса отношениЯ.



”ункционал 
 может быть инициирован как входЯщим соединителем, так и внешним событием 
. Џри этом целевой объект отношениЯ будет создан функционалом только в том случае, если ссылочный атрибут в исходном объекте не имеет хранимого значениЯ.





‘уществует твердое правило логического взаимодействиЯ значений, согласно которому значение, принадлежащее определенному домену, можно свЯзать только со значением, домен которого входит в исходный или включает в себЯ исходный. Џри этом принЯть исходное значение может только значение с равным или более обширным доменом. ‘амый большой домен (после 
) у атрибута типа 
, который может принЯть значение любого другого типа. Џроще говорЯ, соединителем можно свЯзать только однотипные атрибуты, что и наблюдалось во всех рассматриваемых ранее примерах. Ќо вот в следующей декларации пассивный соединитель, свЯзываЯ атрибуты обратной ссылки (
.{B} ? 
.{D}) очевидно разного типа, Явным образом нарушает это правило, и тем не менее имеет полное право на жизнь.





‚се дело в том, что в данном случае предметом взаимодействиЯ ЯвлЯетсЯ не собственно значение, а 
 свЯзываемых множеств, принЯвших форму списков обратных ссылок. ђассмотрим подробнее логику происходЯщего.



‘татический атрибут, производное значение которого не инициализировано, при обращении к нему с запросом, тем не менее способен вернуть значение, сформировав его из входЯщих соединений, при их наличии. Џри этом, само хранимое значение атрибут все равно не создаст, так как запрос не содержит Явного указаниЯ на принадлежность к 
, а значит база данных должна сохранить свое 
 неизменным. €ное дело, когда транзакционный характер воздействиЯ очевиден. ‚ этом случае не инициализированный ранее статический атрибут вполне может и должен в рамках общего изменениЯ состоЯниЯ базы образовать хранимое значение. Љак видно из декларации, рассматриваемый соединитель и его целевой атрибут 
.{D} будут инициированы при присвоении значениЯ атрибуту 
.[A], то есть транзакционно. € если производного значениЯ в этот момент не существует, атрибут 
.{D} начинает его формирование по исходному образцу, предоставленному соединителем.



Љак значение, список обратных ссылок производен от ссылок прЯмых. €ными словами, у атрибута 
.{D} есть единственный способ сформировать собственный список размером с исходный, С это создать требуемое количество объектов класса 
, и присвоить каждому из созданных объектов указатель на собственный объект. ’акое создание с присвоением можно сделать одной командой 
 в собственный адрес. —то атрибут (а если уж быть совсем точным Р то функционал списка, назначенный атрибуту) и делает С длЯ каждого элемента исходного списка. Ђ так как значением этого элемента ЯвлЯетсЯ ссылочный указатель, тип которого известен, то анализом кортежа класса создаваемого объекта определЯетсЯ атрибут прЯмой ссылки требуемого типа, которому и присваиваетсЯ извлеченное из элемента значение указателЯ.



‚ результате всех этих действий по имеющемусЯ образцу Р множеству производных объектов исходного класса создаетсЯ аналогичное множество производных объектов целевого класса, попарно свЯзанных с образцовыми.





„лЯ свЯзываниЯ однотипных объектов (объектов одного класса) используетсЯ отношение, создаваемое непосредственно внутри класса данных. Џри этом способ реализации собственно отношениЯ остаетсЯ неизменным Р в классе создаетсЯ два ссылочных атрибута, свЯзанных ссылочными соединителЯми, и типизированных собственным классом.



—то примечательно, рассмотренную в предыдущем параграфе корреспонденцию также можно отнести, пусть и частично, к внутренним отношениЯм, так как свЯзывает она объекты, производные от одного класса. Џравда делает это через объекты стороннего класса.



‚ отличие от обычных отношений, создаваемых визуальным диалогом, в ходе которого последовательно выбираютсЯ свЯзываемые классы, внутренние отношениЯ создаютсЯ по примеру атрибутов в визуальном пространстве целевого класса.



—ерез внутреннее отношение атрибут может создать соединитель на самого себЯ. ќто очень эффективный прием, позволЯющий реализовать различного рода обобщениЯ значений, включаЯ обобщение Знарастающим итогомИ.



”ункциональный смысл внутреннего отношениЯ определЯетсЯ его типом. 





‚нутреннее отношение типа один-к-одному позволЯет формировать из объектов класса последовательные цепочки, в силу чего и именуетсЯ 
. 



ђеализовать цепочечное отношение можно различными способами: как забираЯ соединителем указатель на предыдущий объект из списка обратных ссылок у общего владельца, так и используЯ функционал 
, который реализует отношение созданием последующего объекта относительно предыдущего. ‚ последнем случае длЯ инициации функционала удобно использовать метод-событие 
.



Џримеры использованиЯ Р прохождение деталью цикла обработки, организованного как последовательность операций, или расчетные периоды года: квартальные или месЯчные, с нарастающими итогами на начало и конец периода. …сли мощность цепочечного отношениЯ увеличить до трех, объекты класса могут образовать логическое подобие трехмерной кристаллической решетки. ’акую конструкцию можно использовать длЯ самого различного моделированиЯ поведениЯ, и в том числе в физических средах.





‚нутреннее отношение типа 
, именуемое 
, позволЯет создавать образованные объектами древовидные структуры данных переменной глубины вложенности (объектные иерархии а-лЯ папки в файловой системе). ’ипичный пример использованиЯ 
 Р календарный график работ на объекте строительства, в котором вместе с рекурсивным одновременно используетсЯ и цепочечное отношение. ‘амый удобный и естественный способ реализации рекурсивного отношениЯ Р создание объекта класса относительно уже существующего объекта-родителЯ.



Џрименительно к древовидной иерархии объектов, образованной рекурсивным отношением, при реализации множественных отношений этих объектов с объектами прочих классов, действуют два логически очевидных ограничительных правила.





ѓрафически, правила взаимодействиЯ сторонних классов с рекурсивным можно проиллюстрировать так:



1. Џри 
 отношении с объектной иерархией, объект стороннего класса может реализовать свою прЯмую ссылку только на объект, принадлежащий самому нижнему уровню этой иерархии, то есть на объект с пустым значением атрибута обратной ссылки рекурсивного отношениЯ.



2. ’олько объект, принадлежащий самому верхнему уровню объектной иерархии (обладающий не инициализированным значением атрибута прЯмой ссылки 
) может реализовать свою прЯмую ссылку на объект стороннего класса.



‘тоит отметить, что данные ограничениЯ применимы только к реализации множественных отношений класса, обладающего внутренним рекурсивным отношением, с прочими классами, и не распространЯютсЯ на аналогичные унитарные отношениЯ. ќти правила, характерные длЯ иерархий вообще, не ЯвлЯютсЯ строгими, а носЯт рекомендательный характер. ‘облюдение этих правил на уровне объектной модели никак не контролируетсЯ, и целиком возлагаетсЯ на интерфейсную частью приложениЯ.





…сли один или оба класса, свЯзанных уникальным 
, обладают еще и внутренней 
, то логично предположить, что производные объекты этих классов должны быть свЯзаны между собой объектами-проекцией не только на самом нижнем уровне объектной иерархии, но и на всех последующих уровнЯх. Џримерно так, как это показано на следующем рисунке:





—тобы реализовать такую свЯзь, класс-проекциЯ также должен обладать декларацией рекурсивного отношениЯ.



‘оответственно, когда в классе-проекции создаетсЯ 
, то, в дополнение к двум ссылочным атрибутам и соединителЯм этого отношениЯ, 
 создает еще два дополнительных атрибута, а также набор соединителей, которые и обеспечивают проекцию на следующий уровень объектной иерархии по значению дополнительных атрибутов:





Љонструктор присваивает дополнительным атрибутам (на схеме отмечены символом [*]) тот же тип, что и атрибутам прЯмой ссылки проекции на свЯзываемые классы, тем самым переводЯ их в разрЯд атрибутов отношениЯ. Ќо есть отличие: обратной ссылки длЯ дополнительных атрибутов не предусмотрено.



„ополнительные атрибуты получают свое хранимое значение (указатель на объект) от однотипных им атрибутов прЯмой ссылки рекурсии, через активные соединители, на схеме отмеченные символом (=). …сли оба значениЯ получены, то будет реализована схема свЯзи под номером 2. …сли рекурсиЯ в одном из свЯзываемых проекцией объектов не реализована (схемы свЯзи с номером 1 и 3), то соответствующий дополнительный атрибут не будет иметь хранимого значениЯ, но при обращении к нему вернет указатель на объект без рекурсии. ’акое поведение характерно длЯ статических атрибутов, и уже упоминалось ранее: при обращении в методе Get к атрибуту, значение которого не инициализировано, он тем не менее способен сформировать возвращаемое значение путем опроса входЯщих соединителей. Ќа схеме соответствующие пассивные соединители, созданные конструктором модели, изображены пунктиром.



‘тоит упомЯнуть, что совершенно аналогичный набор дополнительных атрибутов и соединителей конструктор модели создаст и в том случае, когда внутреннее рекурсивное отношение будет декларировано в таком варианте проекции как рассмотреннаЯ выше 
.





Ќеобходимость в структурном интерфейсе возникает всЯкий раз, когда требуетсЯ через отношениЯ получить унифицированный доступ к 
 сущностЯм. €ными словами, сущности с различным набором реквизитов надо свести в однородное (с точки зрениЯ реквизитов) множество. Ќу хотЯ бы затем, чтобы представить их общим списком.



Џервый вариант решениЯ такой задачи нам предоставлЯет механизм 
: класс-потомок наследует кортеж атрибутов класса предка. ќтого вполне достаточно, например, чтобы все богатство видов финансовых документов свести в один список вида 
, 
, 
, 
.



’акой вариант решениЯ можно условно назвать 
 "
". ђаботает он хорошо, но к сожалению не все сущности имеют общего предка. ’ипичный пример нам дает специфика учета в строительстве: несколько 
 финансируют крупные 
, которые состоЯт из нескольких 
, 
 по которым структурированы по 
, и включены в различные 
 (с 
). ’ребуетсЯ ход выполнениЯ работ (финансированиЯ, произведенных расходов, человеко-часов,...) свести в общую картину а-лЯ 
. Њножественное наследование не ЯвлЯетсЯ хорошей идеей. Љ тому же, эффект множественного наследованиЯ можно получить, объединЯЯ разнотипные сущности свЯзью 
, Р в чем, по-видимому, и состоит философский смысл унитарного отношениЯ. „лЯ нашего примера результат достигаетсЯ комбинированием 
 и 
, и в декларациЯх выглЯдит например так: 



Љаждый из перечисленных выше субъектов ЗстроительногоИ учета автоматически (используЯ 
) создает парный себе объект в классе ѓантт, после чего передает в этот объект указатель на своего логического "
" (в качестве значениЯ атрибута прЯмой ссылки рекурсии), а также прочие свои значениЯ. Џередача указателЯ на Т
" осуществлЯетсЯ через вспомогательные атрибуты, такие же как и на схеме рекурсивной проекции, на которой они обозначены символом [*]. € создание объектов ѓантт, и передача значений их атрибутам, осуществлЯетсЯ через унитарное отношение, логически свЯзывающее Здве части одного целогоИ.



’акой вариант решениЯ можно (также условно) назвать 
 "
" (специалисты по терминологии нас поправЯт), поскольку существует еще один способ единообразного представлениЯ сущностей, которому очень подходит название С 
 "
". …го идеЯ заключаетсЯ в том, чтобы в качестве значениЯ хранить в атрибуте унифицированную структуру данных на правах значениЯ 
, в которую и передавать значениЯ, требующие унифицированного представлениЯ. ’ак в частности ЗработаютИ бухгалтерские "
", которые совершенно одинаково выглЯдЯт относительно регистра учета, несмотрЯ на то, что размещены в разных классах-документах, и зачастую не в единственном экземплЯре.



Ќаверное стоит отметить, что существование столь разных вариантов частичной структурной унификации наталкивает на мысль о том, что универсального интерфейсного решениЯ в природе не существует.





‚ объектной модели данных любой структурный тип самым естественным образом существует на правах пользовательского класса, идентификатор которого (
) и ЯвлЯетсЯ дескриптором этого типа данных. ‘оответственно, интерфейсную структуру данных можно определить как класс, а ее использование в качестве значениЯ атрибута следует рассматривать как своеобразную модификацию 
, при которой атрибут прЯмой ссылки на интерфейсный класс хранит не идентификатор объекта интерфейсного класса (IDO), а собственно сам объект. ’ак как ЗвключаемыйИ в качестве значениЯ объект терЯет свою самостоЯтельность, то вместе с ней он перестает обладать и собственным дескриптором. ’еперь его идентификатором ЯвлЯетсЯ составное значение в терминах 
 объекта-владельца 
 атрибута, в котором он размещен. ’акое решение позволЯет не беспокоитьсЯ о способе созданиЯ включенного объекта и реализации отношениЯ с ним Р все это происходит автоматически при создании объекта-владельца в ходе инициализации его атрибутов.



’ак как изначально предполагаетсЯ, что ЗинтерфейсныйИ объект будет включен в состав объектов самых разных классов, то традиционный способ обеспечениЯ симметрии отношениЯ путем созданиЯ ссылочного атрибута в каждом из свЯзываемых классов перестает быть оптимальным. ‚ самом деле, при таком способе в кортеже ЗинтерфейсногоИ класса будет декларировано энное количество ссылочных атрибутов, из которых при собственно реализации отношениЯ получит значение всегда только один. Џоэтому был выбран другой вариант, асимметричный в декларации, но тем не менее сохранЯющий ссылочную симметрию при реализации.



‚ интерфейсном классе роль атрибута обратной ссылки длЯ всех создаваемых интерфейсных отношений выполнЯет один и тот же атрибут Р 
, которому, чтобы он мог принЯть значение любого ссылочного типа, принудительно назначен тип 
. ‘обственно говорЯ, назначение этого типа атрибуту 
 и играет роль флага, отмечающего класс как "
". 


€тоговые декларации "
" отношениЯ (справа), в сравнении с декларациЯми обычного унитарного отношениЯ (слева), выглЯдЯт так: 



‹огика определениЯ интерфейсного типа устанавливает также и порЯдок его использованиЯ: класс, объЯвлЯемый 
, образует самостоЯтельный тип данных (структурный тип), которым дополнЯетсЯ стандартный набор типов, участвующих в образовании меню выбора диалога типизации атрибута. Џри выборе такого типа и назначении его атрибуту конструктор модели создаст все декларации, приведенные на схеме.





”актически, служебные классы ЯвлЯютсЯ обычными классами данных, которые используютсЯ системой управлениЯ данными длЯ решениЯ ее внутренних утилитарных задач. Ћтличие служебных классов от прочих состоит лишь в том, что создаютсЯ они системой управлениЯ автоматически, при генерации новой базы данных, и соответственно имеют фиксированные дескрипторы, которые априори известны системе.





Њножество объектов данных, симметрично свЯзанных взаимными ссылками, представлЯет собой замкнутую систему, в пределах которой естественнаЯ меж-объектнаЯ навигациЯ не ограничена ничем. Ќо так как по соображениЯм надежности и безопасности прЯмой доступ к объектам запрещен, возникает проблема входа в такую систему. Џреодолеть ее помогает использование 
, именуемого 
, и производного от него 
, с фиксированными значениЯми дескрипторов 
 и 
.



Џри создании дизайнером приложениЯ каждого нового пользовательского класса, длЯ этого класса автоматически создаетсЯ множественное отношение с 
. ’ем самым, упомЯнутый ранее набор 
 класса (
, 
 и 
) дополнЯетсЯ четвертым членом Р атрибутом прЯмой ссылки на ‘упер-класс. ‘упер-класс же, в свою очередь, получает атрибут обратной ссылки, типизированный дескриптором 
 вновь созданного класса. ’аким образом, по факту созданиЯ пользовательских классов, 
 становитсЯ своего рода 
 их полного множества, что позволЯет использовать 
с его фиксированным дескриптором как точку входа в действующую модель данных. —то примечательно, атрибутный идентификатор (
) обратной ссылки в ‘упер-классе странным образом совпадает по значению с ее классовым идентификатором (
).



‚ процессе созданиЯ классом производного объекта (
) выполнЯетсЯ автоматическаЯ инициализациЯ его служебных атрибутов, и в том числе атрибута прЯмой ссылки на 
, который получает фиксированный 
. Џри этом, как следствие, указатель на новый объект пополнЯет собой соответствующий список обратных ссылок 
. ’аким образом, исключительно по факту соблюдениЯ стандартных правил реализации отношений, 
 становитсЯ владельцем списков объектов каждого класса, иными словами Р полного множества объектов. ќто обстоЯтельство позволЯет использовать 
 как естественную точку входа в 
, открывающую доступ к спискам объектов классов.



Ћбратим внимание на важный момент Р класс данных, как декларациЯ, не обладает физическим указателем на список собственных объектов. Њежду данными и метаданными не может быть иной свЯзи, кроме логической. 



€ еще одна деталь: при организации диалога выбора объекта, 
 по умолчанию, если не задано иное, использует список обратных ссылок целевого класса из 
.





‹юбое приложение нуждаетсЯ в глобальных значениЯх, перманентно доступных всем частЯм приложениЯ. „лЯ декларации таких значений используетсЯ служебный класс 
, в производном объекте которого они и хранЯтсЯ. ‘пецификой класса 
 ЯвлЯетсЯ тот факт, что он свЯзан с 
 не 
, как все прочие классы, а 
 отношением 
. €ными словами, относительно 
 объект 
 существует в единственном экземплЯре, а так как его позициЯ в кортеже 
 известна, то доступ к его значениЯм осуществлЯетсЯ в один шаг.



‚ зависимости от особенностей их использованиЯ, все множество глобальных значений можно условно разделить на группы. ‚ первую группу входЯт изолированные значениЯ, которые используютсЯ сами по себе, как правило в интерфейсных формах, как например, 
 (собственной). „лЯ доступа к таким значениЯм достаточно маршрута: 
 ? 
 ? 
.



‚торую группу образуют так называемые заимствуемые значениЯ, такие как 
. „лЯ того, чтобы воспользоватьсЯ заимствуемым значением, класс должен обладать отношением с классом 
, и очевидно Р 
. …сли такое отношение декларируетсЯ, то конструктор модели в дополнение к нему создает соединитель, позволЯющий создаваемому объекту автоматически получать указатель на объект 
.



Џомимо 
, глобальными могут быть также и 
 значениЯ. ’акие значениЯ чаще всего используют в качестве значений по умолчанию, задаваемых при настройке приложениЯ, например, ссылки на объекты 
, образующие пару ђубль-„оллар. ’ак как отношение типа 
 (Global)
 (‚алюта) будет напрЯгать здравый смысл, глобальные ссылочные значениЯ создают несколько иначе: сначала создаетсЯ 
 атрибут, в 
 (длЯ единственной ссылки) или перечислимой (длЯ нескольких ссылок) форме, а затем его тип переопределЯетсЯ на 
 = 
 целевого класса. €ными словами, атрибут прЯмой ссылки создаетсЯ без декларации собственно отношениЯ. ќтот прием используетсЯ везде, где нет практического смысла декларировать отношение, а атрибут нужного типа необходим (как, например, при реализации рассмотренной выше 
).



Љроме этого, все значениЯ, хранимые объектом 
, подразделЯютсЯ на 
 и 
. Ћбщие, такие как 
 или 
, одинаковы длЯ всех пользователей базы данных. ‚ отличие от 
 или указателЯ на 
 (длЯ конкретного кладовщика, например), которые должны быть индивидуальны длЯ каждого пользователЯ. „лЯ образованиЯ и хранениЯ пользовательских значений используютсЯ объекты класса 
.





Ћсновное назначение класса 
 состоит в том, что на его основе строитсЯ система аутентификации конечных пользователей базы данных. …сли в ходе авторизации введенные пользователем логин и пароль совпадают со значениЯми соответствующих атрибутов в одном из объектов 
, то авторизациЯ считаетсЯ успешной, после чего значениЯ всех прочих атрибутов данного объекта становЯтсЯ доступны этому пользователю (и только ему) на правах глобальных значений.



ђеализуетсЯ это следующим образом. Љлассы 
 и 
 свЯзаны 
. Џри создании нового статического атрибута в классе 
, в классе 
 автоматически создаетсЯ парный ему однотипный и одноименный динамический атрибут (
), который после созданиЯ получает пассивный входЯщий соединитель от парного ему атрибута в 
. Џри обращении к пользовательскому атрибуту в 
, этот атрибут делает попытку получить свое значение через соединитель, и в этот момент среда исполнениЯ вместо списка обратных ссылок на объекты 
 подставлЯет указатель на единственный такой объект, полученный при авторизации пользователЯ.



Ћтметим, что атрибут может получить свое значение по соединителю через список обратных ссылок из множества источников или преобразованием этих значений в единственное (например, суммированием), или при наличии условиЯ (контекста), позволЯющего выделить из множества значений единственное. ‚ отсутствие соответствующего условиЯ или преобразованиЯ (функционала), атрибуту запрещено создание входЯщего соединителЯ через атрибут обратной ссылки. „лЯ пользовательского атрибута в классе 
 это ограничение преодолеваетсЯ искусственным путем.





Ќесколько выше по тексту уже упоминалось, что множество свЯзанных отношениЯми объектов образует замкнутую систему, единственной точкой входа в которую ЯвлЯетсЯ 
. ‚ пределах одной физической базы данных может существовать произвольное множество таких замкнутых систем. Љаждую такую систему можно рассматривать как логическую базу данных, полностью изолированную от других таких же логических баз. “ каждой логической базы есть своЯ точка входа, свой 
. €ными словами, длЯ генерации новой логической базы необходимо создать еще один объект, производный от 
.



ђешаетсЯ эта задача при помощи трех служебных классов: 
 ? 
: 
, причем ведущим в этой свЯзке будет класс 
. €менно класс 
 ассоциируетсЯ с логической базой данных, а каждый производный объект этого класса в соответствующем атрибуте хранит в том числе пользовательское наименование ЗсвоейИ базы. Ќаличие отношениЯ 
 позволЯет при создании объекта 
 автоматически создавать и свЯзывать с ним новый 
. Ћтносительно объекта 
 (рассматриваемого как экземплЯр 
) создаютсЯ объекты класса 
 (именованные Џользователи этого экземплЯра локальной базы). Џосле прохождениЯ процедуры авторизации, длЯ данного ЏользователЯ в его записи в ’аблице Љлиентов хранЯтсЯ дескрипторы (
) не только объекта 
, но и свЯзанных с ним объектов 
 и 
. €менно пользовательский указатель на 
 (корневой элемент локальной базы данных) и будет использован системой управлениЯ в качестве значениЯ, которое автоматически присваиваетсЯ соответствующему служебному атрибуту объекта любого класса, при создании этого объекта по инициативе данного конкретного пользователЯ.



—то важно отметить С все взаимно-изолированные логические базы данных подчинЯютсЯ общим длЯ них правилам модели данных, которые действуют на всем пространстве физической базы данных.





Џри своем создании класс-наследник получает полный кортеж атрибутов класса-предка, и вместе с атрибутами отношениЯ класс-наследник получает в полном объеме комплект отношений класса-предка. € при этом всплывает интереснаЯ деталь.



Љаждый новый класс, независимо от способа его созданиЯ, должен образовать собственное отношение с 
, чтобы иметь полный список своих объектов в Явной форме. Ќо класс-наследник не может напрЯмую создать такое отношение, так как уже наследует атрибут прЯмой ссылки на супер-класс в составе всего кортежа предка. Љроме того, хотЯ класс-предок и не создает собственных объектов, тем не менее его список обратных ссылок в супер-объекте должен включать в себЯ полный список объектов, производных от всех его дочерних классов. („лЯ примера: есть множество всех 
 вообще, и есть частное множество только 
.)

‘писок объектов длЯ класса-предка будет формироватьсЯ и безо всЯкого вмешательства в существующие декларации, так как все его наследники получили его родительское отношение с супер-классом. Џрименительно же к классу-наследнику конструктор классов реализует частичное создание нового отношениЯ Р используетсЯ существующий атрибут прЯмой ссылки (новый не создаетсЯ), ему в пару создаетсЯ атрибут обратной ссылки в супер-классе, и оба атрибута свЯзываютсЯ 
.



’аким образом, при наследовании частично нарушаетсЯ двустороннЯЯ симметриЯ отношениЯ с супер-классом: одному прЯмому указателю на супер-объект теперь будет соответствовать два и более (зависит от глубины наследованиЯ) указателЯ обратной ссылки в супер-объекте. Ќо такое исключение из правил носит частный характер и представлЯетсЯ логически оправданным.





„омен значений ссылочного атрибута образован идентификаторами объектов, производных от оппозитного класса отношениЯ и всех его классов-наследников. ‚ прикладных задачах зачастую возникает потребность принудительно сузить домен значений ссылочного атрибута, ограничив его единственным классом.



ђассмотрим следующий пример:



Ђбстрактный 
 имеет одну из двух организационных форм: 
 или 
 (наследники класса 
). ‚ товарообменных сделках 
 играет определенную 
: он может быть 
, 
 или и тем и другим одновременно. Ћчевидно, что между 
 и 
 существует вполне конкретное отношение, которое отдельно рассмотрим чуть позже. Љласс 
 представлЯет собой абстрактную товарообменную операцию, в которой декларированы естественные множественные отношениЯ с 
 и 
. ‚ нашем же примере конкретных операций ровно две: 
 и 
, наследники 
 и ее отношений.



Ќаследники 
 используют отношение с 
 в том виде, в котором его унаследовали. € 
 и 
 накладные реализуют это отношение, выбираЯ целевой объект из общего списка 
, в котором в равной степени присутствуют и 
 и 
. 



“наследованное же отношение с 
 требует 
, так как предметом ссылки длЯ 
 может быть только 
, а длЯ 
 С только 
. Џереопределение унаследованных отношений (
) достигаетсЯ путем замены в свойствах атрибута идентификатора класса-предка на идентификатор класса-наследника, длЯ чего ссылочный атрибут предоставлЯет конструктору модели соответствующий диалог. Ћбратим внимание, что после уточнениЯ отношениЯ со стороны прЯмой ссылки в 
 и 
 накладных, в списки обратных ссылок 
 и 
 автоматически попадут только объекты накладных, соответствующие их роли. Ќо симметричное переопределение отношениЯ также и длЯ ссылочных атрибутов этих классов будет считатьсЯ хорошим тоном.



‚ предыдущем примере 
 логически свЯзывает 
 с его 
. ђассмотрим эту свЯзь чуть подробнее, используЯ тот же набор классов, но представленный в несколько ином ракурсе:





Љонтрагент может одновременно быть и 
 и 
. ќтот факт декларируетсЯ созданием двух раздельных 
 отношений 
 с этими классами, без созданиЯ общего отношениЯ с 
. ‚месте с тем общий предок 
 необходим, так как несет в себе не только отношение с 
, но и общий длЯ 
 и 
 дополнительный комплект атрибутов, необходимый, например, длЯ организации различных взаиморасчетов. ‹огическаЯ же свЯзь 
 с 
 выглЯдит следующим образом (на примере пары 
 С 
): 
 приобретает статус 
 (образует объект класса 
, и реализует отношение с этим объектом) при наличии хотЯ бы одной 
. „лЯ того, чтобы эта свЯзь получила физическую реализацию, и работала как внутреннее правило модели данных, следует использовать функционал 
, как показано на рисунке:





€з левой части рисунка видно, что наличие унитарного отношениЯ между 
 и 
 позволЯет 
 потенциально получить значение длЯ любого из своих атрибутов прЯмой ссылки при присвоении указателЯ другому атрибуту прЯмой ссылки. Ќо так как логически 
 у нас вторичен, то функционал 
 назначаетсЯ атрибуту прЯмой ссылки на 
. Џри этом назначении автоматически будет создан дополнительно двунаправленный соединитель типа 
-. Џри наличии этих деклараций, в процессе исполнениЯ, после выбора в накладной объекта 
, произойдет одно из двух. …сли у 
 указатель на 
 актуален, то соединитель передаст его соответствующему атрибуту 
. Ђ иначе 
-соединитель инициализирует функционал 
, обЯзывающий владеющий им ссылочный атрибут безусловно реализовать отношение, в данном случае Р путем созданиЯ объекта целевого класса. Џосле того, как объект 
 будет создан, и указатель на него будет присвоен атрибуту прЯмой ссылки, тот же самый 
-соединитель реверсом передаст этот указатель в объект 
.



…ще один пример на тему уточнениЯ отношениЯ представлен на следующем рисунке:





Ћбъекты типа 
 всегда создаютсЯ в контексте объекта 
 событием 
, адресованным его атрибуту обратной ссылки на 
. ‘оответственно длЯ того, чтобы создавалсЯ объект нужного класса, строго необходимо уточнение целевого класса обратной ссылки. Џереопределение класса в свойствах атрибута прЯмой ссылки в дочерних классах 
 рекомендовано, но не ЯвлЯетсЯ обЯзательным.





‡начение атрибута 
 из класса 
 раздаетсЯ тремЯ соединителЯми: одним общим Р в атрибут 
 класса-предка 
, и двумЯ частными Р в атрибуты 
 и 
 его наследников 
 и 
. ‚ зависимости от того, указатель на объект какого из наследников, 
 или 
, будет получен объектом 
, в адресуемом объекте только один из двух атрибутов, 
 или 
, получит свое значение. Ђтрибут 
 получит свое значение в любом случае.





’акое поведение обеспечиваетсЯ селективными свойствами 
 соединителЯ, а именно Р благодарЯ наличию в декларациЯх 
-сокета идентификатора 
 целевого класса соединителЯ. ‚нешний соединитель исполнит свою передаточную функцию только в том случае, если 
-контекст предоставит ему 
 целевого объекта. Ђ это произойдет только в том случае, когда значение ссылочного атрибута Р 
 объекта входит в домен значений типа, декларированного в свойствах 
-сокета. 



Ќу просто напрашиваетсЯ ассоциациЯ с оператором 
, который перед выполнением действиЯ проверЯет соответствие типов.





‘имметричнаЯ форма реализации свЯзи объектов, основаннаЯ на взаимном обмене идентификаторами, способна автоматически поддерживать ссылочную целостность и логическую согласованность средствами управлениЯ самой базы данных. Џомимо этого, симметриЯ свЯзи делает возможной 
 (no 
) навигацию в 
 объектов данных. 



‘обственно говорЯ, способы интеграции бизнес-логики приложениЯ непосредственно в логическую структуру базы данных, рассмотренные в этой, а также в 
 публикации, позволЯют в разы увеличить скорость созданиЯ приложений. ‘огласитесь, визуальное конструирование существенно проще, чем написание и отладка программных кодов.