Часть 2: Сетевое взаимодействие — Написание blockchain менее чем за 200 строк кода на Go
KosToZyB
Вы прочитали 
 из этой серии? Если нет, то стоит взглянуть. Не волнуйся, мы подождем...
Добро пожаловать!
Мы были ошеломлены обратной связью от нашего первого поста: "Написание blockchain менее чем за 200 строк кода на Go". То, что предназначалось для небольшого урока для начинающих разработчиков по blockchain, приобрело новую жизнь. Нас завалили запросами сделать пост, где мы добавляем сетевое взаимодействие.
Прежде чем начнем, вы можете присоединиться к нашему чату в 
! Это лучшее место, что бы задать нам вопросы, дать отзывы и попросить новые уроки. Если вы нуждаетесь в помощи с вашим кодом, то это идеальное место, что бы спросить!
Последний пост показал вам, как создать свой собственный blockchain с хэшированием и валидацией каждого нового блока. Но все это выполнялось на одной ноде. Как мы можем подключить еще одну ноду к нашему основному приложению и создавать новые блоки, и обновлять всю цепочку блоков на всех остальных нодах?
После урока попробуйте сделать сами: каждый новый терминал, так же выступает в качестве "первых" терминалов, но с различными TCP портами и каждый с каждым имеет соединения для правильной работы сети.
Как и в предыдущем посте, цель данного урока в том, что бы получить базовую сеть из нод, что бы вы дальше смогли самостоятельно изучать blockchain. Вы не сможете добавить компьютеры из другой сети, которые будут писать в ваш первый терминал, но этого можно достичь, запустив бинарник в облаке. Кроме того, цепочка блоков будет смоделирована для каждой из нод. Не волнуйтесь, мы скоро все объясним.
Местами будет обзор предыдущего поста. Оставим множество функций, таких как генерация блоков, хэширование, проверка. Функционал HTTP использовать не будем, а просматривать результат будем в консоли, а для работы по сети будем использовать TCP.
Какие различия между TCP и HTTP?
Не будем вдаваться в подробности, но все, что вам нужно знать, что TCP является базовым протоколом, который передает данные. HTTP построен поверх TCP стека, что бы использовать эту передачу данных между интернетом и браузером. Когда вы просматриваете веб-сайт, вы используете HTTP протокол. В данном уроке будем работать с TCP, так как нам не нужно ничего просматривать в браузере. Go имеет хороший 
 пакет, предоставляющий все функции TCP соединения, которые нам необходимы.
Некоторая реализация уже рассматривались в 
 части. Для генерации и проверки цепочки блоков будем использовать функции из предыдущей статьи.
Создайте 
 файл в вашей главной директории и добавьте строку:
Сохраняем номер порта TCP, который хотим использовать (в нашем случае 9000) в переменной окружения под названием 
.
Если вы еще этого не сделали, установите следующие пакеты:
для красивой печати нашей цепочки блоков в консоль
для чтения переменных из нашего 
 файла.

Создайте пустой 
 файл. Там расположим наш код.
Декларация пакета и необходимые нам импорты:

Следующие фрагменты кода хорошо описаны в 
 части.
Давайте создадим нашу 
 структуру и объявим слайс блоков, это и будет наша цепочка блоков.
Объявим так же нашу функцию хэширования, которая понадобится нам при создании новых блоков.
И функция создания блоков:
Можем убедиться, что наш новый блок правильный, для этого проверим, что поле 
 ссылается на поле 
 из предыдущего блока.
Теперь гарантируем, что возьмем самую длинную цепочку, как правильную:
Замечательно! Получили основной функционал по работе с цепочкой блоков. Теперь можем перейти к созданию взаимодействия по сети.
Давайте создадим сеть, которая может передавать новые блоки, интегрировать их в цепочку и транслировать новую цепочку для сети.
Начнем с функции main, но перед этим давайте объявим глобальную переменную 
, которая является каналом принимающим входящие блоки.
Теперь давайте объявим нашу функцию main и загрузим переменные окружения из нашего файла 
, который находится в корневом каталоге. А так же запустим экземпляр нашего 
 в функции main.
Теперь нам необходимо создать TCP сервер. Помните, что TCP серверы похожи на HTTP серверы, но для работы с браузером протокола TCP недостаточно. Все данные будут отображаться через консоль. Будем обрабатывать несколько соединений с нашим TCP портом. Добавим это к нашей функции main:
Этот код запустит наш TCP сервер на порту 9000. Важно выполнить 
, что бы соединение закрылось, когда больше нет необходимости в нем. Почитать подробнее про 
 можно 
.
Теперь нам необходимо создавать новое соединение каждый раз, когда получаем запрос на установку соединения, и нам необходимо будем его обработать. Добавим еще кода:
Создаем бесконечный цикл, в котором принимаем новые соединения. Для конкурентной обработки, каждое соединение запускаем в обработчике в Go рутине 
, поэтому не останавливаем наш цикл. Таким образом можем одновременно слушать несколько соединений конкурентно.
Внимательный читатель заметит, что функция обработчик 
 не объявлена. Мы пока что создали нашу основную функцию 
. Целиком она выглядит так:
Давайте теперь напишем нашу функцию 
. Она принимает только один аргумент, это интерфейс 
. На наш взгляд, интерфейсы в Go поразительны и они отличают его от всех C-подобный языков. Конкурентность и Go рутины рекламируют язык, но интерфейсы и тот факт, что они могут реализовывать интерфейс не явно, является самой мощной функцией языка. Если вы еще не используете интерфейсы в Go, ознакомитесь с ними как только сможете. Интерфейсы это ваш следующий шаг, для становления как Go разработчика.
Поместите в заготовку функции обработчика отложенное закрытие соединения 
, что бы не забыть его закрыть, когда завершим работу.
Теперь нам нужно разрешить клиенту добавлять новые блоки в цепочку. Для данных будем использовать частоту пульса, как в 
 части. Замерьте свой пульс в течение минуты и запомните это число. Это будет параметр BPM (beats per minute)
Для реализации вышеуказанного нам необходимо:
Код, который реализует выше описанный функционал:
Создаем новый сканер. 
 это цикл, который работает конкурентно в Go рутине и отдельно от других соединений. Делаем быстрое строковое преобразование значения BMP (которое всегда будет типом 
, поэтому проверяем его). Выполняем стандартную генерацию блока, проверка блока на валидность и добавление нового блока в цепочку.
Синтаксис 
 просто означает, что мы бросаем нашу новую цепочку в канал, который создали ранее. Затем предлагаем клиенту ввести новое значение BPM для создания следующего блока.

Нам необходимо разослать новую цепочку блоков для всех соединений на нашем TCP сервере. Поскольку мы программируем на одном компьютере, нам надо имитировать, как данные будет передаваться всем клиентам. В функцию 
 нам необходимо добавить:
Вот код, выполняющий все в нужном порядке:
Замечательно! Наша функция 
 готова. Фактически вся программа готова и мы сохранили ее компактность в 200 строк кода. Это неплохо, не так ли?
Целиком со всем кодом, можно ознакомиться 
!
Давайте перейдем в директорию с нашим кодом и запустим нашу программу, выполнив: 
Как и ожидалось, видим наш базовый блок. В это же время запустили TCP сервер на порту 9000, который может принимать несколько соединений.
Откройте новое окно терминала и подключитесь к нашему TCP серверу с помощью 
. Будем использовать разный цвет в терминалах, что бы было понятно, что это разные клиенты. Сделайте это несколько раз с разными сеансами терминала, что бы запустить несколько клиентов.
Теперь введите BPM на любом из клиентов. Видим, что новый блок добавлен в первый терминал! Сеть работает!
Ждем 30 секунд. Перейдите к одному из других клиентов, и вы увидите, что новая цепочка блоков передалась всем клиентам, даже если эти клиенты никогда не вводили BPM!
Поздравляем! Вы не только создали свой собственный blockchain из последнего урока, но и добавили сетевое взаимодействие. Теперь есть несколько направлений для того, что бы двигаться дальше:
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

