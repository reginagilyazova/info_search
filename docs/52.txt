Туториал по Unreal Engine: C++
PatientZero

Blueprints — очень популярный способ создания геймплея в Unreal Engine 4. Однако если вы уже давно программируете и предпочитаете код, то вам идеально подойдёт C++. С помощью C++ можно даже вносить изменения в движок и создавать собственные плагины. 
 
В этом туториале вы научитесь следующему: 
 
 
Стоит учесть, что это   туториал по изучению C++. Мы сосредоточимся на работе с C++ в контексте Unreal Engine. 
 
 
 
Если вы ещё этого не сделали, то вам понадобится установить  . Выполните инструкции из   Epic по настройке Visual Studio для Unreal Engine 4. (Вы можете использовать альтернативные IDE, но в этом туториале применяется Visual Studio, потому что Unreal рассчитан на работу с ним.) 
 
Затем скачайте   и распакуйте её. Перейдите в папку проекта и откройте  . Если приложение попросить пересобрать модули, то нажмите  . 
 
 
Закончив с этим, вы увидите следующую сцену: 
 
 
В этом туториале мы создадим шар, который будет перемещать игрок, чтобы собрать монеты. В предыдущих туториалах мы использовали управляемых игроком персонажей с помощью Blueprints. В этом туториале мы создадим его с помощью C++. 
 
 
Для создания класса C++ перейдите в Content Browser и выберите  . 
 
 
После этого откроется C++ Class Wizard. Во-первых, нужно будет выбрать, от какого класса мы будем наследовать. Поскольку класс должен быть управляемым игроком, нам понадобится Pawn. Выберите   и нажмите  . 
 
 
На следующем экране можно указать имя и путь к файлам .h и .cpp. Замените   на   и нажмите на  . 
 
 
При этом будут созданы файлы и скомпилирован проект. После компиляции Unreal откроет Visual Studio. Если   и   не будут открыты, то перейдите в Solution Explorer и откройте их. Они находятся в папке  . 
 
 
Прежде чем двигаться дальше, вам нужно узнать о   Unreal. Эта система управляет различными частями движка, такими как панель Details и сборка мусора. При создании класса с помощью C++ Class Wizard движок Unreal добавляет в заголовок три строки: 
 
 
Движку Unreal нужны эти строки, чтобы класс был видим системе рефлексии. Если вам это не понятно, то не волнуйтесь. Вам достаточно только знать, что системе рефлексии позволяет делать такие вещи, как раскрытие функций и переменных Blueprints и редактору. 
 
Вы можете также заметить, что класс называется  , а не  . При создании класса типа actor Unreal ставит перед названием класса префикс   (от слова  ). Чтобы система рефлексии могла работать, ей нужно, чтобы классы имели соответствующие префиксы. Подробнее прочитать о префиксах можно в   Epic. 
 
 
Это всё, что вам пока нужно знать о системе рефлексии. Теперь нам нужно добавить модель игрока и камеру. Для этого нужно использовать  . 
 
 
Для Pawn игрока нам нужно добавить три компонента: 
 
 
Во-первых, нам нужно добавить заголовки для каждого типа компонента. Откройте   и добавьте над   следующие строки: 
 
 
 
Теперь нам нужно объявить переменные для каждого компонента. Добавьте после   следующие строки: 
 
 
Использованное здесь имя будет именем компонента в редакторе. В нашем случае компоненты будут отображаться как  ,   и  . 
 
Далее нам нужно сделать каждую переменную видимой для системы рефлексии. Для этого добавим над каждой переменной  . Теперь код должен выглядеть вот так: 
 
 
Также можно добавить к    . Они будут управлять поведением переменной в различных аспектах движка. 
 
Добавьте   и   внутри скобок каждого  . Отделите каждый описатель запятой. 
 
 
  позволит каждому компоненту быть видимым в редакторе (в том числе и в Blueprints). 
 
  позволит   ссылку на компонент с помощью нодов Blueprint. Однако он не позволит нам   компонент. Для компонентов важно быть read-only, потому что их переменные являются указателями. Мы  , чтобы пользователи задавали их, иначе они могут указать на случайное место в памяти. Стоит заметить, что   всё-таки позволяет задавать переменные   компонента, и именно к такому поведению мы стремимся. 
 
 
Теперь, когда у нас есть переменные для каждого компонента, нам нужно их инициализировать. Для этого необходимо создать их внутри  . 
 
 
Для создания компонентов можно использовать  . Откройте   и добавьте в   следующие строки: 
 
 
Это создаст компонент каждого типа, а затем назначит их адрес в памяти переданной переменной. Аргумент-строка будет внутренним именем компонента, используемым движком (  отображаемым именем, несмотря на то, что в нашем случае они одинаковы). 
 
Затем нам нужно настроить иерархию (выбрать корневой компонент и так далее). Добавьте после предыдущего кода следующее: 
 
 
Первая строка сделает     компонентом. Вторая строка прикрепит   к  . Наконец, третья строка прикрепит   к  . 
 
После завершения кода компонентов нам нужно выполнить компиляцию. Выберите один из следующих способов компиляции: 
 
 
Затем нам нужно указать, какой меш использовать и поворот пружинного рычага. Рекомендуется делать это в Blueprints, потому что нежелательно жёстко указывать пути к ресурсам в C++. Например, в C++ для задания статичного меша нужно сделать нечто подобное: 
 
 
Однако в Blueprints достаточно будет просто выбрать меш из раскрывающегося списка. 
 
 
Если вы переместите ресурс в другую папку, в Blueprints ничего не испортится. Однако в C++ придётся менять каждую ссылку на этот ресурс. 
 
Чтобы задать поворот меша и пружинного рычага в Blueprints, нужно будет создать Blueprint на основании  . 
 
 
 
В Unreal Engine перейдите в папку   и создайте  . Разверните раздел   и найдите  . Выберите  , а затем нажмите на  . 
 
 
Переименуйте его в  , а затем откройте. 
 
Сначала мы зададим меш. Выберите компонент   и задайте для его   значение  . 
 
 
Затем нам нужно задать поворот и длину пружинного рычага. Наша игра будет с видом сверху, поэтому камера должна быть над игроком. 
 
Выберите компонент   и задайте для   значение  . Это повернёт пружинный рычаг так, что камера будет смотреть на меш сверху вниз. 
 
 
Поскольку пружинный рычаг является дочерним элементом меша, он начинает вращаться, когда начинает вращаться шар. 
 
 
Чтобы исправить это, нам нужно сделать так, чтобы поворот рычага был  . Нажмите на   рядом с   и выберите  . 
 
 
Затем задайте для   значение  . Так мы отдалим камеру на 1000 единиц от меша. 
 
 
Затем нужно задать Default Pawn Class, чтобы использовать наш Pawn. Нажмите на   и вернитесь в редактор. Откройте   и задайте для   значение  . 
 
 
Нажмите на  , чтобы увидеть Pawn в игре. 
 
 
Следующим шагом будет добавление функций игроку, чтобы он мог перемещаться. 
 
 
Вместо того, чтобы добавлять для движения смещение, мы будем двигаться с помощью физики! Сначала нам нужна переменная, указывающая величину прикладываемой к шару силы. 
 
Вернитесь в Visual Studio и откройте  . Добавьте после переменных компонентов следующее: 
 
 
  позволяет изменять   в панели Details.   позволит задавать и считывать   с помощью нодов Blueprint. 
 
Далее нам нужно создать две функции. Одну для движения вверх-вниз, другую — для движения влево-вправо. 
 
 
Добавьте под   следующие объявления функций: 
 
 
Позже мы   с этими функциями привязки осей. Благодаря этому привязки осей смогут передавать свой   (поэтому функциям нужен параметр  ). 
 
 
Теперь нам нужно создать реализацию для каждой функции. Откройте   добавьте в конец файла следующее: 
 
 
  добавляет физическую силу для   по  . Величина силы задаётся  . Благодаря умножению результата на   (масштаб привязки оси), меш может перемещаться в   или   направлениях. 
 
  делает то же самое, что и  , но по  . 
 
Закончив создание функций движения, мы должны связать с ними привязки осей. 
 
 
Ради упрощения я уже заранее создал привязки осей. Они находятся в  , в разделе  . 
 
 
 
Добавьте внутрь   следующий код: 
 
 
Так мы свяжем привязки осей   и   с   и  . 
 
На этом мы закончили с функциями движения. Теперь нам нужно включить физику для компонента  . 
 
 
Добавьте внутрь   следующие строки: 
 
 
Первая строка позволит воздействовать на   физическим силам. Вторая строка присваивает   значение  . Это значит, что при движении шару будет прибавлено 100 000 силы. По умолчанию физические объекты весят примерно 110 килограмм, так что для их перемещения потребуется много силы! 
 
Если мы создали подкласс, некоторые свойства не изменятся, даже если мы изменим их в базовом классе. В нашем случае у   не будет включено  . Однако теперь во всех создаваемых подклассах оно будет включено по умолчанию. 
 
Выполните компиляцию и вернитесь в Unreal Engine. Откройте   и выберите компонент  . Затем включите  . 
 
 
Нажмите  , а затем на  . Нажимайте  ,  ,   и  , чтобы передвигать шар. 
 
 
Далее мы объявим функцию C++, которую можно реализовать с помощью Blueprints. Это позволит дизайнерам создавать функционал без использования C++. Чтобы научиться этому, мы создадим функцию прыжка. 
 
 
Сначала нам нужно связать привязку прыжка к функции. В этом туториале мы назначим прыжок на  . 
 
 
Вернитесь в Visual Studio и откройте  . Добавьте под   следующие строки: 
 
 
Первое — это переменная float с именем  . Мы можем использовать её при реализации прыжка. Она использует  , чтобы её можно было изменять в редакторе. Также в ней используется  , чтобы мы могли считывать и записывать её с помощью нодов Blueprint. 
 
Далее идёт функция прыжка.   делает   видимой для системы рефлексии.   позволяет Blueprints реализовать  . Если реализация отсутствует, то вызовы   ни к чему не приведут. 
 
 
Так как   — это привязка  , способ связывания немного отличается. Закройте   и откройте  . Добавьте внутрь   следующее: 
 
 
Так мы свяжем привязку   с  . Она будет выполняться только при   клавиши прыжка. Если вы хотите выполнять её при   клавиши, то используйте  . 
 
Дальше мы переопределим   в Blueprints. 
 
 
Выполните компиляцию и закройте  . Затем вернитесь к Unreal Engine и откройте  . Перейдите в панель My Blueprints и наведите мышь на  , чтобы появился раскрывающийся список  . Нажмите на него и выберите  . Так мы создадим  . 
 
 
 
Далее мы создадим следующую схему: 
 
 
Так мы добавим   импульс ( ) по  . Учтите, что в этой реализации игрок может прыгать бесконечно. 
 
Далее нам нужно задать значение  . Нажмите на   в Toolbar, а затем перейдите к панели Details. Задайте   значение  . 
 
 
Нажмите на  , а затем закройте  . Нажмите на   и попробуйте попрыгать с помощью  . 
 
 
В следующем разделе мы заставим монеты исчезать при контакте с игроком. 
 
 
Для обработки коллизий нам нужно связать функцию с событием наложения. Для этого функция должна удовлетворять двум требованиям. Первое — функция должна иметь макрос  . Второе требование — функция должна иметь правильную сигнатуру. В этом туториале мы будем использовать событие  . Это событие требует, чтобы у функции была следующая сигнатура: 
 
 
Вернитесь в Visual Studio и откройте  . Добавьте под   следующие строки: 
 
 
После связывания   будет исполнятся при наложении монеты и другого актора.   будет монетой, а   — другой актор. 
 
Далее нам нужно реализовать  . 
 
 
Откройте   и добавьте в конец файла следующее: 
 
 
Так как мы хотим распознавать только наложения игрока, то нужно привести   к  . Прежде чем выполнить приведение, нам нужно добавить заголовок для  . Добавьте под   следующее: 
 
 
Теперь нам нужно выполнить приведение. В Unreal Engine приведение можно выполнить так: 
 
 
Если приведение выполнено успешно, то оно вернёт указатель на  . Если неудачно, то оно вернёт  . Проверяя результат на  , мы можем определить, имел ли объект нужный тип. 
 
Добавьте внутрь   следующее: 
 
 
Теперь, когда   выполняется, она будет проверять, имеет ли   тип  . Если это так, то она будет уничтожать монету. 
 
Далее нам нужно привязать  . 
 
 
Чтобы связать функцию с событием наложения, нам нужно использовать с событием  . Добавьте внутрь   следующее: 
 
 
Так мы свяжем   с событием  . Это событие происходит всегда, когда актор накладывается на другого актора. 
 
Выполните компиляцию и вернитесь в Unreal Engine. Нажмите   и начните собирать монеты. При контакте с монетой она будет уничтожаться, что приводит к её исчезновению. 
 
 
 
В следующем разделе мы создадим ещё одну переопределяемую функцию C++. Однако на этот раз мы также создадим реализацию по умолчанию. Для демонстрации этого мы воспользуемся  . 
 
 
Чтобы создать функцию с реализацией по умолчанию, нужно использовать описатель  . Вернитесь в Visual Studio и откройте  . Добавьте для  
 в    : 
 
 
Чтобы сделать функцию реализацией по умолчанию, нам нужно добавить суффикс  . Откройте   и замените   на  : 
 
 
Теперь если дочерний Blueprint не реализует  , то будет использована эта реализация. 
 
Следующим этапом будет реализация   в  . 
 
 
Для реализации в Blueprint мы будем вызывать  . Эта функция C++ увеличит скорость вращения монеты. Через 0,5 секунды монета будет себя уничтожать. 
 
Для вызова функции C++ из Blueprints нам нужно использовать описатель  . Закройте   и откройте  . Добавьте над   следующее: 
 
 
Выполните компиляцию и закройте Visual Studio. Вернитесь к Unreal Engine и откройте  . Переопределите   и создайте следующую схему: 
 
 
Теперь при наложении игрока на монету будет выполняться  . 
 
Нажмите на   и закройте  . Нажмите   и соберите несколько монет, чтобы протестировать новую реализацию. 
 
 
 
Вы можете скачать готовый проект  . 
 
Как вы видите, работать с C++ в Unreal Engine довольно просто. Хотя мы уже добились кое-чего в C++, вам ещё нужно многому научиться! Я рекомендую изучить серию туториалов Epic по созданию с помощью C++  . 
 
Если вы новичок в Unreal Engine, то изучите нашу   из десяти частей. В этой серии вы познакомитесь с различными системами, такими как Blueprints, материалы и системы частиц.
