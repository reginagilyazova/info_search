Концептуальная сортировка в С++20
MarkGrin
К изменениям лучше готовиться заранее, поэтому предлагаю посмотреть на то, что войдет в стандарт C++20, а именно на 
.
Сейчас концепции имеют статус технической спецификации(
): документ их описывающий 
. Такие документы нужны, чтобы перед принятием нововведений в стандарт языка, эти нововведения были опробованы и скорректированы сообществом С++. Компилятор gcc поддерживает техническую спецификацию концепций в экспериментальном режиме с 2015 года. 
Стоит заметить, что концепции из технической спецификации и концепции из текущего черновика С++20 различаются, но не сильно. В статье рассматривается вариант технической спецификации.
Шаблоны классов и функций могут быть связаны с 
. Ограничения накладывают требования на аргументы шаблона. Концепции это именованные наборы таких ограничений. Каждая концепция является булевой функцией(
), проверяющей эти ограничения. Проверка производится на этапе компиляции при инстацировании шаблона связанного с концепцией или ограничением. Если такая проверка не проходит, то компилятор укажет какой аргумент шаблона провалил проверку какого ограничения.
Теперь когда понятны смысл и назначение концепций можно рассмотреть синтаксис. Определения концепций имеют две формы: переменной и функции. Нас будет интересовать форма переменной. Она очень похожа на определение обычной шаблонной переменной, но с ключевым словом 
. 
Вместо комментария нужно написать constexpr выражение, которое приводится к bool. Это выражение и есть ограничение на аргумента шаблона. Что бы ограничить шаблон концепцией, нужно вместо typename(или class) использовать её название.
Например, для целых чисел:
Можно ставить более сложные ограничения, используя требование-выражение(
). Требование-выражение умеет проверять правильность(
) выражения, возвращаемое значение выражения, наличие типов. Синтаксис хорошо разобран 
.
Как же концепции помогут в написании сортировки? Сам алгоритм останется неизменным, но шаблон сортировки можно улучшить с помощью концепций. Рассмотрим такой пример:
Ошибка заключается, в том что у структуры NonComparable нет операции сравнения. Представляете как будет выглядеть ошибка компилятора? Если нет, то загляните под спойлер.
Такие ошибки можно сократить с помощью концепций, для этого напишем враппер их использующий. Сортировка принимает итераторы, поэтому нужно написать концепцию Сортируемый итератор. Для такого итератора, нужно несколько концепций поменьше. Например, сравнимый объект(приведен выше), обмениваемый объект:
перемещаемый объект
итератор случайного доступа
Когда все простые концепции готовы, можно определить составную концепцию Сортируемого итератора:
С его помощью пишется враппер:
Если вызывать "концептуальную" сортировку с несравниваемым объектом,
то ошибка компиляции будет занимает всего 16 строк:
Конечно, первые разы все равно не очень просто понять в чем ошибка, но после нескольких "концептуальных" ошибок они начинают читаться за несколько секунд.
Конечно, 
 не единственное преимущество нововведения. Шаблоны станут безопаснее благодаря 
. Код станет более читаемым благодаря 
 концепциям(самые часто используемые войдут в 
). В целом С++ расширится в своей функциональной(шаблонной) части.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

