Исследуем сопоставление с образцом в C# 7
JosefDzeranov
В C# 7 наконец появилась долгожданная возможность под названием «сопоставление с образцом» ( ). Если вы знакомы с функциональными языками, такими как F#, вы можете быть немного разочарованы этой возможностью в ее текущем виде, но даже сегодня она может упростить ваш код в самых разных сценариях.  
 
Каждая новая возможность чревата опасностью для разработчика, работающего в критическом для производительности приложении. Новые уровни абстракций хороши, но для того, чтобы эффективно использовать их, вы должны знать, что происходит под капотом. Сегодня мы собираемся изучить внутренности сопоставления с образцом, чтобы понять, как это реализовано. 
Язык C# ввел понятие образца, которое может использоваться в is-выражении и внутри блока   оператора  . 
 
Существует 3 типа шаблонов: 
 
 
 
 
is-выражение может проверить, равно ли значение константе, а проверка типа может дополнительно создавать переменную образца ( ). 
 
Я нашел несколько интересных аспектов, связанных с сопоставлением с образцом в is-выражениях: 
 
 
Сначала проверим первые два случая: 
 
 
Первый оператор   вводит переменную  , и переменная видна внутри всего метода. Это разумно, но усложнит логику, если другие if-операторы в том же блоке будут пытаться повторно использовать одно и то же имя еще раз. В этом случае вам  использовать другое имя, чтобы избежать коллизий. 
 
Переменная, введенная в is-выражении, полностью определена только тогда, когда предикат является  . Это означает, что переменная   во втором операторе   не определена в правом операнде, но поскольку эта переменная уже объявлена, мы можем использовать ее как переменную   в методе  . 
 
Третий аспект, упомянутый выше, является наиболее важным. Рассмотрим следующий код: 
 
 
В большинстве случаев, is-выражение преобразуется в   (даже если спецификация говорит, что   должен использоваться для примитивных типов): 
 
 
Этот код вызывает 2 упаковки (boxing), которые могут весьма серьезно повлиять на производительность, если они используются в критическом пути приложения. Когда-то выражение   так же вызывало упаковку (см.  ) и, я надеюсь, что текущее поведение так же будет исправлено в скором времени (вот соответствующий  на гитхабе). 
 
Если  -переменная имеет тип  , то   приведет к одному выделению памяти (для упаковки литерала  ), хотя подобный код на основе switch не приводит к выделениям памяти. 
 
 
Образец  является частным случаем образца типа с одним ключевым отличием: образец будет соответствовать любому значению, даже если значение равно  . 
 
 
 , когда   не  , но   всегда  . Компилятор знает об этом и в режиме Release (*) полностью удаляет конструкцию if и просто оставляет вызов консольного метода. К сожалению, компилятор не предупреждает, что код недостижим в следующем случае:  
 . Надеюсь, это тоже будет исправлено. 
 
(*) Непонятно, почему поведение отличается только в режиме Release. Но я думаю, что все проблемы имеют одну природу: первоначальная реализация фичи неоптимальна. Но на основе   Нила Gafter это изменится: «Плохой код, соответствующий сопоставлению с образцом, переписывается с нуля (для поддержки рекурсивных шаблонов тоже). Я ожидаю, что большинство улучшений, которые вы ищете здесь, будут „бесплатными“ в новом коде.». 
 
Отсутствие проверки на  делает этот случай очень особенным и потенциально опасным. Но если вы знаете, что именно происходит, вы можете найти этот вариант сопоставления полезным. Его можно использовать для введения временной переменной внутри выражения: 
 
 
 
Есть другой случай, который я нашел очень полезным. Образец типа соответствует значению, только если значение не равно  . Мы можем использовать эту «фильтрующую» логику с   оператором, чтобы сделать код более читабельным: 
 
 
Обратите внимание, что один и тот же шаблон может использоваться как для типов значений, так и для ссылочных типов. 
 
 
C# 7 расширяет оператор  для использования образцов в  -блоках: 
 
 
В примере показан первый набор изменений в операторе switch. 
 
 
(**) В последнем  -блоке показана еще одна возможность, добавленная в C# 7, называемая шаблоном « ». Имя   является специальным и сообщает компилятору, что переменная не нужна. Шаблон типа в предложении  требует имени переменной, и если вы не собираетесь ее использовать, то вы можете ее проигнорировать с помощью  . 
 
Следующий фрагмент показывает еще одну особенность сопоставления с образцом на основе   — возможность использования предикатов: 
 
 
  может иметь более одного  -блока с одним и тем же типом. В этом случае, компилятор объединяет все проверки типов в один блок, чтобы избежать избыточных вычислений: 
 
 
Но нужно иметь в виду две вещи: 
 
 
 

