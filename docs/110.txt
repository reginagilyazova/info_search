Пишем масштабируемые и поддерживаемые сервера на Node.js и TypeScript
Altox
Џоследние три года Я занимаюсь разработкой серверов на Node.js и в процессе работы у менЯ накопилась некотораЯ кодоваЯ база, которую Я решил оформить в виде фреймворка и выложил в open-source. 
Ћсновными особенностЯми фреймворка можно назвать:
‚ данной статье мы поговорим немного о Node.js и рассмотрим данный фреймворк
‚сем кому интересно Р прошу под кат
ЋсновнаЯ проблема серверной разработки на Node.js заключаетсЯ в двух вещах:
‘ отсутствием инфраструктуры все просто: Node.js достаточно молодаЯ платформа, поэтому вещи, которые можно удобно и быстро написать на более взрослых платформах (например тот же PHP или .NET) в Node.js вызывают сложности.
—то же с низким уровнем вхождениЯ? ’ут основнаЯ проблема в том, что с каждым оборотом колеса хайпа и приходом новых библиотек/фреймворков, все пытаютсЯ упростить. Љазалось бы, проще С лучше, но т.к. пользуютсЯ этими решениЯми в итоге не всегда опытные разработчики С возникает культ поклонениЯ библиотекам и фреймворкам. Ќаверное самый очевидный пример С это express.

—то не так с express? „а ничего! Ќет, безусловно в нем можно найти недостатки, но express С это инструмент, инструмент которым нужно уметь пользоватьсЯ, проблемы начинаютсЯ когда express, или любой другой фреймворк, занимает главную роль в вашем проекте, когда вы слишком завЯзаны на нем.
€сходЯ из вышеперечисленного, начинаЯ разрабатывать новый проект, Я начал с написаниЯ некоторого "Ядра" сервера, позже оно переносилось в другие проекты, дорабатывалось и в конечно итоге стало фреймврком Airship.
ЌачинаЯ продумывать архитектуру Я задал себе вопрос: "—то делает сервер?". Ќа самом высоком уровне абстракции сервер делает три вещи: 
‚се же просто, зачем усложнЯть себе жизнь? џ решил, что архитектура должна быть примерно следующей: у каждого запроса, поддерживаемого нашим севером, есть модель, модели запросов поступают в обработчики запросов, обработчики в свою очередь отдают модели ответов.

‚ажно заметить, что наш код ничего не знает про сеть, он работает только с инстансами обычных классов запросов и ответов. ќтот факт позволЯет нам не только доитьсЯ более гибкой архитектуры, но и даже сменить транспортный слой. Ќапример мы можем пересесть с HTTP на TCP без изменениЯ нашего кода. Ѓезусловно это очень редкий случай, но такаЯ возможность показывает нам гибкость архитектуры.
Ќачнем с моделей, что от них нужно? ‚ первую очередь нам нужен простой способ сериализации и десериализации моделей, еще не помешает валидациЯ типов при десериализации, т.к. пользовательские запросы С это тоже модели. 
‚ дальнейшем описании Я опущу некоторые детали, которые можно прочитать в документации, чтобы не раздувать статью.
‚от как это работает: 
Љак видим, модель С это обычный класс, единственное отличие С это использование декоратора 
. ‘ помощью этого декоратора мы указываем полЯ сериализатору.

’еперь мы можем сариализировать и десериализировать нашу модель: 
…сли мы передадим данные неверного типа, то сериализатор выбросит исключение: 
‡апросы С это те же модели, разница в том, что все запросы наследуютсЯ от 
 и используют декоратор 
 длЯ указаниЯ пути запроса:
Њодели ответов тоже пишутсЯ как обычно, но наследуютсЯ от 
: 
Ћбработчики запросов наследуютсЯ от 
 и реализуют два метода:
’.к. при таком подходе не очень удобно реализовывать обработку нескольких запросов в одном обработчике Р существует потомок 
, который называетсЯ 
 и позволЯет обрабатывать несколько запросов: 
‘уществует базовый класс 
, который описывает поставщика запросов в систему: 
‘истема вызывает метод 
, ждет запросов, обрабатывает их и передает ответ в 
.
„лЯ получениЯ запросов по HTTP реализован 
, он работает очень просто: все запросы приходЯт через POST, а данные приходЯт в json. €спользовать его тоже просто, достаточно передать порт и список поддерживаемых запросов: 
Ћсновной класс сервера С это 
, в него мы передаем обработчик запросов и поставщика запросов. ’.к. 
 принимает только один обработчик С был реализован менеджер обработчиков, который принимает список обработчиков и вызывает нужный. ‚ итоге наш сервер будет выглЯдеть так: 
‘хема API С это такой специальный JSON, который описывает все модели, запросы и ответы нашего сервера, его можно сгенерировать с помощью специальной утилиты 
.
‚ первую очередь нужно создать конфиг, который укажет все наши запросы и ответы: 
Џосле этого мы можем запустить утилиту, указав путь до конфига и до папки, в которую будет записана схема:
‡ачем же нам нужна схема? Ќапример мы можем сгенерировать полностью типизированное SDK длЯ фронтенда на TypeScript. SDK состоит из четырех файлов: 
Џриведу кусок API.ts из рабочего проекта: 
‚есь этот код написан автоматически, это позволЯет не отвлекатьсЯ на написание клиента и бесплатно получить подсказки названий полей и их типов, если ваша IDE это умеет.
‘генерировать SDK тоже просто, нужно запустить утилиту 
 и передать ей путь до схем и путь, где будут лежать SDK:
Ќа генерации SDK Я не остановилсЯ и написал генерацию документации. „окументациЯ достаточно простаЯ, это обычный HTML с описанием запросов, моделей, ответов. €з интересного: длЯ каждой модели есть сгенерированный код длЯ JS, TS и Swift:
„анное решение уже долгое времЯ используетсЯ в production, помогает поддерживать старый код, писать новый и не писать код длЯ клиента.

Њногим и статьЯ и сам фреймворк может показатьсЯ очень очевидным, Я это понимаю, другие могут сказать, что такие решениЯ уже есть и даже ткнуть менЯ носом в ссылку на такой проект. ‚ свою защиту Я могу сказать только две вещи: 
…сли кому-то все вышеперечисленное понравилось С добро пожаловать в 
.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

