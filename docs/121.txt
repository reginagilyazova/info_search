Создание системы бонусов в Unity
PatientZero

На что бы была похожа игра Sonic The Hedgehog без золотых колец и скоростных ботинок, Super Mario без грибов или Pac-Man без мигающих точек? Все эти игры стали бы намного скучнее! 
 
  — это важнейший компонент игрового процесса, потому что они добавляют новые уровни комплексности и стратегии, побуждая игрока к действию. 
 
В этом туториале вы научитесь следующему: 
 
 
 
Для повторения действий туториала вам потребуется Unity 2017.1 или более новой версии, поэтому обновите свою версию Unity, если ещё этого не сделали. 
 
 
 
Игра, над которой мы будем работать — это двухмерная аркада с видом сверху, где игрок пытается увернуться от врагов; она немного похожа на Geometry Wars, но без стрельбы (и без коммерческого успеха). Наш герой в шлеме должен уворачиваться от врагов, чтобы добраться до выхода; при столкновении с врагами его здоровье уменьшается. Когда здоровье заканчивается, наступает game over. 
 
Скачайте   для этого туториала и извлеките её в нужную папку. Откройте проект в Unity и изучите папки проекта: 
 
 
 
Откройте сцену под названием   и нажмите на кнопку  . 
 
 
Вы увидите, что в игре пока нет бонусов. Поэтому уровень пройти сложно и игра кажется немного скучноватой. Наша задача — добавить бонусы и оживить игру. Когда игрок подбирает бонус, на экране появляется цитата из известной серии фильмов. Посмотрим, сможете ли вы узнать её. Ответ будет в конце туториала! 
 
 
У бонуса есть  , состоящий из нескольких отдельных состояний: 
 
 
 
В представленном выше цикле жизни содержатся элементы, которые стоит использовать в любой игре, и элементы, которые относятся только к конкретной игре. Например, проверку подбора игроком бонуса стоит использовать в каждой игре, но определённую полезную нагрузку, делающую игрока невидимым, возможно, стоит использовать только в этой игре. Важно учесть это при создании дизайна логики скриптов. 
 
 
 
Скорее всего, вам знакомы бонусы «начального уровня», представляющие собой золотые монеты, звёзды или кольца, дающие очки или прибавку к здоровью. Сейчас мы создадим в сцене бонус-звезду, которая даёт игроку мгновенную прибавку здоровья и увеличивает шансы героя на прохождение уровня живым. 
 
Чтобы сбежать с уровня, недостаточно будет рассчитывать только на звёзды, так что позже мы добавим и другие бонусы, дающие нашему герою преимущества в бою. 
 
Создайте новый  , назовите его   и расположите прямо над героем в точке  . Чтобы сцена была упорядоченной, сделайте спрайт дочерним элементом пустого GameObject   в сцене: 
 
 
Теперь зададим внешний вид спрайта. Введите для   значения  , в компоненте   назначьте слоту   звезду, а для   выберите бледно-коричневый цвет  . 
 
 
Добавьте компонент  , поставьте флажок   и измените   на  : 
 
 
Мы только что создали первый бонус! Запустите игру, чтобы убедиться, что всё выглядит хорошо. Бонус появляется, но когда вы пытаетесь его поднять, то ничего не происходит. Чтобы исправить это, нам потребуются скрипты. 
 
 
 
Будучи ответственными разработчиками, мы хотим оптимальнее тратить своё время и повторно использовать элементы из предыдущих проектов. Чтобы применить это к системе бонусов, нам нужно создавать её дизайн с  . Иерархия классов разделяет логику бонусов на многоразовую часть движка и часть, относящуюся только к конкретной игре. Если вам неизвестна идея иерархий классов и наследования, то  . 
 
 
На схеме выше показан класс   в качестве родительского класса. Он содержит независящую от игры логику, поэтому мы можем повторно использовать её «как есть» почти в любом другом проекте. В проекте туториала уже есть родительский класс. Родительский класс управляет циклом жизни бонуса, различными состояниями, которые может иметь бонус, обрабатывает коллизии, подбирание бонуса, полезные нагрузки, сообщения и завершение действия бонуса. 
 
Родительский класс реализует простой конечный автомат, отслеживающий цикл жизни бонуса.   нужно реализовать подкласс и значения инспектора для каждого нового бонуса, и на этом всё! 
 
 
  для создания скрипта бонуса мы должны создать подкласс класса   и обеспечить выполнение всех пунктов списка. В туториале мы несколько раз будем обращаться к этому списку, так что держите его под рукой! 
 
 
Давайте подумаем о том, что делает бонус-звезда: он просто даёт небольшую прибавку к здоровью. Чтобы это сделать, достаточно небольшого скрипта. 
 
 
Добавьте новый скрипт к GameObject  , назовите его   и откройте в редакторе. 
 
 
Добавьте следующий код, замените бОльшую часть начального boilerplate-кода Unity, оставив только конструкции   в начале. 
 
 
Код довольно короткий, но его достаточно, чтобы реализовать логику звезды! Скрипт соответствует всем пунктам контрольного списка: 
 
 
 
После сохранения и возврата в Unity GameObject   будет выглядеть в инспекторе следующим образом: 
 
 
Введите значения инспектора следующим образом: 
 
 
После того, как вы это сделаете, бонус будет выглядеть следующим образом: 
 
 
Завершив с параметрами PowerUpStar, перетащите его в папку дерева проекта  , чтобы создать префаб. 
 
 
Используйте новый префаб, чтобы добавить несколько звёзд в правой части сцены. 
 
Запустите сцену и проведите героя к первому бонусу. Подбор бонуса сопроводят замечательные звуковые эффекты и частицы. Отлично! 
 
 
 
Следующий создаваемый нами бонус требует фоновой информации. Чтобы получить эту информации, нам нужно, чтобы GameObjects научились обмениваться между собой данными. 
 
Например, когда мы подбираем бонус, UI должен знать, какую информацию нужно отобразить. Когда здоровье игрока меняется, полоска энергии должна знать, каким стал обновлённый уровень здоровья. Это можно реализовать множеством способом, но  . 
 
Каждый способ коммуникации имеет свои плюсы и минусы, и нельзя подобрать один, подходящий ко всем случаям. В нашей игре мы реализуем  , как она описана в  . 
 
Мы можем сделать GameObjects на  ,  , или и тем, и другим: 
 
 
В левой части представленной выше схемы представлены  . Можно считать их объектами, «кричащими», когда происходит что-то интересное. Например, если игрок передаёт сообщение «Меня задели». В правой части схемы показаны  . Как понятно из названия, они слушают сообщения. Слушатели не обязаны слушать   сообщения; они слушают только те сообщения, на которые хотят реагировать. 
 
Передатчики сообщений могут быть также и слушателями. Например, бонус передаёт сообщения, но и слушает сообщения игрока. Хорошим примером здесь может быть бонус, срок действия которого кончается, когда игрока задевают враги. 
 
Можно понять, что при наличии множества передатчиков и множества слушателей, между левой и правой сторонами должно быть множество пересекающихся линий. Чтобы упростить нам жизнь, в Unity имеется компонент  , который располагается посередине: 
 
 
Unity использует расширяемый компонент   для обработки ввода. Также этот компонент управляет большей частью логики событий отправки и получения. 
 
Да, многовато теории, но подведём итог: система сообщений позволит бонусам удобно слушать игровой процесс и снизить количество жёстких соединений между объектами. Это позволит упростить добавление новых бонусов, особенно на поздних этапах разработки, потому что большинство сообщений уже будет передаваться. 
 
 
Прежде чем приступить к созданию, нам нужно немного теории. Для вещания сообщения нам нужно выполнить следующие этапы: 
 
 
См.  , если вам нужно освежить свои знания. 
 
Если вкратце, то интерфейс определяет сигнатуры метода. Любой класс,   интерфейс, обещает предоставить функционал этим методам. 
 
Более чётко это можно увидеть на примере. Посмотрите на код в файле  : 
 
 
У этого интерфейса C# есть методы для   и  . Это сообщения, которые может отправить игрок. Теперь посмотрите на метод   в файле  . Строки, помеченные числами в следующем фрагменте кода, описаны ниже: 
 
 
Представленный выше метод обрабатывает отправку сообщения  . Цикл   обходит всех слушателей, хранящихся в списке   и вызывает для каждого слушателя  , который отправляет сообщения. 
 
Пройдёмся по комментариям с числами: 
 
 
Проект уже настроен для передачи всех необходимых сообщений. Некоторые из них могут оказаться полезными, если вы захотите расширить проект и добавить собственные бонусы. По стандартной договорённости все имена интерфейсов начинаются с буквы I: 
 
 
 
Все эти интерфейсы подробно прокомментированы, так что вы можете изучить их. Необязательно разбираться с ними в этом туториале, если хотите, можете двигаться дальше. 
 
 
 
Теперь, когда мы знаем о связи на основе сообщений, мы воспользуемся ею и будем слушать сообщение! 
 
Мы создадим бонус, дающий игроку дополнительную скорость до момента, пока он с чем-нибудь не столкнётся. Бонус будет распознавать столкновение игрока «прослушивая» игровой процесс. А конкретнее, бонус будет слушать игрока, передающего сообщение «I am hurt». 
 
Чтобы слушать сообщение, нам нужно выполнить следующие шаги: 
 
 
Создайте новый Sprite, назовите его   и расположите где-нибудь в левом верхнем углу арены над игроком. Задайте для его   значения  . Этот GameObject будет слушателем, поэтому укажите ему в инспекторе метку  . 
 
Добавьте   и измените его   на  . В компоненте   назначьте для   значение   и измените его цвет так, как мы делали со звездой. Не забудьте также поставить флажок  . После этого GameObject должен выглядеть примерно так: 
 
 
Добавьте этому GameObject новый скрипт   и вставьте в скрипт следующий код: 
 
 
Проверим пункты контрольного списка. Скрипт выполняет каждый из пунктов следующим образом: 
 
 
Изменим объявление класса, чтобы реализовать интерфейс для сообщений игрока: 
 
 
 
Добавляйте или изменяйте методы, пока они не будут выглядеть следующим образом, и убедитесь, что они всё ещё являются частью класса  : 
 
 
Метод   вызывается каждый раз, когда игрок получает урон. Это часть «прислушивания к вещаемым сообщениям». В этом методе мы сначала делаем так, чтобы бонус реагировал только после подбора. Затем код вызывает   в родительском классе, который будет обрабатывать логику истечения срока действия. 
 
Сохраните этот метод и вернитесь в Unity, чтобы внести нужные изменения в инспекторе. 
 
 
GameObject   теперь будет выглядеть в инспекторе следующим образом: 
 
 
Введите в инспекторе следующие значения: 
 
 
После этого бонус будет выглядеть следующим образом: 
 
 
Настроив параметры бонуса   нужным вам образом, перетащите его в папку дерева проекта  , чтобы создать префаб. Мы не будем использовать его в демо-проекте, но для завершённости стоит это сделать. 
 
Запустите сцену и переместите героя, чтобы собрать бонус скорости, после чего он получит дополнительную скорость, которая будет сохраняться до контакта с врагом. 
 
 
 
 
 
Следующий бонус позволяет игроку отталкивать объекты со своего пути нажатием клавиши  ; количество его применений ограничено. Вы уже знакомы с этапами создания бонуса, поэтому чтобы не загромождать текст, я рассмотрю только самые интересные части кода, а затем создам префаб. Этому бонусу не нужно слушать никакие сообщения. 
 
Найдите и изучите в иерархии проекта префаб  . Откройте его скрипт под названием   и изучите код. 
 
 
Вы увидите знакомые методы, которые мы уже рассматривали. Все интересные действия отталкивающего бонуса происходят в методе  : 
 
 
Вот, что происходит в этом коде: 
 
 
Отталкивающим бонусом очень интересно пользоваться, поэтому стоит разместить парочку в подходящих местах сцены. Запустите сцену ещё раз и поиграйте с новым бонусом. 
 
 
 
 
Этот раздел необязателен, но довольно интересен. Вооружённые полученными знаниями, создайте бонус, на какое-то время делающий игрока неуязвимым. 
 
Советы и рекомендации для выполнения этого задания: 
 
 
Вам нужно полное решение или вы хотите сравнить своё решение с нашим? Тогда вот оно: 
 
 
Надеюсь, вы попробовали решить задание, прежде чем посмотрели решение! 
 
 
 
Готовый проект для этого туториала можно скачать  . 
 
Если вы хотите дальше развивать проект, то можно сделать следующее: 
 
 
Вы всё ещё не поняли, из какой серии фильмов эти фразы? Ответ под спойлером: 
 

