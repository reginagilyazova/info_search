Мобильные устройства изнутри. Структура образов разделов, содержащих файловую систему. Часть 1
vin2809

Часть 2 
3.2._sparsechunk-файлы. 
4.Создание  -файлов. 
5.Источники информации. 
 
 
 
Образы разделов мобильных устройств (МУ), содержащих файловую систему (ФС) ext4, имеют большие размеры, например, размер образа раздела system может достигать нескольких ГБ, а размер образа раздела userdata составляет уже несколько десятков ГБ. 
 
Эти особенности требуют от разработчика прошивок применения «хитростей» при выполнении операций первоначальной загрузки прошивок МУ или установки обновлений, т.к. размеры образов разделов становятся не только соизмеримыми с объемом оперативной памяти МУ, но и значительно их превышают. 
 
Разработчики стоковых (заводских) прошивок для уменьшения размера образов разделов в настоящее время применяют следующие способы: 
 
 
В основе первого способа лежит уменьшение размера образа за счет разделения его на несколько частей, называемых кусками ( ), при этом размер каждого куска не должен превышать заранее выбранную допустимую величину. Это позволяет уменьшить размер порции информации, передаваемой в МУ за один сеанс. 
 
При втором способе используется то свойство образа ФС, что он представляет собой разреженный файл [1]. Это позволяет применить кодирование без потери данных, что приводит к уменьшению размера всего образа раздела за счет сокращения объема «пустых» блоков, содержащих или нулевые, или повторяющиеся данные. 
 
Особенность третьего способа состоит в том, что после кодирования из образа удаляются все «пустые» блоки (при установке прошивки) или передаются только изменения образов (при выполнении обновлений). 
 
Думаю, что в качестве повышения квалификации разработчикам custom-прошивок будет интересно ознакомиться с внутренним строением образов такого типа и прояснить некоторые моменты работы с ними… 
 
 
Этот способ подразумевает, что исходный образ, имеющий ext4-формат, делится на части размером не более заранее заданной величины, называемой  . Чаще всего,   имеет значение 128 или 256 Мб. При этом, для обратного восстановления, дополнительно создается, так называемый, файл размещения, описывающий расположение этих частей в исходном образе. 
 
Процесс разрезания образа раздела на части может быть описан таким алгоритмом: 
 
 
После такого разбиения образа раздела и за счет отсечения нулевых данных происходит существенное уменьшение суммы длин кусков, т.е. общего размера выходного файла. 
 
Процесс восстановления очень прост и производится по следующему алгоритму: 
 
 
Для примера, давайте рассмотрим процесс восстановления исходного образа раздела, используя прошивку для МУ Lenovo s90 на основе процессора Qualcomm MSM8916 [2], которая содержит файл размещения rawprogram0.xml. А за «границу» части у Qualcomm принято значение 128 Мб. 
 
Файл размещения rawprogram0.xml представляет собой xml-файл, цитата из которого приведена ниже: 
 
 
Строго говоря, это файл описания разметки памяти МУ на основе чипов Qualcomm. Я не буду описывать все параметры этого файла, т.к. нам потребуются только следующие: 
 
 
Параметр   указывает имя файла, содержащего образ или его часть, метка которого представлена параметром  . 
 
Параметр   содержит АБСОЛЮТНОЕ смещение начала файла в памяти МУ. 
 
Т.к. мы не будем прошивать файлы частей в память, а только соберем из них цельный файл-образ раздела, то для размещения каждой части в этом файл-образе нужно использовать относительное смещение. За базу принимается начало образа конкретного раздела, т.е. смещение образа в памяти МУ. Расчет производится по следующей формуле: 
 
 
В теле прошивки имеется несколько файлов, содержащих ФС ext4: 
 
 
Давайте попробуем собрать образ раздела  , т.е. из частей cache_1.img — cache_4.img соберем один файл cache.img. Конкретно, для него выберем из файла размещения rawprogram0.xml, приведенного выше, следующие значения: 
 
 
Для восстановления необходимо выполнить следующее: 
 
 
Выполнив все действия, Вы получите файл  , размером 262МБ, содержащий образ раздела   в виде ФС типа ext4. 
 
 
Разрезание на части частично решает проблемы разработчиков, уменьшая размер одной части, передаваемой за сеанс передачи при прошивке или обновлении. Тем не менее, общий размер файла не изменяется. 
 
Проблему уменьшения размера образа можно решить путем его сжатия (кодирования). Для этого применяют следующие способы: 
 
 
 -файлы активно используются, например, в устройстве Moto G фирмы Lenovo, а  -файлы применяются в  . 
 
 
Для удаления «пустых» значений, число которых в образах разделов может достигать 90%, сами образы конвертируют (сжимают) в файлы типа  , структура которого описана в [3]. При этом исходный файл рассматривается как массив элементов, представляющих собой четырехбайтовые числа, и просмотр массива выполняется поблочно, т.е. по 4096 байт или по 1024 элемента. 
 
В зависимости от содержимого блоки разделяются на следующие типы: 
 
 
 
Разреженный образ раздела с ФС после конвертации в  -файл представляет собой последовательность (список) кусков типа   и  , расположенных вперемежку. Для идентификации и обеспечения обратного преобразования (восстановления образа) все это дополнено заголовком. 
 
Итак,  -файл состоит из: 
 
 
Несмотря на то, что при конвертации образа  -формата в   используется только два типа кусков, всего существует 4 типа кусков  -файлов, которые будут рассмотрены ниже. 
 
 
Заголовок имеет следующее строение: 
 
 
   Заголовок sparse-файла 
 
Кратко рассмотрим все поля заголовка. 
 
Поле   длиной 4 байта, содержит сигнатуру (число 0xed26ff3a) и служит для идентификации  -файла как типа файла. 
 
Поля  и   длиной по 2 байта, содержат номер версии формата  -файла. Сейчас это версия 1.0. 
 
Поле   длиной 2 байта, содержит размер заголовка  -файла в байтах. В настоящее время существует две версии заголовка, отличающихся только его размером: 0х1С (28) байт и 0х20 (32) байта. Соответственно и это поле содержит число или 0х1С, или 0х20. 
 
Поле   длиной 2 байта, содержит размер заголовка кусков  -файла. Независимо от типа кусков оно содержит число 0х0С (12). 
 
Поле   длиной 4 байта, содержит размер блока  -файла. Для сжатия в sparse-файл образов ФС типа ext2-ext4 значение этого поля равно 0х1000 (4096). 
 
Поле   длиной 4 байта, содержит размер исходного файла (img) в блоках. 
 
Поле   длиной 4 байта, содержит число частей, на которые был разделен исходный (входной) файл. Столько же кусков содержится и в выходном файле ( ). 
 
Поле   содержит контрольную сумму данных выходного файла (sparse), рассчитанную по алгоритму   для всего файла (заголовок + данные). 
 
 
Следом за заголовком располагается область данных, состоящая из списка кусков  -файла. 
 
Каждый кусок имеет заголовок куска и данные куска. 
 
Заголовок имеет длину 0х0С (12) байт, как указано в поле   заголовка  -файла и содержит следующие поля: 
 
 
   Структура заголовка куска 
 
Поле   длиной 2 байта, содержит идентификатор куска и может принимать следующие значения: 
 
 
Поле   длиной 2 байта, не используется и всегда равно нулю. 
 
Поле   длиной 4 байта, содержит размер исходного куска во входном файле (img), выраженный в блоках. 
 
Поле   длиной 4 байта, содержит размер полученного куска в выходном sparse-файле, выраженный в байтах. При рассчете учитывается как длина заголовка, так и длина данных куска. 
 
Следом за заголовком располагаются данные, различающиеся в зависимости от типа куска. 
 
Т.к. кусок типа   предназначен для хранения неповторяющихся данных, то данные куска полностью совпадают с данными соответствующей ему части входного файла. Имеет наибольший размер, т.к. количество данных может достигать значения выбранной  . 
 
Кусок типа   в качестве данных содержит только одно четырехбайтовое число (4-хбайтовый заполнитель), повторяющееся в соответствующей ему части входного файла. Он заменяет собой всю область, занятую этими повторяющимися данными без их перечисления, что и приводит к их сжатию. 
 
Кусок типа   в качестве данных содержит контрольную сумму куска, рассчитанную по алгоритму  . 
 
Исключением является кусок типа  , который вообще не содержит данных, но поле   все равно заполняется. Он представляет собой указатель (смещение) на начало следующего куска данных входного файла. 
 
 
При работе с sparse-файлами выполняются операции кодирования «сырого»( ) img-файла в  -файл и декодирование   -файла в исходный файл. 
 
Кодирование входного  -образа раздела  -формат производится по следующему алгоритму: 
 
 
Декодирование  -файла в исходный образ производится по следующему алгоритму: 
 
 
 
При работе с sparse-файлами чаще всего возникают два вопроса: 
 
 
Рассмотрим их согласно поступлению… 
 
 
Для примера рассмотрим процесс восстановления образа раздела   из  -файла МУ Moto Z от Lenovo [4]. Все действия выполняются при помощи hex-редактора, например, WinHex. 
 
Исходный файл oem.img, содержащий сжатый образ раздела  , имеет размер 69MБ. Посмотрим его заголовок: 
 
 
  Заголовок Moto Z 
  
С адреса 0х0000 расположена сигнатура файла, указывающая, что файл имеет тип sparse-файл и состоит из кусков. Сигнатура отмечена синим цветом. 
 
Далее зеленым цветом выделены поля, содержащие версию sparse-файла (1.0). 
 
Затем красным цветом выделены поля   и  , содержащие размер заголовка файла (0x001C) и размер заголовка куска (0x000C) соответственно. 
 
По смещению 0x000C расположено поле  , указывающее размер блока sparse-файла. Значение размера блока 0х00001000. 
 
По смещению 0x0010 расположено поле  , содержащее размер исходного файла в блоках. Оно выделено желтым цветом и имеет значение 0x0000С021. 
 
По смещению 0x0014 расположено поле  , содержащее число кусков, содержащихся в sparse-файле. Оно выделено фиолетовым цветом и имеет значение 0x0000001F. 
 
По смещению 0x0018 расположено поле  , содержащее контрольную сумму sparse-файла. Это поле содержит 0, что означает, что КС не рассчитывалась и не учитывается при загрузке этого файла в память МУ. 
 
Начиная с адреса 0x001C, расположен заголовок первого куска sparse-файла: 
 
 
  Заголовок куска CAC1 
  
Видно, что поле   содержит значение 0xCAC1, выделенное синим цветом. Следующих 2 байта пусты, а затем расположено поле  , отмеченное красным цветом, содержащее число блоков входного файла (0x00000001), закодированных в куске. 
 
Далее расположено поле  , содержащее длину куска вместе с заголовком, выраженную в байтах (0x0000100C). Оно выделено зеленым цветом. Нам всегда нужен размер без заголовка, поэтому длина только данных: 0х100С — 0х000С = 0х1000. 
 
Сразу за заголовком, начиная с адреса 0x0028 идет массив данных куска. 
 
Итак, для восстановления исходного образа выполним следующие действия: 
 
 
В результате получится файл, содержащий ФС типа ext4, размером 192МБ. 
 
 
Для простоты возьмем только что полученный образ   и попробуем его превратить в  -файл. При этом необходимо создать новый файл размера 0х001С (28) байт, поместить в него заголовок  -файла и далее последовательно просмотреть исходный файл, деля его на куски и кодируя их, размещать в новом файле все создаваемые  -куски. Ну и, конечно, сохранить новый файл под именем, например,  . 
 
Чтобы заполнить заголовок файла, вписываем в первые 4 байта сигнатуру  -файла: 
 
 
   Заголовок sparse-файла 
 
Далее последовательно записываем значения: 
 
 
Оставшиеся поля оставляем свободными, т.к. их значения появятся у нас только после окончательного создания выходного файла. 
 
Давайте теперь рассмотрим как кодировать, т.е. создавать, разные типы кусков. 
Любой тип куска имеет заголовок. Поэтому создадим его в первую очередь: создаем в hex-редакторе файл размером 12 байт: 
 
 
   Пустой заголовок куска 
 
Далее рассмотрим, как и что заполнять в кусках. 
 
 
В первые 2 байта заголовка запишем его тип (CAC1): 
 
 
   Тип куска CAC1 
 
Затем в поле  вставляем размер данных (0x00000001), выраженное в блоках: 
 
 
   Размер в блоках 
 
Ну и, наконец, размер куска в байтах (0x0000100C), т.е. длина заголовка + длина данных: 
 
 
   Размер куска САС1 
 
После заголовка вставляем данные, т.е. 0х1000 (4096) байт из исходного файла: 
 
 
   Данные куска САС1 
  
Перейдем к созданию следующего куска. 
 
 
В первые 2 байта заголовка запишем его тип (CAC2): 
 
 
   Тип куска CAC2 
  
Вставляем размер данных куска (0х001D), выраженное в блоках: 
 
 
   Размер в блоках САС2 
 
Вставляем размер куска в байтах (0х0010), т.е. длина заголовка + длина данных: 
 
 
   Размер куска САС2 
  
Добавляем данные куска. Для CAC2 это элемент-заполнитель (0xFFFFFFFF): 
 
 
   Данные куска САС2 
 
Перейдем к созданию следующего куска. 
 
 
В первые 2 байта заголовка запишем его тип (CAC3): 
 
 
   Тип куска CAC3 
  
Вставляем значение смещения до следующего куска (0ххххх), выраженное в блоках, по адресу 0х0004 заголовка. 
 
Вставляем размер куска в байтах (0х000С), т.е. просто длина заголовка, т.к. кусок этого типа данных не имеет, по адресу 0х0008 заголовка: 
 
 
   Размер куска САС3 
 
Перейдем к созданию следующего куска. 
 
 
 
В первые 2 байта заголовка запишем его тип (CAC4): 
 
 
   Тип куска CAC4 
  
Вставляем размер данных куска (0х001D), выраженное в блоках: 
 
 
   Размер в блоках САС4 
 
Вставляем размер куска в байтах (0х0010), т.е. длина заголовка + длина данных: 
 
 
   Размер куска САС4 
  
Добавляем данные куска. Для CAC4 это контрольная сумма куска, рассчитанная по алгоритму CRC32: 
 
 
   Данные куска САС4 
 
Собственно мы уже все разобрали по косточкам: создаем заголовок  -куска; и сразу за ним добавляем нужные ему данные. 
 
Теперь процесс кодирования исходного файла в  -файл выглядит следующим образом: 
 
 
 
 
