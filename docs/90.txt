Написание blockchain менее чем за 200 строк кода на Go
KosToZyB
Привет, Хабр! Представляю вашему вниманию перевод статьи "
".
Данный урок является хорошо адаптированным 
 про простое написание blockchain на Javascript. Мы портировали его на Go и добавили дополнительных фич, таких как просмотр цепочек в браузере.
Примеры в уроке будут основываться на данных сердцебиения. Мы ведь медицинская компания. Для интереса, вы можете подсчитать свой 
 (кол-во ударов в минуту) и учитывать это число во время учебного курса.
Почти каждый разработчик в мире слышал про blockchain, но большинство до сих пор не знают, как это работает. Многие слышали только про биткоин, 
. Данный пост является попыткой развеять слухи о blockchain, помогая Вам написать свой собственный blockchain на Go менее чем в 200 строк кода! В конце данного урока Вы сможете запустить и записать данные в blockchain локально, а так же просмотреть это в браузере.
Есть ли более хороший способ узнать о blockchain, чем создать свой собственный?
Что бы этот пост оставался простым, мы не будем рассматривать более совершенные концепции 
 и 
. Сетевое взаимодействие будет моделироваться, что бы Вы могли просматривать Ваш blockchain и просматривать добавленные блоки. Сетевая работа будет зарезервированная для будущих постов.
Поскольку мы собираемся писать код на Go, мы предполагаем, что у вас уже есть опыт разработки на нем. После 
 мы так же будем использовать следующие пакеты:
Spew позволяет нам красиво выводить структуры и слайсы в консоль.
Gorilla/mux это популярный пакет для написания обработчиков запросов.
 позволяет нам читать из файла 
 который лежит в корне каталога, поэтому нам не придется задавать в нашем коде такие параметры, как http порт.
Давайте создадим наш 
 файл в корне каталога, который будет определять порт на котором мы будем слушать HTTP запросы. Просто добавьте строку в файл:
Создайте файл 
. Вся реализация будет в этом файле и будет содержать менее 200 строк кода.
Импорты пакетов, вместе с объявлением пакета:
Давайте определим структуру каждого из наших блоков, которые представляют собой blockchain. Чуть ниже мы объясним для чего необходимы все эти поля:
Каждый блок содержит данные, которые будут записаны в blockchain и представляет собой событие каждого замера пульса.
Давайте объявим наш blockchain, который представляет собой просто слайс структур:
Итак, как хеширование используется в блоках и в blockchain? Мы используем хэши для определения и сохранения блоков в правильном порядке. Благодаря тому, что поле 
 в каждом блоке ссылается на поле 
 в предыдущем блоке (т.е. они равны), мы знаем правильный порядок блоков.
Зачем нам хэшировать? Мы получаем хэш по двум основным причинам:
Давайте напишем функцию, которая возьмет наши данные 
 и создаст для них хэш SHA256.
Функция 
 объединяет в одну строку 
, 
, 
, 
 из структуры 
, которая является аргументом функции и возвращается все в виде строкового представления хэша SHA256. Теперь мы можем сгенерировать новый блок со всеми необходимыми элементами с помощью новой функции 
. Для этого нам нужно будет передать предыдущий блок, что бы мы могли получить его хэш и индекс, а так же передадим новое значение частоты пульса 
.
Обратите внимание, что текущее время автоматически записывается в блок через 
. Так же обратите внимание, что была вызвана функция 
. В поле 
 скопировано значение хэша из предыдущего блока. 
 просто увеличивается на единицу от значения из предыдущего блока.
Теперь нам нужно написать функционал для проверки валидности предыдущих блоков. Мы делаем это проверяя 
, что бы убедиться, что они увеличиваются так, как это ожидается. Мы так же проверяем, что бы 
 действиетльно совпадал с 
 предыдущего блока. И наконец, мы повторно вычисляем хэш текущего блока, что бы убедиться в его корректности. Давайте напишем функцию 
, которая выполняет все эти действия и возвращает bool значение. Функция вернет 
, если все проверки пройдут верно:
Что, если мы столкнемся с проблемой, когда два узла нашей blockchain экосистемы добавили блоки в свои цепочки, и мы получили их оба. Какой из них мы выберем, как правильный источник? Мы выбираем наиболее длинную цепь. Это классическая проблема в blockchain.
Итак, давайте убедимся, что новая цепочка, которую мы принимаем, длиннее текущей цепи. Если это так, мы можем перезаписать нашу цепочку новой, у которой есть новый блок или блоки.
Мы просто сравним длину срезов цепей:
Если у Вас получилось, то можете похлопать себя по спине! Мы описали каркас функционала для нашего blockchain.
Теперь нам нужен удобный способ просмотра нашего blockchain и запись в него, в идеале в браузере, что бы мы могли похвастаться друзьям!
Мы предполагаем, что вы уже знакомы с тем, как работают веб-серверы, и у вас есть немного опыта работы на Go.
Используем пакет 
, который загрузили ранее. Создадим функцию 
 для запуска сервера и вызовем ее позже.
Обратите внимание, что порт конфигурируется из вашего 
-файла, который мы создали ранее. Вызовем метод 
 для вывода в консоль информации о запуске сервера. Мы настраиваем сервер и вызываем 
. Обычная практика в Go.
Теперь нам нужно написать функцию 
, которая будет определять наши обработчики. Для просмотра и записи нашего blockchain в браузере нам хватит двух простых роутов. Если мы отправляем 
 запрос на 
, то мы просматриваем нашу цепочку. Если отправляем 
 запрос, то мы можем записывать данные.
Обработчик 
 запроса:
Мы будем описывать blockchain в формате JSON, который можно будет просматривать в любом браузере по адресу 
. Вы можете задать порт в файле 
.
 запрос немножко сложнее и нам понадобится новая структура сообщений 
.
Код для обработчика записи в blockchain.
Причина, по которой мы использовали отдельную структуру сообщения, заключается в том, что тело 
 запроса приходит в формате 
 и мы будем использовать его для записи новых блоков. Это позволяет нам отправить 
 запрос следующего вида и наш обработчик заполнит оставшуюся часть блока за нас:
 — пример частоты пульса. Можете использовать своё значение пульса.
После декодирования тела запроса в структуру 
, мы создадим новый блок, передавая предыдущий бок и новое значение пульса в функцию 
, которую мы писали ранее. Проведем быструю проверку, что бы убедиться в правильности нового блока функцией 
.
Хочется получать уведомление, когда наши 
 запросы успешны или завершились с ошибкой. Мы используем небольшую обертку, для получения результата. Помните, что в Go никогда не игнорируются ошибки.
Давайте соединим все наработки в одной функции 
:
Что здесь происходит?
Весь код вы можете забрать с 

Давайте проверим наш код.

Запускаем в терминале наше приложение 

В терминале мы видим, что веб-сервер работает и мы получаем вывод нашего проинициализированного первого блока.
Теперь посетите 
. Как и ожидалось, мы видим первый блок.
Теперь давайте отправим 
 запросы для добавления блоков. Используя Postman, мы собираемся добавить несколько новых блоков с различными значениями 
.
Обновим нашу страничку в браузере. Теперь можно увидеть новые блоки в нашей цепочке. Новые блоки содержат 
 соответствуют 
 у старых блоков, как мы и ожидали!
Поздравляем! Вы только что создали свой blockchain с правильным хэшированием и блочной проверкой. Теперь Вы можете изучать более сложные проблемы blockchain, такие, как Proof of Work, Proof of Stake, Smart Contracts, Dapps, Side Chains и другие.
Данный урок не затрагивает такие темы, как новые блоки добавляются с помощью Proof of Work. Это будет отдельный урок, но существует множество blockchain и без механизмов Proof of Work. Сейчас все моделируется путем записи и просмотра данных blockchain на веб-сервере. В этом уроке нет составляющей P2P.
Если Вы хотите, что бы мы добавили механизм Proof of Work и работу по сети, вы можете сообщить об этом в 
 или подписаться на нас в 
! Это лучшие способы связаться с нами. Мы ждем новых отзывов и новых предложений по урокам. Мы рады услышать Вас!
Чтобы узнать больше о Coral Health и о том, как мы используем blockchain в исследовательской работе по медицине, можете посетить наш 
.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

