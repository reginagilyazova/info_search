Погружение в разработку на Ethereum. Часть 3: приложение для пользователя
rubyruby
В предыдущих статьях (
 и 
) мы описали как можно пользоваться децентрализованными приложениями на смарт-контрактах, если вы сами не против быть нодом. Но чем меньше пользователя заставляют совершать дополнительные действия — тем лучше. Для работы со смарт контрактами необходимо подписывать транзакции приватным ключом, поэтому совсем без дополнительный действий, к сожалению, не обойтись. В этой статье мы рассмотрим два подхода: первый — полноценное децентрализованное приложение (DApp) на javascript с использованием библиотеки Web3 и плагина MetaMask, второй — аналогичное приложение, но использующее Ruby on Rails API и гем Ethereum.rb для доступа к блокчейну.







Для демонстрации работы настоящего DApp рассмотрим приложение, вдохновленное 
. Вместо Democracy с голосованием и выполнением произвольных транзакций сделаем упрощенный контракт Charity, в котором кто угодно создает предложение по распределению денег (эфира), участники голосуют, и после истечения дедлайна предложение либо выполняется, либо нет, в зависимости от результата голосования.

Логика смарт контракта в данном случае не очень важна, наша цель — продемонстрировать варианты взаимодействия пользователя с блокчейном.

Рассмотрим какие средства мы будем использовать чуть подробнее а после перейдем непосредственно к приложению.







Это такой плагин для браузера Chrome, разработчики пишут, что планируют и для Firefox, но пока только хром. Скачать можно 
. Плагин делает две вещи:





Подробнее о том как пользоваться плагином можно прочитать на 
 или 



Web3.js — это JavaScript библиотека, та же, которую мы использовали в Geth в 
. MetaMask встраивает Web3.js в каждую открытую страницу, поэтому можно протестировать простые команды непосредственно в javascript консоли в Chrome Developer Tools. Важно отметить, на момент написания этой статьи, актуальная версия Web3.js — 0.20.1. Документация для версии 0.x.x доступна по 
, не путайте с документацией для версии 1.0 (
). 

Выполним две команды, одну на получение данных, например баланса аккаунта, вторую на изменение, например задание строки в смарт контракте StringHolder из 
. Предварительно не забудьте создать аккаунт в MetaMask, подключиться к нужной сети (в данном случае Ropsten Test Network) и зайти в консоль Developer Tools. 







Не забывайте при вызове методов контракта передавать коллбэк функцию в качестве последнего аргумента. Можно так:





Web3.js использует библиотеку 
 для числовых значений. В примере выше ответ выведен без преобразования.

Команды чтения выполняются сразу, а если вы захотите выполнить функцию, изменяющую данные в смарт контракте (не помеченную как 
), то MetaMask выдаст окно подписи транзакции. Продемонстрируем это, открыв контракт StringHolder из 
 и вызвав в нем метод задания строки:







После вызова метода setString выдается окно с запросом подтвердить транзакцию и информацией по предположительным затратам газа и эфира. Нажмите Submit. В консоли увидите хеш транзакции.





Через некоторое время проверим, что строка изменилась:





Все работает как должно.





Это библиотека для работы с блокчейном Ethereum из Ruby (
) — на данный момент поддерживается наиболее активно. 

Попробуем открыть контракт StringHolder из irb консоли:









Особенность вызова методов здесь в том, что через 
 вызываются только геттеры, где нужно просто получить данные. Для выполнения транзакций будет нужен 
 для синхронного вызова либо 
 для асинхронного вызова.

Попробуем вызвать функцию 
, для которой будет создаваться транзакция. Есть два способа: unlockAccount (deprecated) и sign transaction (об этом чуть позже).





Необходимо назначить от кого посылается транзакция (того же, кого мы сейчас разблокировали):





Потом можно вызывать сеттер вместо 
 подставив либо 
, либо 
:





Дожидаемся окончания, вызываем





Видим наши изменения — все работает.





Сформулируем задачу. У нас должен быть контракт, представляющий собой благотворительную организацию со счетом. В этой организации могут быть зарегистрированы пользователи, которые могут выступать и в качестве получателей пожертвований и в качестве голосующих за предложения. Нужен способ создать предложение о перечислении денег (эфира) со счета организации на один из зарегистрировавшихся аккаунтов. Чтобы не было искушения забрать за раз весь эфир введем ограничение — предложить можно не более 1 эфира. Далее идет голосование (можно голосовать “за” или “против”), которое нельзя завершать до определенного дедлайна (5 минут с момента создания предложения). После дедлайна голоса продолжают приниматься, но должна быть возможность завершить голосование, и если оно завершилось с бо?льшим количеством “за” чем “против” — перечислять эфир со счета организации на счет получателя. Если больше голосов “против” — ничего не делать. 

В целом схема приложения такая:





Два js модуля — Blockchain.js и BlockchainApi.js — отвечают за работу с блокчейном. Они делают одно и тоже, только первый работает c Web3.js и через ноду MetaMask напрямую обращается к блокчейну, второй — делает ajax запросы к Rails API, где уже происходит взаимодействие с блокчейном через гем ethereum.rb. Само клиентское приложение написано на React и не зависит от того, какой js модуль из двух используется.





Контракт в виде одного единственного файла, поэтому не будем пользоваться специальными средствами для деплоя, сделать это можно любым способом, хоть 
, хоть 
. Можете использовать наш код 
. В целом его схему можно изобразить так:







Рассмотрим код контракта Charity.sol по логическим блокам. Сначала идет описание всех нужных нам переменных:





Маппинг позволяет по адресу пользователя получить его индекс в массиве. Если пользователя с таким адресом не существует, то будет возвращен индекс 0. На этом будет основана далее функция, определяющая, зарегистрирован ли пользователь с данным адресом. Но это вносит требование для массива: пользователи должны храниться в массиве начиная с индекса 1. Код, отвечающий за эту логику будет рассмотрен дальше. А пока идет структура для хранения предложения.





Структура голосов, складывается в массив для каждого предложения





Рассмотрим модификатор, который позволит нам контролировать, что выполнение методов, к которым он будет добавлен, возможно только если пользователь зарегистрирован. Код проверки, как уже было сказано, основан на том, что несуществующие элементы маппинга дают индекс 
, а пользователей будем хранить начиная с индекса 
:






 — это структура, по которой можно получить информацию о вызывающем. В данном случае 
 — это адрес аккаунта, который вызвал метод с этим модификатором. 



Опишем конструктор нашего контракта, который будет выполняться при деплое. Все, что требуется задавать — время, которое выделяется для голосования за каждое предложение. Кроме этого увеличиваем размер массива members, потому что добавлять пользователей будем исходя из размера, а нулевой элемент остается зарезервированным.





Функция для добавления пользователя: 





Заметьте функцию 
 — она пришла на замену 
 в более старых версиях solidity. В 
 передается 
 или 
, если это 
 — то срабатывает обработчик аналогичный 
 — откатывается вся транзакция. 

Чтобы можно было проверить, находится ли адрес в списке пользователей используем такую функцию:





Следующая функция — для создания предложения, принимает адрес получателя пожертвования, количество эфира в wei и строку с описанием. К этой функции применяется модификатор onlyMembers, это значит до выполнения всего кода произойдет проверка, что вызывающий аккаунт зарегистрирован. Здесь вы увидите такие преобразования как 
 и 
. Полный список таких суффиксов можете посмотреть 
, они сделаны для удобства и могут применяться только к значениям, но не к переменным. Но чтобы применить к переменной достаточно просто добавить 1 к суффиксу, что и сделано в нашем случае для преобразования в секунды.





Заметьте здесь ключевое слово 
 — это текущее время, но не на момент вызова транзакции, а на момент создания блока. Поэтому дедлайн будет отсчитываться с момента, когда предложение уже будет создано на блокчейне.



Несмотря на то, что 
 у нас 
, получать таким образом можно только простейшие поля в виде массива. То есть вызвав в контракте метод например 
, мы получим предложение с индексом 
 в виде массива 
, а массивы 
 и 
 внутри структуры не вернутся. Но нам нужна информация о том, проголосовал ли пользователь за определенное предложение, чтобы отображать его голос или дать возможность проголосовать. И желательно сделать это в одно обращение, поэтому мы получаем эту информацию когда читаем структуру Proposal для отображения в нашем приложении с помощью специальной функции 
, которая принимает аккаунт, для которого нужен статус голоса и идентификатор предложения.





А это вспомогательная функция, которая ищет как проголосовал конкретный пользователь в конкретном предложении. Возвращаться будет: 
 — если пользователь не проголосовал, 
 — если пользователь проголосовал “за”, 
 — если проголосовал “против”.





Голосование: для предложения с конкретным номером отдаем голос true (за) или false (против).





И последняя функция 
 служит для завершения голосования и отправки (или неотправки) эфира на адрес получателя.





В конце присутствует пустая функция с модификатором payable.





Это нужно для того, чтобы на адрес контракта можно было присылать эфир. Вообще пустая функция — это функция, которая принимает и обрабатывает все сообщения, которые не являются вызовом функций. Все, что нам требуется — это сделать ее payable, тогда отправленный газ просто зачислится на контракт без каких-либо дополнительных действий. Но заметьте, что на других функциях этого модификатора нет, поэтому в нашем случае нельзя отправлять эфир например с вызовом 
.





Основной сценарий приложения:





Демонстрация приложения доступна по 
 — MetaMask версия.

Исходный код 
. 



Еще раз обращаем ваше внимание на то, что текущая версия Web3.js — 0.20.1. Но уже готовится к релизу версия 1.0, в которой изменения достаточно существенны. Как мы говорили выше, MetaMask встраивает web3 в страницу, и его можно сразу использовать. Но учитывая то, что библиотека активно развивается, а нам нужно гарантировать работоспособность приложения для пользователя, необходимо использовать свою залоченную версию, и переопределять объект web3, который встраивает MetaMask. Мы делаем это 
 в следующем методе:





Делать это нужно после события 
.

Одна неочевидная проблема, которая решается в этом коде — если просто сделать 
 как предлагается в официальной документации, то не подхватывается аккаунт по умолчанию. 

Еще в MetaMask, как уже писалось, можно выбирать сеть из списка. У нас используются адреса контрактов в сети Ropsten, если попытаться подключаться по этим адресам в других сетях — результат будет непредсказуем. Поэтому прежде чем предоставлять доступ к приложению, нужно проверить в той ли сети находится пользователь. Получить идентификатор сети можно с помощью команды:





Мы делаем эту проверку 
 и сравниваем результат с id для сети Ropsten — это 3.

 

Список id всех сетей можно увидеть например 
 в описании net_version. 



Вся логика работы с блокчейном находится в файле 
.



Здесь есть два типа функций — функции для получения данных из блокчейна и функции изменяющие данные в блокчейне. Большинство методов из web3.js выполняются асинхронно и принимают callback в качестве последнего параметра. Поскольку зачастую приходится вызывать несколько методов для получения данных, и вызов некоторых из них зависит от результата работы других — удобно использовать промисы. В версии 1.0 web3.js асинхронные методы возвращают промисы по умолчанию.



Приведем один пример получения информации из блокчейна:

Функция 
 возвращает адрес текущего аккаунта, баланс и флаг того, является ли данный аккаунт участником организации.





Рассмотрим теперь функцию изменения данных в блокчейне, например функция добавления участника организации.





Как видим, синтаксис ничем не отличается от предыдущего примера, вот только выполнение этой функции повлечет создание транзакции, для изменения данных в блокчейне.

При вызове любой функции смарт контракта, в результате которой создается транзакция, MetaMask предлагает пользователю подтвердить эту транзакцию или отклонить ее. Если пользователь подтверждает транзакцию, то функция возвращает хеш транзакции.

Один неочевидный момент — это как узнать выполнилась транзакция успешно или нет.

Определить статус транзакции можно на основании кол-ва газа, которое было использовано. Если использовано максимально доступное кол-во газа, то либо в ходе выполнения возникла ошибка, либо газа не хватило для выполнения транзакции. Проверку статуса мы делаем следующим образом.







При создании новой транзакции, мы добавляем ее в localStorage и периодически опрашиваем ее статус, до тех пор пока не узнаем что она выполнилась успешно или нет. Логика мониторинга транзакций находится в файле —  
.





По-настоящему децентрализованное приложение выглядит как вариант, описанный выше. Пользователь сам подписывает транзакции при помощи ключа, который хранится у него же. Но помимо случаев, когда пользователь приложения непосредственно взаимодействует с блокчейном, бывают случаи, когда требуется доступ к блокчейну на стороне бекенда. Возможно это какое-то внутреннее приложение и действия с блокчейном выполняются от аккаунтов, которые вы контролируете и ключи для которых вы можете хранить на сервере. Возможно логика вашего приложения на смарт контрактах подразумевает реагирование на определенные события от вашего централизованного сервера. В данном случае, помимо web3.js, который вы конечно тоже можете использовать на сервере, было бы неплохо иметь инструмент для привычного вам стека разработки. Для нас таким является Ruby on Rails, поэтому мы решили попробовать библиотеку ethereum.rb, которая должна решать туже задачу, что и web3.js.



Демонстрация приложения доступна по 
 — Rails API версия.

Исходный код 
. 



Для демонстрации работы с ethereum.rb, мы сделали аналогичный набор функций, описанным в blockchain.js. Код работы с блокчейном можно посмотреть 
, а мы опишем основные моменты и, возможно, отличия. 



Первое — теперь у нас нет доступа к аккаунту пользователя, поэтому нам нужно сделать некоторый процесс авторизации и создавать для каждого пользователя аккаунт в блокчейне. Процесс авторизации в данном примере максимально упрощен, мы просто генерируем токен, который сохраняется в LocalStorage браузера, и по которому происходит авторизация запросов к API.



В целом схема работы с аккаунтами такая: 





Как и в js версии, есть два типа методов — те что берут данные из блокчейна, и те что изменяют их. Первые — достаточно простые и как они работают понятно из примера.





Методы, которые изменяют данные в блокчейне — создают транзакцию, которую нужно подписать приватным ключом. Для работы с приватными ключами используется 
. Ниже демонстрируется процесс создания нового аккаунта для блокчейна и подпись транзакции приватным ключом.





Рассмотрим метод 
 — он принимает приватный ключ и блок кода, который мы хотим выполнить используя данный ключ.

В базе данных ключ хранится в бинарном виде, из которого создается объект ключа при помощи гема Eth. Далее этот ключ присваивается в поле 
 экземпляра контракта. Подпись транзакций происходит автоматически в геме ethereum.rb если в поле 
 контракта задан ключ. После вызова нужного метода, или нескольких методов, обнуляем ключ, чтобы случайно не отправить еще транзакций от этого же аккаунта.



Для примера использования 
 рассмотрим метод завершения Proposal, который вызывает метод 
 в смарт контракте:





Метод возвращает хеш транзакции. Логика проверки статуса транзакции аналогична той, что мы использовали в js версии.









Демонстрация приложения доступна по 
.

Мы перечислили на счет контракта некоторое кол-во эфира, если он закончится и у вас есть лишний тестовый эфир — можете задонатить сюда 
 — сеть Ropsten.





На наш взгляд оба варианта имеют право на жизнь, но в различных случаях. В данном конкретном примере версия с Ruby немного притянута за уши и версия использующая MetaMask более логична. Но, как уже было упомянуто в начале, задачей было не дать образец проекта, а показать на простой логике примеры взаимодействия с блокчейном при помощи javascript и ruby. Надеемся с этой задачей мы справились.

Следующей задачей ставим себе описание более продвинутой работы с деплоем и тестированием смарт контрактов. Ожидайте следующую статью на эту тему!



Погружение в разработку на Ethereum:



