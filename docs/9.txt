Применение паттерна observer в Redux и Mobx
bgnx
Паттерн "observer" известен наверное с момента появления самого ооп. Упрощенно можно представить что есть объект который хранит список слушателей и имеет метод "добавить", "удалить" и "оповестить", а внешний код либо подписывается либо оповещает подписчиков
В redux-е этот паттерн применяется без всяких изменений ?— пакет "react-redux" предоставляет функцию 
 которая оборачивает компонент и при вызове componentDidMount вызовет 
 метод у 
, при вызове 
? вызовет ?
 а 
 просто вызовет метод 
 который в цикле вызовет всех слушателей где каждый в свою очередь вызовет 
 и потом в зависимости от того изменилось ли значение ?— ?вызовет 
 на самом компоненте. Все очень просто, но платой за простоту является необходимость явно указывать от каких частей стора зависит компонент внутри 
.
Mobx очень похож на redux тем что использует этот паттерн observer только развивает его еще дальше ?— ?что если мы не будем писать 
 а сделаем так чтобы компоненты зависели от данных которые они "рендерят" самостоятельно?, по отдельности. Вместо того чтобы собирать подписчиков на одном объекте состояния всего приложения, подписчики будут подписываться на каждое отдельное поле в состоянии. Это как если бы для юзера, у которого есть поля 
 и 
 мы создали бы целый redux-стор отдельно для 
 и отдельно для 
. 
Таким образом, если мы найдем легкий способ создавать такие "сторы" и подписываться на них, то 
 будет не нужен, потому что эта зависимость от разных частей состояния уже выражается в существовании разных сторов. 
Итак на каждое поле у нас будет по отдельному "мини-стору" ?— ?объекту observer где кроме 
, 
 и 
 добавится еще поле 
 а также методы 
 и 
 и при вызове 
 подписчики вызовутся только если само значение изменилось.
Вместе с этим требование иммутабельности стора нужно трактовать немного по-другому? —? если мы в каждом отдельном сторе будем хранить только примитивные значение, то с точки зрения redux нет ничего зазорного в том чтобы вызвать 
 ?— ?поскольку строка это иммутабельное значение? — ?то здесь происходит просто установка нового состояния стора, точно так же как и в redux. В случаях когда нам нужно сохранить в "мини-сторе" объект или сложные структуры то можно просто вынести их в отдельные "мини-сторы". Например вместо этого
лучше написать так чтобы компоненты могли по отдельности зависеть то от 
 то от 
 и чтобы не было лишних "перерендеров"
Второй момент? — ?можно заметить что с таким подходом мы будем вынуждены на каждый доступ к свойству вызывать метод 
, что добавляет неудобств.
Но эта проблема решается через геттеры и сеттеры javascript-а
А если вы не относитесь негативно к декораторам то этот пример можно еще больше упростить
В общем можно пока подвести итоги и сказать что 1) никакой магии в этом моменте нет? —?декораторы это всего лишь геттеры и сеттеры 2) геттеры и сеттеры всего лишь считывают и устанавливают root-state в "мини-сторе" а-ля redux
Идем дальше — для того чтобы подключить все это к реакту нужно будет в компоненте подписаться на поля которые в нем выводятся и потом отписаться в 
Да, при росте полей которые выводятся в компоненте, количество болерплейта будет возрастать многократно но одним небольшим движением ручную подписку можно убрать полностью если добавить несколько строчек кода? —? поскольку в шаблонах так или иначе будет вызываться метод 
 чтобы отрендерить значение то мы можем воспользоваться этим чтобы сделать автоматическую подписку? —? если перед вызовом метода 
 компонента мы запишем в глобальной переменной текущий массив то в методе 
 мы просто добавим 
 в этот массив и потом в к конце вызова метода 
 мы получим массив всех “мини-сторов” на которые подписан текущий компонент. Этот простой механизм решает даже ситуации когда сторы на которые подписан компонент динамически меняются во время рендера? —? например когда компонент рендерит 
 ( если длина имени меньше 5 компонент не будет реагировать (то есть не будет подписан) на изменение фамилии а подписка автоматически произойдет когда длина имени будет больше-равно 5)
Здесь функция 
 оборачивает компонент или stateless-component (функцию) реакта и возвращает компонент который благодаря это механизму автоподписки подписывается на нужные "мини-сторы".
В итоге у нас получился такой вот механизм автоподписок только на нужные данные и оповещения когда только эти данные изменились. Компонент будет обновляться только тогда когда изменились только те "мини-сторы" на которые он подписан. Учитывая что в реальном приложении где может быть тысячи этих "мини-сторов" с данным механизмом множественных сторов при изменении одного поля обновятся только те компоненты которые находятся в массиве подписчиков на это поле, а вот подходом redux когда мы подписываем все эти тысячи компонентов на один единственный стор, при каждом изменении нужно оповещать в цикле все эти тысячи компонентов (и при этом заставляя программиста вручную описывать от каких частей состояния зависят компоненты внутри 
)
Более того этот механизм автоподписок способен улучшить не только redux а и такой паттерн как мемоизацию функций, и заменить библиотеку reselect ?— ?вместо того чтобы явно указывать в createSelector() от каких данных зависит наша функция, зависимости будут определяться автоматически точно так же выше сделано с функцией render()
Mobx это логичное развитие паттерна observer для решения проблемы "точечных" обновлений компонентов и мемоизации функций. Если немного отрефакторить и вынести код в примере выше из компонента в 
 и вместо вызова 
 и 
 поставить геттеры и сеттеры, то мы почти что получим 
 и 
 декораторы mobx-а. Почти — потому что у mobx вместо простого вызова в цикле находится более сложный алгоритм вызова подписчиков для того чтобы исключить лишние вызовы 
 для ромбовидных зависимостей, но об этом в следующей статье.