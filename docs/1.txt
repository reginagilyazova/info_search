Простой Stack Fragment'ов
morkovkin
Доброе время суток, уважаемые читатели Хабра! Хочу представить вашему вниманию статью, основанную на моем опыте работы в Single Activity Architecture, в частности со стеком пользовательских представлений. 
 
При первом знакомстве с Single Activity Architecture у меня возникало много вопросов: “Как можно управлять моментом добавления и удаления фрагментов?”, “Как фрагменту удерживать нажатие кнопки назад?”, “Возможно ли запускать фрагмент на результат?”, ”Как понять когда пользователь вернулся на фрагмент?” и тд. 
 
Первый вопрос является почти тривиальным. Можно создать единый класс навигации, в который передавать менеджер фрагментов и использовать по функции перехода на экран. 
 
Второй вопрос тоже частично решается оповещением класса навигации о том, что произошло нажатие на кнопку назад. Но в этом случае навигатор начинает являться чем-то большим, чем просто хранителем путей, в нем появляется логика, которая, на мой взгляд, абсолютно не оправдана. Но кто-то в системе должен обрабатывать движения вперед и назад? 
 
С возвращением пользователя на фрагмент тоже есть некоторые сложности. Одним из самых критичных, на мой взгляд, это повторный вызов onCreateView. Как мы все знаем, там появляется пользовательское представление в виде View. Думаю также, ни для кого не секрет, что эта операция является довольно прожорливой. 
 
По итогу получается класс с большим количеством логики переходов, созданием фрагментов различного рода, сомнительными вставками “очень полезной функциональности” в методы обработки перехода назад (если пользователь добавил что-то на предыдущем экране нужно, это добавить в список). По моему мнению, это не совсем то, что требуется от класса, который отвечает за навигацию внутри приложения. Разумное решение — это делегировать часть функционала другим частям системы. Таким образом, в моей программе появилась сущность стека фрагментов. 
 
Требования к стеку фрагментов почти тривиальны: добавить фрагмент, перейти назад, перейти до, — за исключением некоторых нюансов. Для меня, как для проектировщика, основной проблемой стал жизненный цикл добавляемых / удаляемых фрагментов.Также некой проблемой было завершение фрагмента с результатом и отправки результата его потребителю. Благо решение нашлось довольно быстро. Внутренней логической структурой я выбрал немного усовершенствованный стек: слоеный пирог. Идея заключается в том, что слои укладываются на корж. Коржом нашего абстрактного пирога можно считать точку входа в приложение (главный фрагмент, домашняя страница и т.д.). Слои же в свою очередь имеют следующие свойства: 
 
 
Если отойти от сладкого примера, то добавление — это транзакция, состоящая из скрытия предыдущего фрагмента и добавления нового. Также в эту операцию я добавил оповещение скрываемого фрагмента о том, что пользователь с него ушел, и ограничение на размер стека. Операция удаления является более витиеватой, поэтому обо всем более подробно. 
 
Логику, которая отвечает за отправку результата из фрагмента поставщика к фрагменту, разумно вынести в отдельный класс. Например, воображаемый экран добавления записи в ежедневник пользователя мог бы возвращать добавленную запись для последующей ее обработки вызываемому блоку программы. Это некий аналог onActivityResult.  
 
Если представить все вышесказанное на схеме, то она будет выглядеть следующим образом 
 
 
 
Для обеспечения результативности я создал отдельный класс ResultUtils и интерфейс ResultableFragment.  
 
Потребителем может являться любой фрагмент, который расширяет интерфейс ResultableFragment. Данный интерфейс состоит из одной функции void onFragmentResult(final int requestCode, final int resultCode, final Bundle data). Данная функция является аналогом onActivityResult. 
 
 
Реализация класса   представляет из себя набор следующих методов: 
 
 
 
Также мне потребовался интерфейс, который объединяет все фрагменты, подчиняющиеся новому жизненному циклу. Данный интерфейс я назвал LifeBoundFragment. Туда включены следующие методы: 
 
 
 
 
Прорабатывая внешний интерфейс стека, я выделил следующие основные функции: 
 
 
Сам стек я организовал на структуре LinkedList. Наиболее интересными, с моей точки зрения, являются методы: push(final T target, final int requestCode), pop() и popToTarget(Class target).  
 
 
Как упоминалось ранее, данный метод добавляет новый фрагмент на экран, скрывает предыдущий и добавляет в новый ключи. Для того чтобы скрыть внутреннюю реализацию, я создал приватный метод  , который отвечал за всю логику добавления и удаления фрагмента. Метод pushFragment возвращает Pair<Fragment, Fragment>. Это по сути направление движения, где ключ это фрагмент с которого пользователь переходит, а значение куда. По задумке при добавлении фрагмента мы должны оповестить фрагмент, который скрывается, о том, что пользователь с него уходит. Для этого достаточно убедиться, что скрываемый фрагмент расширяет интерфейс  , и отправить событие  .  
 
Также в этом методе стоит добавить обязательства через класс утилит ResultUtils, используя метод addPromise. 
 
 
Наиболее интересным тут является метод pushFragment: 
 
 
В данном методе происходит вся основная манипуляция со стеком, скрытие предыдущего фрагмента и ограничение на кол-во элементов стека.  
 
 
Метод pop() также является неким собирательным методом.  
Особенностью этого метода является вызов sendResultIfPossible класса ResultUtils. 
 
 
Основная логика метода popFragment вполне предсказуема. Так что особо на ней задерживаться смысла я не вижу. 
 
 
 
Данный метод, по моему мнению, является самым интересным. Он сочетает в себе практически все.  
 
Когда я начал разрабатывать функционал класса ResultUtils, одним моим внутренним ограничением было то, что результат при переходе назад передается по цепочке. Исходя из этого ограничения, метод onFragmentResult будет вызываться по цепочке до тех пор, пока не наткнется на корневой вызов. Фрагменты, находящиеся посередине цепочками, я начал называть транзитными. Действительно, они получают вызов onFragmentResult, в котором могут установить результат для следующего фрагмента цепи. 
 
 
 
По моему мнению получилась гибкая, простая и надежная система управления фрагментами. В данный момент мне удалось успешно применить этот подход в ряде проектов, в которых я участвовал. Из минусов с которыми я столкнулся при использовании этого подхода это leanback (Android TV), но отчасти сама система не располагает к Single Activity Architecture. Далее я планирую придумать механизм хранения/восстановления истории, запуск приложения с заданной историей (будет полезно при push нотификации). Спасибо за внимание!
