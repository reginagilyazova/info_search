Исследуем сопоставление с образцом в C 7 JosefDzeranov В C 7 наконец появилась долгожданная возможность под названием сопоставление с образцом Если вы знакомы с функциональными языками такими как F вы можете быть немного разочарованы этой возможностью в ее текущем виде но даже сегодня она может упростить ваш код в самых разных сценариях Каждая новая возможность чревата опасностью для разработчика работающего в критическом для производительности приложении Новые уровни абстракций хороши но для того чтобы эффективно использовать их вы должны знать что происходит под капотом Сегодня мы собираемся изучить внутренности сопоставления с образцом чтобы понять как это реализовано Язык C ввел понятие образца которое может использоваться в is выражении и внутри блока оператора Существует 3 типа шаблонов is выражение может проверить равно ли значение константе а проверка типа может дополнительно создавать переменную образца Я нашел несколько интересных аспектов связанных с сопоставлением с образцом в is выражениях Сначала проверим первые два случая Первый оператор вводит переменную и переменная видна внутри всего метода Это разумно но усложнит логику если другие if операторы в том же блоке будут пытаться повторно использовать одно и то же имя еще раз В этом случае вам использовать другое имя чтобы избежать коллизий Переменная введенная в is выражении полностью определена только тогда когда предикат является Это означает что переменная во втором операторе не определена в правом операнде но поскольку эта переменная уже объявлена мы можем использовать ее как переменную в методе Третий аспект упомянутый выше является наиболее важным Рассмотрим следующий код В большинстве случаев is выражение преобразуется в даже если спецификация говорит что должен использоваться для примитивных типов Этот код вызывает 2 упаковки boxing которые могут весьма серьезно повлиять на производительность если они используются в критическом пути приложения Когда то выражение так же вызывало упаковку см и я надеюсь что текущее поведение так же будет исправлено в скором времени вот соответствующий на гитхабе Если переменная имеет тип то приведет к одному выделению памяти для упаковки литерала хотя подобный код на основе switch не приводит к выделениям памяти Образец является частным случаем образца типа с одним ключевым отличием образец будет соответствовать любому значению даже если значение равно когда не но всегда Компилятор знает об этом и в режиме Release полностью удаляет конструкцию if и просто оставляет вызов консольного метода К сожалению компилятор не предупреждает что код недостижим в следующем случае Надеюсь это тоже будет исправлено Непонятно почему поведение отличается только в режиме Release Но я думаю что все проблемы имеют одну природу первоначальная реализация фичи неоптимальна Но на основе Нила Gafter это изменится Плохой код соответствующий сопоставлению с образцом переписывается с нуля для поддержки рекурсивных шаблонов тоже Я ожидаю что большинство улучшений которые вы ищете здесь будут бесплатными в новом коде Отсутствие проверки на делает этот случай очень особенным и потенциально опасным Но если вы знаете что именно происходит вы можете найти этот вариант сопоставления полезным Его можно использовать для введения временной переменной внутри выражения Есть другой случай который я нашел очень полезным Образец типа соответствует значению только если значение не равно Мы можем использовать эту фильтрующую логику с оператором чтобы сделать код более читабельным Обратите внимание что один и тот же шаблон может использоваться как для типов значений так и для ссылочных типов C 7 расширяет оператор для использования образцов в блоках В примере показан первый набор изменений в операторе switch В последнем блоке показана еще одна возможность добавленная в C 7 называемая шаблоном Имя является специальным и сообщает компилятору что переменная не нужна Шаблон типа в предложении требует имени переменной и если вы не собираетесь ее использовать то вы можете ее проигнорировать с помощью Следующий фрагмент показывает еще одну особенность сопоставления с образцом на основе возможность использования предикатов может иметь более одного блока с одним и тем же типом В этом случае компилятор объединяет все проверки типов в один блок чтобы избежать избыточных вычислений Но нужно иметь в виду две вещи
