Написание blockchain менее чем за 200 строк кода на Go KosToZyB Привет Хабр Представляю вашему вниманию перевод статьи Данный урок является хорошо адаптированным про простое написание blockchain на Javascript Мы портировали его на Go и добавили дополнительных фич таких как просмотр цепочек в браузере Примеры в уроке будут основываться на данных сердцебиения Мы ведь медицинская компания Для интереса вы можете подсчитать свой кол во ударов в минуту и учитывать это число во время учебного курса Почти каждый разработчик в мире слышал про blockchain но большинство до сих пор не знают как это работает Многие слышали только про биткоин Данный пост является попыткой развеять слухи о blockchain помогая Вам написать свой собственный blockchain на Go менее чем в 200 строк кода В конце данного урока Вы сможете запустить и записать данные в blockchain локально а так же просмотреть это в браузере Есть ли более хороший способ узнать о blockchain чем создать свой собственный Что бы этот пост оставался простым мы не будем рассматривать более совершенные концепции и Сетевое взаимодействие будет моделироваться что бы Вы могли просматривать Ваш blockchain и просматривать добавленные блоки Сетевая работа будет зарезервированная для будущих постов Поскольку мы собираемся писать код на Go мы предполагаем что у вас уже есть опыт разработки на нем После мы так же будем использовать следующие пакеты Spew позволяет нам красиво выводить структуры и слайсы в консоль Gorilla mux это популярный пакет для написания обработчиков запросов позволяет нам читать из файла который лежит в корне каталога поэтому нам не придется задавать в нашем коде такие параметры как http порт Давайте создадим наш файл в корне каталога который будет определять порт на котором мы будем слушать HTTP запросы Просто добавьте строку в файл Создайте файл Вся реализация будет в этом файле и будет содержать менее 200 строк кода Импорты пакетов вместе с объявлением пакета Давайте определим структуру каждого из наших блоков которые представляют собой blockchain Чуть ниже мы объясним для чего необходимы все эти поля Каждый блок содержит данные которые будут записаны в blockchain и представляет собой событие каждого замера пульса Давайте объявим наш blockchain который представляет собой просто слайс структур Итак как хеширование используется в блоках и в blockchain Мы используем хэши для определения и сохранения блоков в правильном порядке Благодаря тому что поле в каждом блоке ссылается на поле в предыдущем блоке т е они равны мы знаем правильный порядок блоков Зачем нам хэшировать Мы получаем хэш по двум основным причинам Давайте напишем функцию которая возьмет наши данные и создаст для них хэш SHA256 Функция объединяет в одну строку из структуры которая является аргументом функции и возвращается все в виде строкового представления хэша SHA256 Теперь мы можем сгенерировать новый блок со всеми необходимыми элементами с помощью новой функции Для этого нам нужно будет передать предыдущий блок что бы мы могли получить его хэш и индекс а так же передадим новое значение частоты пульса Обратите внимание что текущее время автоматически записывается в блок через Так же обратите внимание что была вызвана функция В поле скопировано значение хэша из предыдущего блока просто увеличивается на единицу от значения из предыдущего блока Теперь нам нужно написать функционал для проверки валидности предыдущих блоков Мы делаем это проверяя что бы убедиться что они увеличиваются так как это ожидается Мы так же проверяем что бы действиетльно совпадал с предыдущего блока И наконец мы повторно вычисляем хэш текущего блока что бы убедиться в его корректности Давайте напишем функцию которая выполняет все эти действия и возвращает bool значение Функция вернет если все проверки пройдут верно Что если мы столкнемся с проблемой когда два узла нашей blockchain экосистемы добавили блоки в свои цепочки и мы получили их оба Какой из них мы выберем как правильный источник Мы выбираем наиболее длинную цепь Это классическая проблема в blockchain Итак давайте убедимся что новая цепочка которую мы принимаем длиннее текущей цепи Если это так мы можем перезаписать нашу цепочку новой у которой есть новый блок или блоки Мы просто сравним длину срезов цепей Если у Вас получилось то можете похлопать себя по спине Мы описали каркас функционала для нашего blockchain Теперь нам нужен удобный способ просмотра нашего blockchain и запись в него в идеале в браузере что бы мы могли похвастаться друзьям Мы предполагаем что вы уже знакомы с тем как работают веб серверы и у вас есть немного опыта работы на Go Используем пакет который загрузили ранее Создадим функцию для запуска сервера и вызовем ее позже Обратите внимание что порт конфигурируется из вашего файла который мы создали ранее Вызовем метод для вывода в консоль информации о запуске сервера Мы настраиваем сервер и вызываем Обычная практика в Go Теперь нам нужно написать функцию которая будет определять наши обработчики Для просмотра и записи нашего blockchain в браузере нам хватит двух простых роутов Если мы отправляем запрос на то мы просматриваем нашу цепочку Если отправляем запрос то мы можем записывать данные Обработчик запроса Мы будем описывать blockchain в формате JSON который можно будет просматривать в любом браузере по адресу Вы можете задать порт в файле запрос немножко сложнее и нам понадобится новая структура сообщений Код для обработчика записи в blockchain Причина по которой мы использовали отдельную структуру сообщения заключается в том что тело запроса приходит в формате и мы будем использовать его для записи новых блоков Это позволяет нам отправить запрос следующего вида и наш обработчик заполнит оставшуюся часть блока за нас пример частоты пульса Можете использовать сво значение пульса После декодирования тела запроса в структуру мы создадим новый блок передавая предыдущий бок и новое значение пульса в функцию которую мы писали ранее Проведем быструю проверку что бы убедиться в правильности нового блока функцией Хочется получать уведомление когда наши запросы успешны или завершились с ошибкой Мы используем небольшую обертку для получения результата Помните что в Go никогда не игнорируются ошибки Давайте соединим все наработки в одной функции Что здесь происходит Весь код вы можете забрать с Давайте проверим наш код Запускаем в терминале наше приложение В терминале мы видим что веб сервер работает и мы получаем вывод нашего проинициализированного первого блока Теперь посетите Как и ожидалось мы видим первый блок Теперь давайте отправим запросы для добавления блоков Используя Postman мы собираемся добавить несколько новых блоков с различными значениями Обновим нашу страничку в браузере Теперь можно увидеть новые блоки в нашей цепочке Новые блоки содержат соответствуют у старых блоков как мы и ожидали Поздравляем Вы только что создали свой blockchain с правильным хэшированием и блочной проверкой Теперь Вы можете изучать более сложные проблемы blockchain такие как Proof of Work Proof of Stake Smart Contracts Dapps Side Chains и другие Данный урок не затрагивает такие темы как новые блоки добавляются с помощью Proof of Work Это будет отдельный урок но существует множество blockchain и без механизмов Proof of Work Сейчас все моделируется путем записи и просмотра данных blockchain на веб сервере В этом уроке нет составляющей P2P Если Вы хотите что бы мы добавили механизм Proof of Work и работу по сети вы можете сообщить об этом в или подписаться на нас в Это лучшие способы связаться с нами Мы ждем новых отзывов и новых предложений по урокам Мы рады услышать Вас Чтобы узнать больше о Coral Health и о том как мы используем blockchain в исследовательской работе по медицине можете посетить наш
