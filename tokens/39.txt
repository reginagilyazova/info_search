Предсказание случайных чисел в умных контрактах Ethereum m1rko Ethereum приобр л огромную популярность как платформа для первичного размещения монет ICO Однако она используется не только для токенов ERC20 Рулетки лотереи и карточные игры вс это можно реализовать на блокчейне Ethereum Как любая реализация блокчейн Ethereum не подда тся подделке он децентрализован и прозрачен Ethereum допускает выполнение тьюринг полных программ которые обычно пишут на языке программирования Solidity По словам основателей платформы это превращает систему во всемирный суперкомпьютер Перечисленные характеристики полезны в приложениях для азартных игр где особенно важно доверие пользователей Блокчейн Ethereum является детерминированным и поэтому представляет определ нные сложности при написании генератора псевдослучайных чисел ГПСЧ неотъемлемой части любого приложения для азартных игр Мы решили исследовать смарт контракты чтобы оценить безопасность ГПСЧ на Solidity и подчеркнуть характерные ошибки проектирования которые ведут к появлению уязвимостей и возможности предсказания будущего состояния ГПСЧ Наше исследование проводилось в несколько этапов Анализ выявил четыре категории уязвимых ГПСЧ Посмотрим на примеры уязвимого кода в каждой категории Вот некоторые переменные блока которые ошибочно принимают за источник энтропии Прежде всего майнеры могут манипулировать всеми переменными блока так что по одной этой причине их нельзя использовать как источник энтропии Что ещ более важно переменные блока очевидно одинаковы в пределах блока Так что если контракт злоумышленника обращается к контракту жертвы через внутреннее сообщение то одинаковый ГПСЧ в обоих контрактах выдаст одинаковый результат Пример 1 Пример 2 Пример 3 У каждого блока в цепочке Ethereum есть проверочный хэш Виртуальная машина Ethereum Virtual Machine EVM позволяет получать эти хэши с помощью функции Функция получает на вход числовой аргумент с указанием номера блока В ходе этого исследования мы обнаружили что результаты выполнения функции зачастую некорректно используются в реализациях ГПСЧ Есть три основных разновидности таких уязвимых ГПСЧ Посмотрим на каждый из этих случаев Переменная состояния позволяет узнать высоту текущего блока Когда майнер забирает транзакцию которая выполняет код контракта то известна переменная будущего блока с этой транзакцией так что контракт может над жно получить е значение Однако в момент выполнения транзакции в EVM хэш создаваемого блока по очевидным причинам ещ не известен а EVM всегда будет выдавать нуль Некоторые контракты неверно интерпретируют выражение В этих контрактах хэш текущего блока считается известным во время выполнения и используется в качестве источника энтропии Пример 1 Пример 2 В некоторых контрактах используется другой вариант ГПСЧ на основе хэша блока там бер тся хэш не текущего а предыдущего блока Нечего говорить что такой подход тоже неприемлем злоумышленник может создать эксплоит контракт с тем же кодом ГПСЧ чтобы вызвать целевой контракт через внутреннее сообщение В обоих контрактах будут одинаковые случайные числа Пример 1 Более хорошая мысль использовать хэш какого нибудь будущего блока Реализовать этот сценарий можно следующим образом Такой подход работает только при соблюдении одного важного требования Документация Solidity предупреждает о лимите хэшей блоков которые способна хранить EVM Поэтому если в течение 256 блоков не поступило второго вызова с проверкой хэша то псевдослучайное число можно предсказать заранее хэш будет равен нулю Самый известный случай эксплуатации этой уязвимости В контракте не проверялся возраст из за чего 400 ETH ушли неизвестному игроку который подождал 256 блоков перед раскрытием предсказуемого выигрышного числа Для увеличения энтропии некоторые контракты применяют дополнительное начальное число seed которое считается секретным Один из примеров лотерея Slotthereum Вот соответствующий код Переменная pointer объявлена секретной то есть другие контракты не могут получить к ней доступ После каждой игры этой переменной присваивается выигрышное число от 1 до 9 а потом используется оно для смещения при получении хэша блока Прозрачный по своей природе блокчейн не должен использоваться для хранения секретов в чистом тексте Хотя секретные переменные защищены от других контрактов но можно получить содержимое хранилища контрактов вне цепочки Например в популярном Ethereum клиенте web3 есть метод API позволяющий получить записи хранилища по заданным индексам Учитывая этот факт становится тривиальной задачей извлечь значение секретной переменной из хранилища контрактов и использовать его как аргумент в коде эксплоита Чтобы получить максимальную награду майнеры выбирают транзакции для создания нового блока на основе совокупного газа топлива который тратится каждой транзакцией Порядок выполнения транзакций в блоке определяется ценой газа Первой будет выполнена транзакция с максимальной ценой газа Так что изменяя цену газа можно добиться чтобы нужная транзакция выполнилась раньше всех остальных в текущем блоке Это может представлять собой проблему безопасности которую обычно называют опережением front running когда исполнение контракта зависит от его положения в блоке Рассмотрим следующий пример Лотерея задействует внешнего оракула для получения псевдослучайных чисел которые используются для выбора победителя среди игроков сделавших ставки в текущем раунде Эти числа отправляются в открытом виде Злоумышленник может наблюдать пул ожидающих транзакций и жд т числа от оракула Как только транзакция от оракула появляется в пуле транзакций злоумышленник делает ставку с большей ценой газа Транзакция злоумышленника пришла последней в текущем раунде но благодаря наивысшей цене газа она в реальности будет исполнена раньше чем транзакция оракула что принес т игроку победу Такую задачу выполняли участники Другой пример контракта подверженного уязвимости с опережением транзакции игра под названием Каждый раз когда игрок покупает билет он занимает последнее место и начинается отсч т таймера Если за определ нное количество блоков никто не покупает билет то последний занявший место игрок выигрывает джекпот Когда раунд близится к завершению злоумышленник может наблюдать пул транзакций других участников и присвоить джекпот установив более высокую цену газа Есть несколько подходов для реализации более безопасных ГПСЧ в блокчейне Ethereum это сервис для распредел нных приложений которые устанавливают мост между блокчейном и внешним окружением Интернет При использовании Oraclize смарт контракты могут запрашивать данные из API в вебе такие как курсы валют прогнозы погоды котировки акций Один из самых известных вариантов использования способность Oraclize работать как ГПСЧ Некоторые из контрактов которые анализировались в ходе нашей работы использовали Oraclize для получения случайных чисел с random org через коннектор URL Эта схема изображена на рис 1 Главный недостаток такого подхода централизация Можем ли мы верить что демон Oraclize не вмешивается в результаты Можем ли мы доверять random org и всей инфраструктуре лежащей в основе этого сервиса Хотя Oraclize проверяет результаты через аудиторский сервис TLSNotary его можно использовать только вне цепочки блоков в случае с лотерей только после оглашения победителя Лучше использовать Oraclize как источник случайных данных с применением которые можно проверить в цепочке это мост между цепочками блоков Ethereum и Bitcoin При использовании BTCRelay смарт контракты в блокчейне Ethereum могут запрашивать хэши будущих блоков Bitcoin и использовать их как источник энтропии Один из проектов применяющих BTCRelay в качестве ГПСЧ лотерея Метод BTCRelay не защищ н от проблемы стимулирования майнеров Хотя здесь барьер выше чем в случае блоков Ethereum но только из за более высокой цены биткоина Так что этот подход снижает но не устраняет вероятность мошенничества со стороны майнеров это алгоритм на основе криптографических подписей Его можно использовать как ГПСЧ в смарт контрактах с участием двух сторон игрока и конторы Алгоритм работает следующим образом В Ethereum есть встроенная функция для проверки подписей ECDSA в цепочке Однако ECDSA нельзя использовать в Signidice поскольку контора может манипулировать входными параметрами в частности параметром и так влиять на получающуюся в результате подпись Алексей Перцев показал такого мошенничества К счастью с выходом ж сткого форка Metropolis появился Это позволяет реализовать проверку подписи RSA В отличие от ECDSA она не допускает манипуляцию входными параметрами для поиска подходящей подписи Как понятно из названия схема коммит раскрытие commit reveal состоит из двух этапов Правильно реализованная схема коммита раскрытия не должна полагаться на единственную сторону Хотя игроки не знают оригинального начального числа поданного владельцем и их шансы равны но владелец тоже может быть игроком поэтому игроки не могут ему доверять Схема коммит раскрытие более грамотно реализована в сервисе ГПСЧ собирает хэши начальных чисел от нескольких сторон и каждая из них получает вознаграждение за участие Никто не знает чужих начальных чисел так что результат абсолютно случаен Однако если хоть одна сторона откажется сообщить сво начальное число то сервис да т сбой Схему коммит раскрытие можно совместить с использованием хэшей будущих блоков В этом случае задействуются три источника энтропии Тогда случайное число генерируется следующим образом Поэтому схема коммит раскрытие решает проблему стимулирования майнеров майнер может повлиять на хэш блока но он не знает начальных чисел владельца и игрока Она также решает проблему стимулирования владельца он знает только собственное начальное число но не знает начальное число игрока и хэш будущего блока Вдобавок такая схема подходит для ситуаций когда человек выступает одновременно в роли владельца и майнера он определяет хэш блока знает начальное число владельца но не знает начальное число игрока Безопасная реализация ГПСЧ в блокчейне Ethereum по прежнему оста тся нереш нной задачей Как показало наше исследование из за отсутствия готовых решений разработчики склонны внедрять собственные реализации ГПСЧ Но при этом легко сделать ошибку поскольку в цепочке блоков немного источников энтропии При разработке ГПСЧ разработчику следует убедиться что он понимает мотивацию каждой стороны и тогда выбирать соответствующий подход
