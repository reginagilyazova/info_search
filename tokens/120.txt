VDOM своими руками pnovikov Привет У многих frontend разработчиков бытует мнение что технология VDOM которая в частности используется в React js работает как черный ящик Так же на просторах npm есть куча библиотек реализующих эту технологию однако вот как по мне так в них черт ногу сломит Сама тема VDOM а меня заинтересовала некоторое время назад и я начал экспериментировать наощупь сам В конечном итоге все кончилось тем что я сделал свою реализацию VDOM а и встроил в свой фрейморк для датагридов о н м я как нибудь напишу Это оказалось не просто а очень просто и в этой статье я детально объясню что к чему зачем и почему И как оно работает тоже расскажу Ныряйте под кат и мы предадимся интересному опыту Я не фронтенд разработчик Не бейте меня тапками Так же не стоит писать возьми готовый фреймворк дубина Я знаю о том что есть готовые фреймворки но мне нужна собственная реализация по ряду сугубо технических причин На хабре но объяснение сути дела в ней мне не нравится Поэтому давайте я на пальцах раскидаю Итак положим у вас есть веб страничка ага В ней отрисован некий HTML элемент вероятно довольно большой Чтобы немного добавить контекста скажу что этот элемент отрисован посредством натягивания шаблона на вью модель Ну все пользовались фреймворками которые делают подобное ведь так Handlebars там lodash шаблоны AngularJS в какой то мере И вот короче представьте что модель на которую натягивается шаблон поменялась И вам надо отрисовать эти изменения внутри HTML элемента Возникает вопрос а как это сделать и при этом не попасть впросак Тут как водится есть несколько вариантов Можно прогнать модель данных через шаблонизатор получить HTML и просто сделать Дешево и сердито но для некоторых задач вполне прокатывает Что же здесь ужасного спросите вы А я вам отвечу этот вариант плох прежде всего потому что все дочерние элементы расположенные внутри будут беспощадно убиты браузером и заменены новыми Следовательно Да следовательно вы потеряете все подписки на события в рамках вашего элемента конечно же которые у вас были Вам придется переподписывать вновь созданные элементы заново Тут я честно признаюсь не в курсе как работает сборка мусора в разных js движках но допускаю что если ранее в своем коде вы сохранили какие то из дочерних элементов например в переменные то эти элементы будут убраны из дерева но не уничтожены Привет утечка памяти мы по тебе скучали Ну это если предположить что браузер использует для DOM элементов reference counting например Кто знает подробности отпишите в комментариях пожалуйста Окромя этого сей вариант дюже медленный особливо когда дочерних элементов много То есть браузер честно сотрет все что было отрисовано внутри элемента пересчитает и перерисует заново Вот представьте нарисована у вас карточка пользователя Гриши в которой 100 разных полей А у вас в данных изменилась только дата рождения И что теперь Все фигня Гриша давай по новой ради одного несчастного куска текста Убьем Гришу целиком посчитаем и нарисуем заново А вы знаете что перерисовка интерфейса в браузере это вообще то долго И если Гриша состоит из 150 элементов то еще куда ни шло А вот если из тысячи вскрытие показывает у Гриши обилие мелких деталей то на отдельных машинах перерисовка может достигать нескольких секунд что дюже снижает отзывчивость интерфейса Ну и самое печальное через innerHTML отрисовываются не все элементы Как пример в IE8 у элемента В Google Chrome через innerHTML плохо рендерятся заголовки таблиц Все что вы туда вставите через innerHTML будет урезано до обычного текста по неведомой мне причине Пруфлинка не будет информация из собственного опыта Вероятно сейчас это уже починили но осадочек остался Таким образом innerHTML как быстрый и грязный хак Ненадежен в общем случае имеет кучу сайд эффектов да и вообще мы тут не в 9 классе школы чтобы так писать Из плюсов реализуется на коленке Откровенно говоря этот вариант решает только последнюю и самую печальную проблему innerHTML крайнюю привередливость в создаваемых элементах Но упомянуть его определенно стоит во многом потому что он нам понадобится для реализации VDOM Как оно работает Да просто работает Парсит HTML и вызывает для каждого узла с последующей установкой атрибутов Потом делаете и проходитесь по полученным элементам вызывая Ну Во первых мы не решили проблему с убиением элементов Во вторых с парсерингом HTML вс не так гладко в этом мире Парсить HTML это примерно как парсить XML документ и в парсерах для клиентской стороны чаще всего употребляется поточный парсер Дада это примерно как Доказано что употребление поточного парсера XML полезно для здоровья Почему Да потому что работает быстро и пишется легко Не стоит использовать для этой задачи классический древесный парсер как для XML Оно тут просто не нужно Все в мире HTML парсеров хорошо кроме одного нету их бедняжек встроенных в браузеры В MDN однако он все еще экспериментален и видимо отдаст вам на выходе дерево Ну вот только обходить деревья и вызывать нам на стороне клиента то и не хватало ага Словом странный он Давайте не будем его трогать Есть Событийный поточный парсер но я сам его не пользовал ибо как идеология моего фреймворка не позволяет мне использовать сторонние зависимости И вот есть пожалуйста воспринимайте его в отрыве от jQuery где он объяснет вс на пальцах и дает код простенького парсера Мне он не нравится тем что работает на регулярных выражениях Вижу сие зело трудозатраным Однако вполне работоспособным Долгое время у меня каюсь использовался как раз код из этой статьи переработанный под TypeScript Однако потом я заменил его на поточный парсер на простенькой state машине коим я с вами сегодня и поделюсь дабы минимизировать сравнения строк и сделать поддержку создания виртуальных элементов что в пример Джона запиливать было несколько неудобно И вот мы наконец подошли к самому хитрому подходу который решает проблемы как с производительностью так и с привередливостью innerHTML к элементам А именно используя парсер HTML мы можем внезапно распарсить наш HTML но вызывать для каждого элемента не а просто создание какого либо объекта который будет хранить имя тега и атрибуты Этот самый объект и будет называться а их совокупность или VDOM Здесь стоит отметить что создать тысячу объектов в JS через это быстро Очень быстро А вот создать тысячу реальных DOM узлов это медленно Из этого обстоятельства собсно и проистекает прирост производительности Окей создали И что же мы будем с этим добром делать Штаны можно не снимать а вот бегать придется мы будем структуру нашего VDOM дерева с тем что уже отрисовано составлять из этого некое подобие diff патча что надо доабвить что убрать куда докинуть атрибутов где поменять контент и накатывать его на существующее DOM дерево Вот прям так же как это происходит в вашем любимом git во время мерджей Благо задача построения diff а в программировании довольно известная гуглится внезапно по словам Решается она динамическим программированием Алгоритм имеет квадратичную сложность В хороших ВУЗах решение этой задачи изучают на первых курсах но здесь я его тезисно опишу и подскажу как адаптировать его под деревья В итоге VDOM подход не убивает те элементы дерева которые не изменились и не созда т лишних элементов что знатно экономит память и сохраняет подписки на события если элементы не уничтожаются одновременно заставляя ваш CPU больше заниматься сравнениями нежели созданием HTML элементов А это да т знатный прирост производительности когда из 1000 элементов на экране изменился только один Мы напишем небольшое приложение которое будет состоять из слева в которой вы будете вбивать и или изменять свой HTML а в окошке справа видеть результат работы Никаких дополнительных библиотек только TypeScript и браузер Будем что называется творить магию из воздуха Вы знаете сначала я хотел добавить в эту статью много кода с построчным разбором оного но памятуя свои предыдущие статьи не решился это делать Непосредственно код снижает читаемость и нагоняет тоску Так что с вашего позволения я просто буду давать ссылки на Github и объясню как и что работает Наш VDOM будет состоять из тр х главных компонент парсера HTML непосредственно компаратора и калькулятора батчей а так же который собер т это вс добро вместе и заставит работать Тут надо сделать оговорочку Как я понимаю React js работает без парсера HTML в виду того что его шаблоны jsx tsx уже собираются в соответствующие вызовы создания нод Это хороший ход улучшающий быстродействие но вы знаете создавать свой язык шаблонизации и писать для него компилятор не входило в мои планы когда я писал эту статью Так что мы будем парсить голый HTML руками Такая реализация гарантирует нам возможность встраивать нашу поделку куда угодно ну и позволит избежать чисто педагогических курь зов если вы понимаете о ч м я Итак поехали JavaScript не содержит эффективных инструментов для работы со стеками а таковой нам понадобится Поэтому делаем Без комментариев Как вы знаете с точки зрения JavaScript HTML документ состоит из нод Некоторые из которых вполне себе являются HTML элементами такими как HTMLInputElement тег HTMLDivElement тег А некоторые нет текст комментарий Все доступные типы нод перечислены Мы же начнем с простого объявим интерфейс т н конструктора нод Чтобы не вхардкоживать в наш парсер HTML я вызовы и использовать один и тот же парсер что для DOM что для VDOM В моей реализации он выглядит Как видим мы ограничиваемся тремя типами нод HTML элемент текст контент и комментарий Интерфейс крайне прост и предусматривает возможность создания всех трех типов нод а для HTML элемента ещ и установку аттрибутов Чтобы далеко не отходить от кассы тут же реализуем его для реальных HTML нод Тут же мы продумаем как мы будем хранить VDOM ноды Что нам важно знать о ноде помимо е типа В случае с HTML элементом тег да атрибуты В случае с комментарием и текстом контент Плюс ко всему прочему нам так же важен список дочерних нод Отлично Описываем интерфейс и для типов после чего реализуем сам конструктор Парсер это у нас будет такая штука у которой есть ограниченной число Она ид т по переданному ей HTML символ за символом и в зависимости от текущего символа меняет сво состояние При переходе из состояния в состояние парсер будет д ргать методы конструктора нод выполняя соответствующие действия Например читает парсер символы никого не трогает Оп встретил запоминает где его увидел меняет состояние на слушаем внимательно сейчас будет HTML тег Читает дальше Оп встречает пробельный символ и такой ага вот оно и имя тега Вспоминает где встретил выгрызает текст оттуда до текущей позиции вот вам и имя тега Стало быть надо дернуть нод конструктор и вызвать у него передав имя тега Дальше парсер пропускает все пробельные символы и если видит то переходит в изначальное состояние А если видит букву алфавита так же ловит имя атрибута значение атрибута в кавычках дергает нод конструктор Ну и так далее пока не дойдет до конца Созданные теги мы будем хранить в стеке Каждый раз когда мы доходим до открывающего тега клад м его в стек При создании элемента через конструктор указываем текущую макушку стека как родительский элемент Тривиально Уверен все хоть раз да делали нечто подобное когда писали калькулятор на первых курсах университета Все состояния а так же действия при переходах мы сложим в которая технически представляет из себя огромный hash объект вида состояние описание действий Описание действий в нашем случае состоит из тр х частей Я объединил эти три функции в штуку которую назвал Там же я описал все возможные состояния парсера Сделал снабдив его несколькими полезными тестер функциями это когда мы смотрим какой у нас символ текущий что было n символов назад складываются ли следующие за текущим m символов в такое то слово ну и иже с ними Особливо выделяется функция когда мы меняем состояние парсера она запоминает позицию текущего символа с той мыслью чтобы сдвинувшись на несколько символов далее мы могли выгрызть кусок текста между запомненной позицией и текущим положением Выгрызание куска текста от запомненной позиции до текущей производится функцией Обычно после вызова state машина подает парсеру вроде о смотри открывающий тег поймали вот его имя Почему так сложно Ну я человек экономный Сделал парсер который не создает лишних строк без необходимости Ну и собственно дальше я просто перечислил все возможные состояния парсера и все возможные действия что называется Там есть много нюансов связанных с кавычками вокруг атрибутов самозакрывающимися тегами символами и в именах атрибутов Разрешите мне опустить здесь детальное разжевывание каждого из этих кейсов вс есть в коде при желании вы сами это увидите Ещ одна особенность теги и парсер вырезает и складывает отдельно дабы пользователь парсера сам решил что с ними дальше делать Можно например сделать у скриптов А вот что делать со стилями вопрос неясный даже для меня Единственное что не учтено в моей реализации это хитрая возможная структура этих тегов Скажем если в е у вас встречается текст в духе то парсер по ошибке распознает оный как закрытие тега что неприятно однако легко чинится Итак на текущем этапе мы имеем годный HTML парсер которому можно передать кусок HTML я и распарсить его в реальные DOM элементы или же в VDOM элементы Это просто прекрасно Теперь представьте что у нас уже отрисован на экране какой то HTML мы хотим его незначительно поменять Бер м его вносим коррективы скармливаем парсеру с VDOM конструктором Получаем список VDOM нод Теперь нам надобно высчитать разницу между HTML ем который отрисован на экране и тем что нам напарсил наш парсер По сути дела надо взять parent нод внутри которого отрисован наш HTML взять массив всех его детей и сравнить его с аналогичным массивом виртуальных детей который нам создал HTML парсер И когда я говорю сравнить я имею в виду не просто ответить на вопрос совпадают или нет но и сгенерировать т н update batch список какие элементы куда надо добавить а какие откуда удалить чтобы из старого куска дерева получить новое После чего полученная пачка изменений просто накатывается на уже отрисованный HTML не уничтожая уже отрисованное и неизмен нное но умно меняя только затронутые ноды Называется эта операция Вот как то так Но обо вс м по порядку Для начала надо научиться сравнивать HTML ноды и VDOM ноды Делается это относительно просто Как можно заметить каждый раз с нуля сравнивать ноды это трудозатратно Во многом из за рекурсии на 5 шаге Поэтому я сделал кэш компаратор который живет в рамках одного update а и хранит результаты сравнений нод друг с другом Таким образом если тот факт что два нода разные уже когда то был установлен то он не устанавливается заново а берется из кэша Это сокращение от Longest Common Subsequence по сути представляет собой матрицу для решения LCS задачи методом динамического программирования Мы ему да м на вход два массива один из реальных нод другой из виртуальных так же скармливаем кэш сравнений про который я рассказал выше Дальше вызываем и получаем массив который по сути говорит что надо сделать с такой то по счету нодой обновить удалить или вставить другую и какую именно ноду ПЕРЕД ней Первым делом после вызова LCS урезает одинаковые элементы с начала и с конца массивов функция Далее на оставшихся данных стоится матрица динамического программирования Затем оную обходят определяя какие ноды надо а какие тоже описано в видео Обратите внимание что на этом этапе мы не получаем список нод которые надо Результат содержит только удаления добавления но Но удаление добавление ноды в одно и то же место или добавление удаление это и есть Операция как раз и делает что схлопывает рядом стоящее добавление удаление в одну операцию переформатируя первичный массив batch entry ев Полученный результат наконец можно вернуть счастливому пользователю LCS и есть самое сложное в VDOM е из за чего многим он кажется страшной магией Как видите сам алгоритм что называется tricky но вполне себе понимаемый Сложность его кстати квадратичная но бояться нечего Если изменений относительно мало и они где то в середине пачки элементов большинство отсекается на стадии и в результате матрица динамического программирования нечасто превышает по размерам 3x3 Конечно же если ваши пользователи не перерисовывают 10 тысяч кнопочек стоящих друг под другом На практике такие случаи происходят редко Так что имеет смысл не строить LCS матрицу если у вас 2 или 1 элемент а обработать результат руками Гораздо чаще в реальной жизни встречается большая вложенность элементов если на то пошло Но однако недостаточная чтобы сорвать стек вызовов в JS у нас дальше будет рекурсивная обработка Вот так и жив м Не знаю возможно тот же React js пошел ещ дальше в оптимизации этого процесса я его исходники не читал Кто знает отпишитесь Все мои задачи же вписываются в означенные ограничения с огромным запасом Наконец пишем метод update который заменяет потомков выбранного нами parent элемента через LCS сравнение на полученный от HTML парсера массив виртуальных нод Тут нам очевидно понадобится штукенция которая превращает виртуальную ноду в реальную Без комментариев И создать кэш сравнений заранее Сам update берем потомков parent а берем массив VDOM нод Создаем LCS получаем update batch Меланхолично проходим по нему собираем всех кого надо добавить в один массив всех кого надо удалить в другой Всех кого надо обновить сначала обновляем список аттрибутов несложной функцией а потом рекурсивно применяем тот же самый метод update который мы в настоящий момент и описываем предварительно достав массив потомков из VDOM ноды донора В итоге всех кого надо добавить прогоняем через материализатор делаем Всех кого надо удалить делаем Упражнение закончено Для дебага я ещ добавил функцию которая выводит в консоль содержимое update batch а Однако на практике е вывод несколько сложен для понимания Создаем создаем из которого и задействуем нашу прекрасную наработку для демонстрации Вы прочли статью о том как устроен VDOM Надеюсь после такого экскурса у вас появится больше понимания зачем оно надо и как оно устроено исчезнет страх перед неизвестным и вы будете немного больше ориентироваться в происходящем внутри модных JS фреймворков Кому то возможно понравится компактный HTML парсер забирайте я не возражаю Всем спасибо за прочтение комментарии приветствуются
