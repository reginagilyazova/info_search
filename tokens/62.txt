Научиться перехватывать необработанные сообщения или пример того как SObjectizer обрастает новыми фичами eao197 Нам очень приятно когда в добавляются новые возможности возникшие в результате подсказок и или пожеланий пользователей SObjectizer а Хотя далеко Ведь с одной стороны у нас как у команды разработчиков и старых пользователей SObjectizer а уже есть собственные стереотипы о том как SObjectizer принято использовать И не всегда получается сразу оценить свежий взгляд со стороны понять что реально хочет видеть пользователь во фреймворке и почему он не удовлетворен имеющимися средствами С другой стороны SObjectzer не такой уж и маленький фреймворк добавление новых возможностей требует определенной осмотрительности Нужно чтобы новая функциональность не конфликтовала с уже имеющимися фичами И тем более чтобы после добавления чего то нового не сломалось то что уже есть и давно работает Плюс к тому у нас есть пунктик по поводу сохранения совместимости между версиями SObjectizer а поэтому мы сильно против кардинальных изменений В общем добавление нового в SObjectizer это всегда приятно с точки зрения увеличения возможностей фреймворка и повышения удобства его использования Но далеко не всегда это так же приятно и просто с точки зрения реализации Под катом небольшой рассказ о том как в SObjectizer добавлялась одна новая фича Может быть кому то из читателей будет интересно посмотреть как старый фреймворк адаптируется под запросы новых пользователей Итак все началось с того что один из пользователей SObjectizer а обратил наше внимание на то что в SObjectizer нет готовых удобных средств для выполнения эпизодических однократных взаимодействий между агентами Оказалось что имеется в виду вот что Допустим агент A хочет отослать запрос агенту B и хочет получить ответное сообщение от агента B Но при этом агент A не хочет ждать ответа дольше чем 5 секунд Тривиальное решение в лоб которое сразу же приходит в голову может выглядеть так К сожалению эта простая версия лишь является наглядной демонстрацией правдивости афоризма о том что любая сложная задача имеет простое легкое для понимания неправильное решение Здесь есть сразу несколько проблем Первая проблема связана с отложенным сообщением A reply_timed_out Если ответ от агента B вовремя не пришел то с reply_timed_out у нас все нормально Мы его получаем обрабатываем и забываем о нем А вот что будет если ответ от агента B пришел вовремя Что произойдет с reply_timed_out Оно все равно придет к агенту A Ведь никто reply_timed_out не отменял Значит как только нить таймера SObjectizer а отсчитает 5 положенных секунд сообщение reply_timed_out будет доставлено агенту A И мы его получим и обработаем не смотря на то что нам оно уже не нужно Что неправильно Правильно было бы сделать так чтобы сообщение reply_timed_out к нам не попадало после того как мы получили reply от агента B Самый надежный способ сделать это это отменить подписку на reply_timed_out Почему именно так это тема отдельного большого разговора Если кому то интересно можно отдельно поговорить на эту тему Пока же ограничимся тем что отписка от отложенного сообщения является железобетонным вариантом решения проблем с отложенным сообщением Вторая проблема связана с тем что вряд ли агенту A нужно будет подобным образом общаться только с агентом B Скорее всего агент A обменивается сообщениями request reply сразу с несколькими агентами Соответственно когда request улетает одновременно агентам B и C то агенту A нужно как то понимать от кого прилетел ответ Или чей ответ не был получен в течении 5 секунд Вторая проблема более менее удобно решается за счет отказа от использования собственного mbox а агента A в качестве обратного адреса Проще создавать новый mbox для каждого нового взаимодействия И именно этот новый mbox будет использоваться и для получения ответа и для отложенного сообщения именно для этого запроса Однако как только мы вводим новый mbox мы должны позаботиться о том чтобы mbox был удален после того как он перестает быть нужным Для этого мы должны удалять подписки на этот mbox Если подписки не будут удалены то mbox останется жить а это приведет к постоянному росту потребляемой памяти мы же будем создавать новые mbox ы на каждый новый запрос а удаляться эти mbox ы не будут В общем если учесть эти две проблемы то простое решение будет преобразовано в не очень простое Получается уже не так просто и компактно как хотелось бы Но и это еще далеко не все Так в этом решении нет никакой exception safety Нет явной отмены отложенного сообщения тогда когда оно уже не нужно Но что еще важнее если агент A захочет иметь не одно дефолтное состояние как в примере выше а несколько состояний в каждом из которых ему нужно реагировать на сообщения по разному то все станет еще страшнее Ну и еще страшнее все станет если обмен между A и B будет требовать не одно ответное сообщение а несколько Скажем если вместо reply будет successful_reply и failed_reply то объем работы для разработчика агента A заметно увеличится Маленькое отступление в сторону Когда нам стало понятно о чем нам говорит мы сами удивились Ведь проблема действительно очевидна Но почему же мы сами с ней не сталкивались По крайней мере не сталкивались настолько часто чтобы обратить на нее внимание и включить решение для этой проблемы в SObjectizer Вероятно здесь имели место два фактора Во первых мы довольно быстро Там количество агентов невелико между ними установлены стабильные связи поэтому там таких проблем нет в принципе Во вторых наверное однократное разовое взаимодействие у нас чаще всего применяется между коротко живущими агентами И для агента который живет всего лишь для обработки одной единственной операции эти проблемы не актуальны Как бы то ни было невозможно не отметить тот факт что как только твоим инструментом начинают пользоваться новые люди так сразу же выясняется что они хотят использовать инструмент совсем не так как привык это делать ты сам В итоге мы расширили свою надстройку над SObjectizer под названием добавив в нее поддержку т н Посредством асинхронных операций приведенный выше пример может быть переписан следующим образом Подробнее о новых асинхронных операциях в so_5_extra можно прочитать Но речь сегодня пойдет не о том как сделаны сами асинхронные сообщения А о том что потребовалось сделать в SObjectizer для того чтобы асинхронные сообщения заработали в so_5_extra В so_5_extra вошло две реализации асинхронных операций time_unlimited когда на время выполнения операции не накладывается вообще никаких ограничений и time_limited когда операцию нужно завершить за отведенное время Выше как раз речь шла именно о time_limited операциях т к именно с их реализацией и была одна из основных загвоздок Суть в том что когда мы начинаем time_limited операцию то мы должны обязательно получить и обработать отложенное сообщение которое и ограничивает время асинхронной операции И вот с этим обязательно как раз то было не все просто Дело в том что одной из ключевых фич SObjectizer а являются Состояния позволяют агентам обрабатывать разные наборы сообщений в каждом из состояний Или же обрабатывать одни и те же сообщения в разных состояниях по разному Но есть и оборотная сторона если какое то сообщение нужно обработать во всех состояниях то нужно явно подписывать обработчик этого сообщения для каждого из состояний Т е писать что то вроде Естественно что это не самое хорошее и удобное решение За счет использования возможностей иерархических конечных автоматов можно сделать проще удобнее и надежнее Теперь обработчик по умолчанию будет вызваться вне зависимости от того в каком из состояний находится агент Но к сожалению такой подход требует чтобы агент изначально был спроектирован с использование иерархических конечных автоматов Вряд ли асинхронными операциями из so_5_extra было бы удобно пользоваться если бы они накладывали столь жесткое требование на пользователей мол хотите пользоваться асинхронными операциями извольте создать в своем агенте родительское состояние Да и не всегда это в принципе возможно сделать Допустим кто то написал вам библиотеку агентов в которой есть базовый тип basic_device_manager Вы делаете свой собственный класс наследний my_device_manager и вам в my_device_manager нужно использовать асинхронные операции Если в basic_device_manager разработчик не сделал что то вроде st_parent то вы туда свой st_parent уже не добавите В общем требовалось сделать что то что позволило бы ловить сообщения которые адресовались агенту но которые агентом не были обработаны Такие сообщения еще иногда называют Мы сделали так что теперь разработчик может повесить собственный обработчик на сообщение которое не было обработано нормальным обработчиком Например Теперь если агент получает сообщение some_msg из почтового ящика some_mbox находясь в состояние st_first то для обработки сообщения будет вызван normal_handler А вот если агент будет находится в любом другом состоянии то для обработки этого сообщение вызовется deadletter_handler Эту фичу как раз и используют time_limited операции При активации операции вешается deadletter_handler на сообщение об истечении тайм аута И в каком бы состоянии агент не находился в момент прихода этого сообщения сообщение будет получено и обработано Что и позволяет завершить асинхронную операцию Даже в случае когда разработчик ошибся и не определил все нужные ему обработчики тайм аутов Первая мысль которая возникла как только сформулировалась проблема deadletter handler ов была в том чтобы снабдить каждого агента неким родительским состоянием А все остальные состояния чтобы автоматически становились дочерними к нему Т е была идея насильно впихнуть в каждого агента некое суперсостояние Которое просто есть и с этим ничего не сделать Эта идея была очень привлекательной с точки зрения текущего механизма хранения и поиска подписок этот механизм не так уж и прост Так же эта идея очень красива с идеологической точки зрения Иерархические конечные автоматы как они есть Но пришлось от нее отказаться может быть на время Главная причина отказа в том что объект state_t является довольно таки тяжеловесным В зависимости от компилятора стандартной библиотеки и параметров компиляции state_t в 64 х битовом режиме может занимать от 150 до 250 байт Если насильно добавлять суперсостояние каждому агенту то вес каждого агента увеличивается на полторы две сотни байт Вот просто так на ровном месте Даже если этому агенту суперсостояние вообще не нужно Была да и есть на самом деле еще и другая причина Суперсостояние для каждого агента это слишком большое нововведение для SObjectizer а чтобы сделать его с бухты барахты не взвесив тщательно все последствия Есть у меня лично большие подозрения на тему того что стоит добавить суперсостояния в SObjectizer и ими начнут злоупотреблять В общем идея с суперсостоянием в работу над версией 5 5 21 не пошла Но зарубка на память осталась Возможно она еще найдет свое воплощение Если у кого то есть соображения на этот счет то интересно было бы услышать и пообсуждать От идеи с суперсостоянием отказались но текущий механизм хранения подписок все таки менять не хотелось Поэтому было найдено решение в котором все таки дополнительный объект state_t потребовался Но и все агенты ссылаются на него Благодаря этому удалось использовать те же самые инструменты для регистрации deadletter handler ов и для их поиска Фактически so_subscribe_deadletter_handler есть ни что иное как Ну а поиск deadletter handler а для сообщения это всего лишь но не для текущего состояния агента а для этого специального невидимого состояния Там правда есть для случая когда включен режим трассировки механизма доставки сообщений но это совсем уже скучные детали Когда я вычитывал эту статью перед публикацией то ловил себя на мысли о том что рассказывается какая то тривиальщина Ну вроде бы все просто и понятно Только вот путь к этому просто и понятно оказался совсем не быстрым не прямым и не очевидным Если кому то интересно то следы эволюции идеи асинхронных операций можно найти в этой мини серии блог постов и Хотя как оказалось даже в заключительном посте этой серии было описано отнюдь не результирующее решение Пришлось еще наткнуться на серьезный собственный просчет и поломать голову над тем как воспрепятствовать утечкам памяти при наличии циклических ссылок между объектами Но это уже совсем другая история Хочется поблагодарить всех кто помогает нам развивать SObjectizer тем кто пользуется SO 5 и высказывает свои соображения и предложения отдельное спасибо здесь тем кто еще не пользуется SO 5 но помогает советами и не только большущая благодарность в частности да и просто тем кому не лень ставить 1 в новостях о SObjectizer на различных ресурсах и звездочки Большое вам всем спасибо Мы собираемся начать работы над следующей версией SObjectizer а под номером 5 5 22 уже в ближайшее время Главная новая фича которую мы хотим увидеть в 5 5 22 это поддержка параллельных состояний для агентов Агенты уже могут использовать продвинутые возможности иерархических состояний Как то вложенность состояний shallow и deep history для состояний обработчики входа выхода временные лимиты на пребывании в состоянии Но вот чего пока еще в SObjectizer не было так это параллельных состояний В свое время мы не стали их делать по каким то причинам Но практика показала что кому то из пользователей параллельные состояния нужные и облегчают им жизнь Так что будем их делать Все желающие приглашаются к обсуждению любые конструктивные соображения а особенно примеры из практики и личного опыта будут нам очень полезны Ну и вообще было бы интересно узнать какие у вас впечатления о SObjectizer е что нравится что не нравится что хотелось бы иметь в SO 5 что мешает Ну и естественно мы готовы ответить на любые вопросы о SObjectizer е
