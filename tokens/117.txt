Концептуальная сортировка в С 20 MarkGrin К изменениям лучше готовиться заранее поэтому предлагаю посмотреть на то что войдет в стандарт C 20 а именно на Сейчас концепции имеют статус технической спецификации документ их описывающий Такие документы нужны чтобы перед принятием нововведений в стандарт языка эти нововведения были опробованы и скорректированы сообществом С Компилятор gcc поддерживает техническую спецификацию концепций в экспериментальном режиме с 2015 года Стоит заметить что концепции из технической спецификации и концепции из текущего черновика С 20 различаются но не сильно В статье рассматривается вариант технической спецификации Шаблоны классов и функций могут быть связаны с Ограничения накладывают требования на аргументы шаблона Концепции это именованные наборы таких ограничений Каждая концепция является булевой функцией проверяющей эти ограничения Проверка производится на этапе компиляции при инстацировании шаблона связанного с концепцией или ограничением Если такая проверка не проходит то компилятор укажет какой аргумент шаблона провалил проверку какого ограничения Теперь когда понятны смысл и назначение концепций можно рассмотреть синтаксис Определения концепций имеют две формы переменной и функции Нас будет интересовать форма переменной Она очень похожа на определение обычной шаблонной переменной но с ключевым словом Вместо комментария нужно написать constexpr выражение которое приводится к bool Это выражение и есть ограничение на аргумента шаблона Что бы ограничить шаблон концепцией нужно вместо typename или class использовать е название Например для целых чисел Можно ставить более сложные ограничения используя требование выражение Требование выражение умеет проверять правильность выражения возвращаемое значение выражения наличие типов Синтаксис хорошо разобран Как же концепции помогут в написании сортировки Сам алгоритм останется неизменным но шаблон сортировки можно улучшить с помощью концепций Рассмотрим такой пример Ошибка заключается в том что у структуры NonComparable нет операции сравнения Представляете как будет выглядеть ошибка компилятора Если нет то загляните под спойлер Такие ошибки можно сократить с помощью концепций для этого напишем враппер их использующий Сортировка принимает итераторы поэтому нужно написать концепцию Сортируемый итератор Для такого итератора нужно несколько концепций поменьше Например сравнимый объект приведен выше обмениваемый объект перемещаемый объект итератор случайного доступа Когда все простые концепции готовы можно определить составную концепцию Сортируемого итератора С его помощью пишется враппер Если вызывать концептуальную сортировку с несравниваемым объектом то ошибка компиляции будет занимает всего 16 строк Конечно первые разы все равно не очень просто понять в чем ошибка но после нескольких концептуальных ошибок они начинают читаться за несколько секунд Конечно не единственное преимущество нововведения Шаблоны станут безопаснее благодаря Код станет более читаемым благодаря концепциям самые часто используемые войдут в В целом С расширится в своей функциональной шаблонной части
