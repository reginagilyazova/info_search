Rust Векторы это значения bmusin В последнее время я долго думал над персистентными коллекциями и в особенности над тем как они относятся к Rust Хочу поделиться с вами своими наблюдениями О том как устроены персистентные векторы быстрее ли они традиционных коллекций смотрите под катом Обычно персистентные коллекции считаются необычным способом работы с коллекциями Вместо того чтобы добавлять элементы посредством что увеличивает вектор не создавая новый экземпляр вы вызываете метод который оставляет исходный вектор на своем месте и возвращает Важно заметить что не меняется Данная особенность хорошо вписывается в функциональные языки хорошо применяется это и в написании многопоточных програм Не буду вдаваться в подробности какого то конкретного решения но большинство из них реализованы на каком либо виде деревьев Например имея вектор вида вы можете сохранять элементы не в одном большом блоке а в виде дерева листами которого являются значения На следующей диаграмме набор значений поделен на два дочерних узла на которые указывает родительский узел А теперь представьте что мы хотим поменять одно из значений в векторе Например мы хотим поменять на Это означает что мы должны изменить правый узел оставляя при этом левый узел нетронутым После этого мы должны будем пересоздать родительский узел который будет ссылаться на новый правый узел В сбалансированном дереве операция добавления в персистентный вектор стремится к O log n мы должны склонировать некоторый лист и изменить его после этого мы должны скопировать и изменить все родительский узлы на пути до корня Несколько замечаний В некоторых случаях персистентные коллекции дают возможность писать более легкий для понимания код Это потому что они выступают как обычные значения и не являются уникальными Посмотрите на этот работающий с числами JS код Если мы меняем мы ожидаем что не поменяется Это потому что являтся простым значением Однако если мы будем использовать массив Теперь когда я меняю переменная тоже меняется Возможно что мне это нужно а возможно и нет Вещи становятся более запутанными когда векторы находятся внутри объектов Не поймите меня неправильно часто бывает удобно когда и являются одним и тем же вектором и изменения одного будут отражены на другом Однако иногда это не то что вам нужно Я часто замечал что использование персистентных коллекций позволяет сделать мой код чище и легче для понимания Если вы видели одно из моих выступлений по то знаете что в них был упор на следующую особенность дизайна Rust Проще говоря когда у вас имеются два указателя на один и тот же участок памяти как и в прошлом примере тогда изменение данных через один из указателей чревато опасностью гонки Особенно ярко это проявляется в Rust когда вы хотите обойтись без сборщика мусора ибо при сборщике мусора неизвестно сколько указателей ссылается на участок памяти ибо дейстия подобные могут затронуть больше объектов чем вы предполагаете порождая баги в частности но не исключительно при одновременной работе нескольких потоков Что же произойдет в Rust если вы захотите получить доступ к одному вектору через два отдельных указателя Давайте вернемся к JavaScript примерам но теперь спроецируем их на Rust Первый пример работает так же как и на JS Однако второй пример с векторами не скомпилируется Проблема в том что как только мы сделаем владение значением будет передано другой переменной поэтому она не сможет больше использоваться Это ведет нас к следующему выводу обычные коллекции Rust'а которые мы используем каждый день Даже больше так делает любой тип в Rust не использующий или Если ваш код компилируется вы знаете что ваш вектор не доступен для изменения через разные указатели вы можете заменить его числом и оно будет вести себя так же Например я написал реализацию персистентного вектора библиотеку Библиотека предоставляет тип который основан на Если вы посмотрите на меторы которые доступны у вы увидите что они самые обычные и т д Вот один из примеров использования Тем не менее является персистентной структурой данных которая реализована как содержит внутри себя потокобезопасный счетчик ссылок который ссылается на внутренние данные Когда вы вызываете то мы обновляем так что теперь он будет ссылаться на новый вектор оставляя старый на своем месте очень крутой метод он проверяет значение счетчика если оно равно 1 то дает вам исключительный доступ к содержимому с возможностью изменения Если же значение счетчика не равно 1 тогда метод склонирует и его содержимое на месте и даст вам изменяемую ссылку на этот клон Если вы помните как работают персистентные структуры данных то данная ситуация очень удобна для обновления дерева при обходе Это позволяет вам избежать клонирования в тех случаях когда на структуру данных ссылается только одна ссылка Главное отличие между и лежит не в поддерживаемых операциях а в том Когда вы вызываете у это O 1 Когда вы клонируете это O n У эти оценки сложности переставлены требует O log n а клонирование O 1 Разумеется когда вы вызываете на он будет клонировать часть данных перестраивая затронутые части дерева в то время как обычно просто пишет в конец массива Однако эта нотация как все знают говорит только об асимптотическом поведении Одной из проблем с которыми я сталкивался при работе с было то что довольно сложно соревноваться со стандартным в скорости Часто копирование набора данных бывает быстрее чем обновление деревьев и выделение памяти Я понял что вы должны приложить много усилий для того чтобы обосновать использование например вы много раз клонируете вектор и они содержат в себе большой объ м данных Конечно производительность это ещ не вс Если вы много раз клонируете вектор то должен использовать меньше памяти ибо может использовать общие части структуры данных Я попытался показать как система владения в Rust предлагает сплав функционального и императивного стилей посредством использования персистентных коллекций когда вы присваиваете одному вектору другой вектор если вы хотите сохранить исходный вектор мы должны c ировать его что делает новый вектор независимым от старого Мои наблюдения не новы В 1990 году Фил Вадлер Phil Wadler написал статью в которой он выдвигает те же утверждения хотя и с несколько другой стороны Он говорит что вы можете предоставлять персистентный интерфейс например метод который возвращает новый вектор Однако если вы используете линейные типы вы можете реализовать это как императивную структуру данных предоставляя и никто об этом не узнает Играясь с я понял что очень удобно иметь персистентный вектор который предлагает такой же интерфейс как и обычный Например было очень легко изменить основанную на векторах библиотеку так чтобы она работала в используя или в императивном режиме используя Проще говоря идея в том чтобы скрывать используемый тип под единообразным интерфейсом Отвлекаясь от основной темы скажу что я хотел бы видеть некоторые экспериментальные исследования скажем было бы удобно иметь вектор который бы преобразовывался в персистентный после достижения определенной длины Я думаю что есть еще одна причина для того чтобы кто то целенаправленно занялся персистентными коллециями В то время как одновременное предоставление доступа и изменяемость могут представлять опасность иногда это бывает очень нужно хотя в Rust это сейчас неудобно Я считаю что мы должны исправить текущее положение вещей так же у меня есть некоторые мысли на этот счет которые я хочу отложить до следующей статьи Rust уже имеет персистентные коллекции клонирование которых однако неэффективно
