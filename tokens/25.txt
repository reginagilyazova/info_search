Руководство для практикующего специалиста как читать научные статьи по языкам программирования m1rko Неделю назад я пошутил что статьи по принципам языков программирования POPL должны соответствовать критерию интеллектуального запугивания чтобы их принимали для публикации Конечно это неправда но факт в том что статьи по языкам программирования выглядят особенно устрашающе для специалистов практиков или академик действительно работает в другой области компьютерных наук Они битком набиты математическими символами и такими фразами как суждения операционная семантика и тому подобное Там много тонких вариантов записи но вы можете в основном уловить суть статьи усвоив несколько базовых понятий Так что вместо рассказа об очередной научной статье я подумал что сегодня лучше напишу краткое практическое руководство по расшифровке научных статей на тему языков программирования Здесь я следую книге Бенджамина Пирса в качестве авторитетного источника Начн м с понятного синтаксис Синтаксис говорит какие предложения можно использовать в языке т е какие программы мы можем писать Синтаксис содержит набор которые представляют собой строительные блоки Возьм м следующий пример из Пирса Всюду где встречается символ можно подставить любой терм Если в статье упоминаются термы то часто используется с подстрочным индексом для различия между разными термами например Множество всех термов часто обозначается как Его не следует путать с символом который традиционно используется для обозначения типов В вышепривед нном примере обратите внимание что сам по себе оператор не является термом это токен в данном случае keyword токен Термом является условное выражение Термы это выражения которые можно вычислить и конечным результатом вычисления в правильно построенном окружении должно стать Значения это подмножество термов В вышепривед нном примере значениями являются а также значения которые могут быть созданы пут м последовательного применения операции к Мы хотим придать какое то значение термам языка Это Существуют различные способы определить значение программ Чаще всего вы встретите упоминания и Из них операционная семантика наиболее распростран нная Она определяет значение программы устанавливая правила для абстрактной машины которая вычисляет термы Спецификации имеют форму набора рассмотрим их чуть позже В этом мировоззрении смысл терма это конечное состояние величина которого достигает машина запущенная с в е начальном состоянии В в качестве значения терма принимается некий математический объект например число или функция в некоторой ранее существующей семантической области а функция интерпретации соотносит термы языка с их эквивалентами в целевой области Так что мы указываем что представляет или денотирует терм в этой области Вы можете также столкнуться с тем что авторы упоминают операционную семантику с малым шагом small step и операционную семантику с большим шагом big step Как следует из названия это относится к тому насколько большой скачок делает абстрактная машина с каждым применяемым правилом В семантике с малым шагом термы переписываются постепенно по одному маленькому шагу за раз пока в конечном итоге не станут значениями В семантике с большим шагом она же естественная семантика мы можем перейти от терма к его окончательному значению за один шаг В записи семантики с малым шагом вы увидите что нибудь такое что следует читать так что вычисляется в Вместо подстрочных индексов могут использоваться штрихи например Это также известно как judgement Стрелка представляет один шаг вычислений Если вам встретится то это значит после многократного применения одношаговых вычислений в конечном итоге переш л в В семантике с большим шагом используется другая стрелка Так что означает что терм в результате вычисления переш л в Если в одном и том же языке используется семантика с малым шагом и семантика с большим шагом то и означают одно и то же Согласно конвенции правила именуются ПРОПИСНЫМИ буквами И если вам повез т то авторы добавят к правилам вычисления префикс E как дополнительную подсказку Например if true then t else t t E IFTRUE Обычно правила вычисления задают в стиле правил вывода inference rules Пример E IF Это следует читать как С уч том указанного в делителе мы можем сделать вывод о том что находится в знаменателе То есть в данном конкретном примере Если выводится в то в этом случае выводится в В языке программирования не обязательно должна быть определ нная система типов он может быть нетипизированным но у большинства она есть Двоеточие используется для указания что данный терм принадлежит определ нному типу Например Терм считается корректно типизированным или типизируемым если существует такой тип для которого верно выражение Как у нас были правила вычисления так здесь имеются правила типизации Они тоже часто определяются в стиле правил вывода а их названия могут начинаться с префикса T Например T IF Такое следует читать как Поскольку терм 1 принадлежит типу Bool а термы 2 и 3 принадлежат типу T то терм if term 1 then term 2 else term 3 будет принадлежать типу T В функциях лямбда абстракциях мы тоже следим за типами аргумента и возвращаемого значения Можно аннотировать связанные переменные указав их тип так что вместо простого можно написать Тип лямбда абстракции для функции с одним аргументом записывается как Это означает что функция принимает аргумент типа и возвращает результат типа В правилах вывода вы увидите знак выводимости оператор в виде турникета Значит следует читать как Из P можно вывести Q или как P подразумевает Q Например означает Из того факта что x принадлежит типу T1 следует что тип t2 принадлежит типу T2 Следует отслеживать привязку переменных к для свободных переменных в функции Для этого мы используем окружение типизации Представьте его как знакомое вам окружение которое транслирует названия переменных в значения но только здесь мы транслируем названия переменных в типы Согласно конвенции для указания контекста типизации используется символ гаммы Он часто встречается в научных статьях без объяснений по конвенции Я запомнил его значение представив виселицу фиксирующую переменные с их типами свисающими на вер вке Но у вас может быть и другой способ Это приводит к часто встречаемому тройственному соотношению в виде Его следует читать так Из контекста типизации следует что терм t принадлежит типу T Оператор в виде запятой расширяет пут м добавления новой привязки справа например Объединив это вс вы получаете правила которые выглядят как это в данном случае для определения типа лямбда абстракции Расшифруем правило Если то что указано в числителе из контекста типизации с ограничением x до T1 следует что t2 принадлежит типу T2 то часть указанная в знаменателе в том же контексте типизации выражение принадлежит типу Если бы Джейн Остин писала книгу о системах типов наверное она бы назвала е Продвижение и сохранение на самом деле я думаю что можно написать много интересных эссе с таким названием Система типов считается безопасной типобезопасной если правильно типизированные термы никогда не оказываются в тупике в процессе вычисления На практике это означает что в цепочке правил вывода мы никогда не застрянем где то без окончательного значения и в то же время без возможности применить правило для дальнейшего продвижения вы увидите что авторы употребляют фразы застрять и оказаться в тупике именно это они имеют в виду Для демонстрации что правильно типизированные термы никогда не окажутся в тупике достаточно доказать теоремы продвижения и сохранения Иногда вы увидите что авторы говорят о продвижении и сохранении не указывая явно почему это важно Теперь вы знаете почему Вот ещ пару вещей которые вам могут встретиться и о которых интересно знать На самом деле я просто заинтересованное постороннее лицо которое наблюдает за тем что происходит в сообществе Если вы читаете это в качестве эксперта по языкам программирования и знаете больше вещей которые следует включить в шпаргалку практикующего специалиста пожалуйста сообщите в комментариях
