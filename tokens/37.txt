Разработка игр под NES на C Главы 1 3 От введения до Hello World BubaVV Впервые я задумался о том как разрабатывают игры под приставки где то через 20 минут после того как в самый первый раз увидел Turbo Pascal На глаза иногда попадался Subor с клавиатурой и появилась мысль Наверное можно набрать какую то программу а потом в нее поиграть Но интерес быстро затух потому что абсолютно никакой информации по этой теме тогда не было доступно Следующий раз эта же идея всплыла когда увидел вполне играбельные эмуляторы старых консолей Тогда стало ясно что вбивать листинг в саму консоль и необязательно Где то очень потом появился Хабр с благожелательной аудиторией для таких вещей В какой то момент даже начал собирать разрозненную инфу чтобы написать мануал самому и вот сегодня наткнулся на готовый учебник который явно надо перевести Разработка под старые консоли документирована вдоль и поперек но именно по NES 99 информации относятся к разработке на Ассемблере Меня почему то зарубило что надо освоить именно работу с С Всем привет Меня зовут Дуг Я пишу игры для NES вот уже год и решил начать этот блог Я намерен написать туториал по разработке игр под NES чтобы вдохновить других людей делать собственные игры Особенностью блога будет использование чистого С так что другие программисты смогут начать писать быстро и не особо вникая в ассемблер для процессора 6502 Насколько мне известно других туториалов такого формата по компилятору cc65 пока нет кроме нескольких примеров игр на сайте Также помните что я не профессионал ни в разработке ни в ведении блога Если возникнут вопросы по NES скорее всего ответы найдутся в Я постараюсь максимально упростить обучение и использовать самые простые примеры Также рекомендую начать с простейшей идеи игры Читателю явно захочется сделать новую но это не получится Простейшая игра потребует 2 3 месяца на разработку Зелда 2 3 года Такой проект скорее всего будет заброшен Ориентируйтесь на Пакман хотя бы первое время Поговорим о структуре памяти У NES два независимых адресных пространства память процессора с диапазоном 0 FFFF и память PPU видеочипа Начнем с памяти процессора более подробная информация У PPU свое независимое адресное пространство Оно имеет размер 3FFF но местами зеркалируется Доступ к нему идет через регистры в памяти процессора Видеопамяти хватает на 4 экранных буфера но в подавляющем большинстве игр используется только 2 для реализации прокрутки Таблица имен nametable связывает тайлы фона и их позицию на экране Зеркалирование позволяет управлять горизонтальной или вертикальной прокруткой но всему свое время Еще в PPU есть отдельная область памяти OAM Object Attribute Memory размером 256 байт Доступ к ней реализован через регистры в адресном пространстве процессора и она позволяет управлять отображением спрайтов Вот подробная информация по памяти PPU Еще один момент Есть два типа картриджей В некоторых два ROM чипа PRG ROM с исполняемым кодом и CHR ROM с графикой В таком случае графика автоматически отображается в адреса 0 1FFF PPU Это позволяет очень просто сделать отрисовку просто записать номер тайла в таблицу Мы будем использовать этот формат Другой тип картриджа использует CHR RAM вместо CHR ROM Это позволяет подгрузить часть графики в эту дополнительную оперативную память Это сложная техника и в этом туториале не рассматривается Теперь можно посмотреть на софт используемый для разработки В этом туториале рассматривается только Это один из лучших компиляторов для 6502 процессора NES Я использую версию 2 15 для проверки введите cc65 version в консоли Файлы из разных версий несовместимы поэтому при необходимости используйте nes lib из комплекта вашего компилятора Во вторых надо создать графику Я использую Для предобработки графики нужен любой графический редактор Photoshop или GIMP по вкусу Код удобно писать в У него есть подсветка сишного синтаксиса и нумерация строк это облегчает отладку А теперь эмулятор Я использую FCEUX 90 времени потому что в нем есть крутой дебаггер и инструменты для работы с памятью просмотрщики спрайтов и все такое Но он не самый точный в эмуляции Игры надо будет тестировать где то еще Судя по отзывам самые точные эмуляторы это Nintendulator Nestopia и puNES Еще желательно подгрузить более точную палитру лежит Есть две версии FCEUX SDL и Win32 Первая работает почти везде вторая только в Windows Так вот отладчик есть только во второй Так что в случае альтернативной ОС придется воспользоваться виртуалкой или Wine И наконец расстановщик тайлов Мы можем сделать игру без него но он точно поможет Я рекомендую Он отлично показывает ограничения консоли по цветам и отлично подходит для одноэкранных игр Для игр с прокруткой лучше подойдет Как же всем этим пользоваться Надо сжать изображение до адекватного размера например 128 пикселей в ширину Потом преобразовать в 4 цвета и подправить при необходимости огрехи Теперь можно копипастить в YY CHR В YY CHR надо проверить чтобы цвет был двухбитный Палитра сейчас не имеет значения потому что она все равно задается в другом месте Все компиляторы для NES работают через консоль без графического интерфейса То есть пишем программу в Блокноте а потом вызываем компилятор с нужными параметрами Дл упрощения работы будем использовать bat скрипты и Makefile Это позволит автоматизировать процесс и собирать образ картриджа в одно касание Процесс примерно такой cc65 компилирует файл с кодом на С в ассемблерный код ca65 собирает объектный файл ld65 линкует его в образ картриджа nes который можно запустить в эмуляторе Настройки хранятся в cfg файле В приставке используется 8 битный процессор MOS 6502 Он не умеет просто обращаться к переменным больше 8 бит Адресация 16 битная из математики есть только сложение вычитание и битовые сдвиги Так что код придется писать с учетом этих факторов Испольуйте опцию O для оптимизации Есть еще опции i r s которые иногда комбинируют в Oirs но они например могут удалить чтение из регистра процессора значение которого не используется А это фатально по использованию компилятора Оптимизация жизненно необходима потому что у 8 битного процессора очень мало ресурсов и в некоторых случаях надо следить за временем выполнения кода А обычный код на С этим требованиям не соответствует Поддерживается импорт переменных из других файлов cc65 умеет импортировать переменные и массивы из ассемблерных модулей командой а если это символ из нулевой страницы памяти то добавьте директиву В дальнейшем курсе эти конструкции будут использоваться редко Единственное исключение импорт большого бинарного файла В этом случае оптимально будет завернуть его в ассемблерный файл а потом импортировать в С как Знак _ здесь критичен потому что при компиляции в ассемблерный код cc65 добавляет _ перед каждым именем переменной Нам надо этому соответствовать Можно вызывать функции написанные на ассемблере через __fastcall__ В этом случае аргументы передадутся в функцию через регистры а не стек экономит время В некоторых случаях без ассемблерного кода не обойтись например при инициализации приставки В любом случае чем меньше аргументов передается в функцию тем лучше Сравним две функции причем переменные test и A глобальные Еще можно вставлять ассемблерный код прямо в сишный Я так почти никогда не делаю но наверное иногда это необходимо Выглядит примерно так Кроме того я заменил громоздкий код инициализации crt0 s на компактный reset s и подправил конфигурацию для всего этого Эти файлы иногда будут меняться nes lib используется стандартный из состава компилятора Проект собирается с опцией add source которая не удаляет промежуточные ассемблерные файлы можно порассматривать сгенерированный код Удобней определить переменные в сишном коде а потом импортировать в ассемблерный через Но это вопрос вкуса на мой взгляд такой код наглядней Эта программа будет просто печатать текст на экране Надо помнить что приставка вообще не знает про кодировку ASCII и работу с текстом в любом виде Но зато есть возможность вывести картинки размером 8х8 поверх фона Так что делаем массив спрайтов букв чтобы адреса букв в нем соответсвовали их ASCII кодам Потом их можно будет дернуть из кода на С Код инициализации приставки пока берем как есть после его выполнения происходит переход на main Нам надо сделать такие операции Выключение экрана нужно потому что работа с видеопамятью вызывает мусор на экране Надо или выключить экран или ждать кадровый гасящий импульс V Blank Детально этот вопрос мы рассмотрим в следующий раз Код инициализации заполняет память нулями так что весь экран будет залит нулевым тайлом в нашем случае он пустой А вся палитра заполнена серым цветом Для вывода на экран надо записать координаты начала заливки начиная со старшего байта по адресу 2006 а потом записывать номера тайлов в 2007 PPU будет выводить тайлы с соответствующими номерами один за другим с переходом на новую строку Можно перенастроить PPU на шаг вывода равный 32 тайлы будут выводиться один под другим Нам же надо выставить шаг 1 через регистр 2000 Пересчитать координаты экрана в адрес можно через NES screen tool Нам также надо заполнить первые 4 цвета палитры они отвечают за фон Они записываются по адресу 3F00 Запись в регистры PPU ломает положение прокрутки так что ее тоже надо сбросить Иначе картинка может уехать за экран Мы делаем это через регистры 2006 и 2005 Ссылка на код На Гитхабе чуть исправил Makefile чтобы корректно работал под Windows Строка внутри секции segments в файлах cfg нужна для совместимости со свежей версией cc65 Включение экрана через PPUMASK 0x1e описано в Все файлы здесь размером 0х4000 Это самый маленький возможный размер PRG ROM 90 игр сюда не влезут и будут отображаться на адреса 8000 FFFF У нас же игра загружается в адреса C000 FFFF и зеркалируется в 8000 BFFF Для разработки большей игры надо будет перенастроить адрес начала ROM на 8000 и выставить размер тоже 8000 А еще включить второй банк PRG ROM в секции header
