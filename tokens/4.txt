Мышление в стиле Ramda первые шаги saggid 2 Сочетаем функции 3 Частичное применение каррирование 4 Декларативное программирование 5 Бесточечная нотация 6 Неизменяемость и объекты 7 Неизменяемость и массивы 8 Линзы 9 Заключение Данный пост это начало серии статей Мышление в стиле Ramda о функциональном программировании Я буду использовать библиотеку в этих статьях хотя многие из обсуждаемых идей применимы также к множеству других библиотек таких как Underscore и Lodash а также к другим языкам программирования Я буду придерживаться л гкой менее академической стороны функционального программирования Это в основном потому что я хочу чтобы серия была доступна большему числу людей но также частично и потому что я сам не так близок к истинно функциональной дороге Я несколько раз затрагивал библиотеку Ramda для JavaScript в данном блоге В я надеюсь также перевести и эту статью впоследствии прим пер я показал некоторые примеры того как Ramda может быть использована в различных контекстах при написании Redux приложения В я использовал Ramda для трансформации полезной нагрузки к запросам и возвращаемым ответам Я наш л Ramda прекрасно спроектированной библиотекой которая предоставляет множество инструментов для чистого и элегантного функционального программирования в JavaScript Если вы желаете поэкспериментировать с Ramda в процессе чтения этой серии статей то на сайте Ramda имеется удобная для ваших экспериментов Как следует из названия функциональное программирование имеет много общего с функциями Для нашей ситуации мы определим функцию как кусочек переиспользуемого кода который вызывается с количеством аргументов равным нулю и более и возвращает результат Это простая функция написанная на JavaScript Вместе со стрелочными функциями из ES6 вы можете написать ту же самую функцию гораздо более кратко Я упоминаю об этом сейчас потому что мы будем использовать множество стрелочных функций по мере продвижения наших статей Некоторые языки идут дальше и предоставляют поддержку для функций как конструкций первого класса Под конструкциями первого класса я подразумеваю что функции могут использоваться таким же образом как прочие значения К примеру вы можете ссылаться на них в константах и переменных передавать их в качестве параметров в другие функции возвращать их как результат от других функций JavaScript один из подобных языков и мы будем использовать это преимущество При написании функциональных программ вы в конце концов приходите к пониманию важности работы с так называемыми чистыми функциями Чистые функции это функции которые не имеют побочных эффектов Они ничего не присваивают внешним переменным они не уничтожают входные данные не генерируют вывод не читают и не пишут в базу данных они не изменяют параметры которые были им переданы и так далее Основная идея заключается в том что если вы вызываете функцию с теми же параметрами снова и снова то вы всегда будете получать один и тот же результат Безусловно вы можете делать различные дела с нечистыми функциями и должны если ваша программа делает что то интересное но для большей части кода вы желаете сохранить свои функции чистыми Другая важная концепция в функциональном программировании это иммутабельность Что это значит Иммутабельный означает неизменяемый Когда я работаю c иммутабельностью после первичной инициализации значения или объекта я уже не изменяю их вновь Это значит что вы не изменяете элементы в массиве или свойства объектов Если мне необходимо изменить что то в массиве или объекте я возвращаю новую его копию с измен нными значениями В последующих постах мы поговорим об этом в подробностях Иммутабельность ид т рука об руку с чистыми функциями Поскольку чистые функции не имеют права создавать побочные эффекты они не имеют права изменять внешние структуры данных Они вынуждены работать с данными в иммутабельном стиле Самый простой путь начать мыслить в функциональной парадигме начать заменять циклы на итерационные функции Если вы пришли с другого языка который имеет эти функции Ruby и Smalltalk лишь два примера вы можете быть уже знакомы с ними Мартин Флауер имеет набор прекрасных статей о Потоках коллекций которые показывают и Обратите внимание что все эти функции за исключением reject доступны в Array prototype так что вам не нужна Ramda для того чтобы начать использовать их Тем не менее я буду использовать Ramda версии для согласованности с остальными статьями Вместо того чтобы писать явный цикл попробуйте использовать функцию forEach вместо этого Вот так forEach бер т функцию и массив и вызывает эту функцию к каждому элементу массива В то время как forEach это наиболее доступная из этих функций она используется в наименьшей степени при выполнении функционального программирования Она не возвращает значения так что она в реальности используется только для вызова функций которые имеют побочные эффекты Следующая наиболее важная функция которую мы изучим это map Как и forEach map применяет функцию к каждому элементу массива Тем не менее в отличии от forEach map собирает результат применения это функции в новый массив и возвращает его Вот вам пример Он использует анонимную функцию но мы можем использовать здесь и именованную функцию Теперь давайте взглянем на filter и reject Как следует из названия filter выбирает элементы из массива на основе некоторой функции Вот пример filter применяет эту функцию isEven в данном случае к каждому элементу массива Всякий раз когда функция возвращает правдивое значение соответствующий элемент включается в результат И также всякий раз когда функция возвращает ложное значение соответствующий элемент исключается фильтруется из массива reject делает точно такую же вещь но в обратном смысле Она сохраняет элемент для каждой функции которая верн т ложное значение и исключает элемент для тех функций которые вернут истинное значение find применяет функцию к каждому элементу массива и возвращает первый элемент для которого функция возвращает истинное значение reduce это немного более сложная чем другие функции которые мы сегодня рассмотрели Это стоит знать но если у вас проблемы с пониманием сути е работы не позволяйте этому останавливать вас Вы можете пройти довольно долгий путь даже не понимая суть е работы reduce принимает функцию с двумя аргументами изначальное значение и массив для работы с ним Первый аргумент который будет передан функции называется аккумулятором а вторым аргументом является значение итерируемого массива Функция должна вернуть новое значение аккумулятора Давайте взглянем на пример и затем разбер м то что в н м происходит Начиная с данных итерирующих функций вы можете уловить идею пробрасывания функций в другие функции Возможно даже что вы уже использовали это в других языках без понимания того что вы занимались в этот момент функциональным программированием Следующий пост в этой серии Сочетаем функции покажет как мы можем перейти к следующему шагу и начать совмещать функции в новых интересных вариантах
