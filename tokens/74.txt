Погружение в разработку на Ethereum Часть 3 приложение для пользователя rubyruby В предыдущих статьях и мы описали как можно пользоваться децентрализованными приложениями на смарт контрактах если вы сами не против быть нодом Но чем меньше пользователя заставляют совершать дополнительные действия тем лучше Для работы со смарт контрактами необходимо подписывать транзакции приватным ключом поэтому совсем без дополнительный действий к сожалению не обойтись В этой статье мы рассмотрим два подхода первый полноценное децентрализованное приложение DApp на javascript с использованием библиотеки Web3 и плагина MetaMask второй аналогичное приложение но использующее Ruby on Rails API и гем Ethereum rb для доступа к блокчейну Для демонстрации работы настоящего DApp рассмотрим приложение вдохновленное Вместо Democracy с голосованием и выполнением произвольных транзакций сделаем упрощенный контракт Charity в котором кто угодно создает предложение по распределению денег эфира участники голосуют и после истечения дедлайна предложение либо выполняется либо нет в зависимости от результата голосования Логика смарт контракта в данном случае не очень важна наша цель продемонстрировать варианты взаимодействия пользователя с блокчейном Рассмотрим какие средства мы будем использовать чуть подробнее а после перейдем непосредственно к приложению Это такой плагин для браузера Chrome разработчики пишут что планируют и для Firefox но пока только хром Скачать можно Плагин делает две вещи Подробнее о том как пользоваться плагином можно прочитать на или Web3 js это JavaScript библиотека та же которую мы использовали в Geth в MetaMask встраивает Web3 js в каждую открытую страницу поэтому можно протестировать простые команды непосредственно в javascript консоли в Chrome Developer Tools Важно отметить на момент написания этой статьи актуальная версия Web3 js 0 20 1 Документация для версии 0 x x доступна по не путайте с документацией для версии 1 0 Выполним две команды одну на получение данных например баланса аккаунта вторую на изменение например задание строки в смарт контракте StringHolder из Предварительно не забудьте создать аккаунт в MetaMask подключиться к нужной сети в данном случае Ropsten Test Network и зайти в консоль Developer Tools Не забывайте при вызове методов контракта передавать коллбэк функцию в качестве последнего аргумента Можно так Web3 js использует библиотеку для числовых значений В примере выше ответ выведен без преобразования Команды чтения выполняются сразу а если вы захотите выполнить функцию изменяющую данные в смарт контракте не помеченную как то MetaMask выдаст окно подписи транзакции Продемонстрируем это открыв контракт StringHolder из и вызвав в нем метод задания строки После вызова метода setString выдается окно с запросом подтвердить транзакцию и информацией по предположительным затратам газа и эфира Нажмите Submit В консоли увидите хеш транзакции Через некоторое время проверим что строка изменилась Все работает как должно Это библиотека для работы с блокчейном Ethereum из Ruby на данный момент поддерживается наиболее активно Попробуем открыть контракт StringHolder из irb консоли Особенность вызова методов здесь в том что через вызываются только геттеры где нужно просто получить данные Для выполнения транзакций будет нужен для синхронного вызова либо для асинхронного вызова Попробуем вызвать функцию для которой будет создаваться транзакция Есть два способа unlockAccount deprecated и sign transaction об этом чуть позже Необходимо назначить от кого посылается транзакция того же кого мы сейчас разблокировали Потом можно вызывать сеттер вместо подставив либо либо Дожидаемся окончания вызываем Видим наши изменения все работает Сформулируем задачу У нас должен быть контракт представляющий собой благотворительную организацию со счетом В этой организации могут быть зарегистрированы пользователи которые могут выступать и в качестве получателей пожертвований и в качестве голосующих за предложения Нужен способ создать предложение о перечислении денег эфира со счета организации на один из зарегистрировавшихся аккаунтов Чтобы не было искушения забрать за раз весь эфир введем ограничение предложить можно не более 1 эфира Далее идет голосование можно голосовать за или против которое нельзя завершать до определенного дедлайна 5 минут с момента создания предложения После дедлайна голоса продолжают приниматься но должна быть возможность завершить голосование и если оно завершилось с бо льшим количеством за чем против перечислять эфир со счета организации на счет получателя Если больше голосов против ничего не делать В целом схема приложения такая Два js модуля Blockchain js и BlockchainApi js отвечают за работу с блокчейном Они делают одно и тоже только первый работает c Web3 js и через ноду MetaMask напрямую обращается к блокчейну второй делает ajax запросы к Rails API где уже происходит взаимодействие с блокчейном через гем ethereum rb Само клиентское приложение написано на React и не зависит от того какой js модуль из двух используется Контракт в виде одного единственного файла поэтому не будем пользоваться специальными средствами для деплоя сделать это можно любым способом хоть хоть Можете использовать наш код В целом его схему можно изобразить так Рассмотрим код контракта Charity sol по логическим блокам Сначала идет описание всех нужных нам переменных Маппинг позволяет по адресу пользователя получить его индекс в массиве Если пользователя с таким адресом не существует то будет возвращен индекс 0 На этом будет основана далее функция определяющая зарегистрирован ли пользователь с данным адресом Но это вносит требование для массива пользователи должны храниться в массиве начиная с индекса 1 Код отвечающий за эту логику будет рассмотрен дальше А пока идет структура для хранения предложения Структура голосов складывается в массив для каждого предложения Рассмотрим модификатор который позволит нам контролировать что выполнение методов к которым он будет добавлен возможно только если пользователь зарегистрирован Код проверки как уже было сказано основан на том что несуществующие элементы маппинга дают индекс а пользователей будем хранить начиная с индекса это структура по которой можно получить информацию о вызывающем В данном случае это адрес аккаунта который вызвал метод с этим модификатором Опишем конструктор нашего контракта который будет выполняться при деплое Все что требуется задавать время которое выделяется для голосования за каждое предложение Кроме этого увеличиваем размер массива members потому что добавлять пользователей будем исходя из размера а нулевой элемент остается зарезервированным Функция для добавления пользователя Заметьте функцию она пришла на замену в более старых версиях solidity В передается или если это то срабатывает обработчик аналогичный откатывается вся транзакция Чтобы можно было проверить находится ли адрес в списке пользователей используем такую функцию Следующая функция для создания предложения принимает адрес получателя пожертвования количество эфира в wei и строку с описанием К этой функции применяется модификатор onlyMembers это значит до выполнения всего кода произойдет проверка что вызывающий аккаунт зарегистрирован Здесь вы увидите такие преобразования как и Полный список таких суффиксов можете посмотреть они сделаны для удобства и могут применяться только к значениям но не к переменным Но чтобы применить к переменной достаточно просто добавить 1 к суффиксу что и сделано в нашем случае для преобразования в секунды Заметьте здесь ключевое слово это текущее время но не на момент вызова транзакции а на момент создания блока Поэтому дедлайн будет отсчитываться с момента когда предложение уже будет создано на блокчейне Несмотря на то что у нас получать таким образом можно только простейшие поля в виде массива То есть вызвав в контракте метод например мы получим предложение с индексом в виде массива а массивы и внутри структуры не вернутся Но нам нужна информация о том проголосовал ли пользователь за определенное предложение чтобы отображать его голос или дать возможность проголосовать И желательно сделать это в одно обращение поэтому мы получаем эту информацию когда читаем структуру Proposal для отображения в нашем приложении с помощью специальной функции которая принимает аккаунт для которого нужен статус голоса и идентификатор предложения А это вспомогательная функция которая ищет как проголосовал конкретный пользователь в конкретном предложении Возвращаться будет если пользователь не проголосовал если пользователь проголосовал за если проголосовал против Голосование для предложения с конкретным номером отдаем голос true за или false против И последняя функция служит для завершения голосования и отправки или неотправки эфира на адрес получателя В конце присутствует пустая функция с модификатором payable Это нужно для того чтобы на адрес контракта можно было присылать эфир Вообще пустая функция это функция которая принимает и обрабатывает все сообщения которые не являются вызовом функций Все что нам требуется это сделать ее payable тогда отправленный газ просто зачислится на контракт без каких либо дополнительных действий Но заметьте что на других функциях этого модификатора нет поэтому в нашем случае нельзя отправлять эфир например с вызовом Основной сценарий приложения Демонстрация приложения доступна по MetaMask версия Исходный код Еще раз обращаем ваше внимание на то что текущая версия Web3 js 0 20 1 Но уже готовится к релизу версия 1 0 в которой изменения достаточно существенны Как мы говорили выше MetaMask встраивает web3 в страницу и его можно сразу использовать Но учитывая то что библиотека активно развивается а нам нужно гарантировать работоспособность приложения для пользователя необходимо использовать свою залоченную версию и переопределять объект web3 который встраивает MetaMask Мы делаем это в следующем методе Делать это нужно после события Одна неочевидная проблема которая решается в этом коде если просто сделать как предлагается в официальной документации то не подхватывается аккаунт по умолчанию Еще в MetaMask как уже писалось можно выбирать сеть из списка У нас используются адреса контрактов в сети Ropsten если попытаться подключаться по этим адресам в других сетях результат будет непредсказуем Поэтому прежде чем предоставлять доступ к приложению нужно проверить в той ли сети находится пользователь Получить идентификатор сети можно с помощью команды Мы делаем эту проверку и сравниваем результат с id для сети Ropsten это 3 Список id всех сетей можно увидеть например в описании net_version Вся логика работы с блокчейном находится в файле Здесь есть два типа функций функции для получения данных из блокчейна и функции изменяющие данные в блокчейне Большинство методов из web3 js выполняются асинхронно и принимают callback в качестве последнего параметра Поскольку зачастую приходится вызывать несколько методов для получения данных и вызов некоторых из них зависит от результата работы других удобно использовать промисы В версии 1 0 web3 js асинхронные методы возвращают промисы по умолчанию Приведем один пример получения информации из блокчейна Функция возвращает адрес текущего аккаунта баланс и флаг того является ли данный аккаунт участником организации Рассмотрим теперь функцию изменения данных в блокчейне например функция добавления участника организации Как видим синтаксис ничем не отличается от предыдущего примера вот только выполнение этой функции повлечет создание транзакции для изменения данных в блокчейне При вызове любой функции смарт контракта в результате которой создается транзакция MetaMask предлагает пользователю подтвердить эту транзакцию или отклонить ее Если пользователь подтверждает транзакцию то функция возвращает хеш транзакции Один неочевидный момент это как узнать выполнилась транзакция успешно или нет Определить статус транзакции можно на основании кол ва газа которое было использовано Если использовано максимально доступное кол во газа то либо в ходе выполнения возникла ошибка либо газа не хватило для выполнения транзакции Проверку статуса мы делаем следующим образом При создании новой транзакции мы добавляем ее в localStorage и периодически опрашиваем ее статус до тех пор пока не узнаем что она выполнилась успешно или нет Логика мониторинга транзакций находится в файле По настоящему децентрализованное приложение выглядит как вариант описанный выше Пользователь сам подписывает транзакции при помощи ключа который хранится у него же Но помимо случаев когда пользователь приложения непосредственно взаимодействует с блокчейном бывают случаи когда требуется доступ к блокчейну на стороне бекенда Возможно это какое то внутреннее приложение и действия с блокчейном выполняются от аккаунтов которые вы контролируете и ключи для которых вы можете хранить на сервере Возможно логика вашего приложения на смарт контрактах подразумевает реагирование на определенные события от вашего централизованного сервера В данном случае помимо web3 js который вы конечно тоже можете использовать на сервере было бы неплохо иметь инструмент для привычного вам стека разработки Для нас таким является Ruby on Rails поэтому мы решили попробовать библиотеку ethereum rb которая должна решать туже задачу что и web3 js Демонстрация приложения доступна по Rails API версия Исходный код Для демонстрации работы с ethereum rb мы сделали аналогичный набор функций описанным в blockchain js Код работы с блокчейном можно посмотреть а мы опишем основные моменты и возможно отличия Первое теперь у нас нет доступа к аккаунту пользователя поэтому нам нужно сделать некоторый процесс авторизации и создавать для каждого пользователя аккаунт в блокчейне Процесс авторизации в данном примере максимально упрощен мы просто генерируем токен который сохраняется в LocalStorage браузера и по которому происходит авторизация запросов к API В целом схема работы с аккаунтами такая Как и в js версии есть два типа методов те что берут данные из блокчейна и те что изменяют их Первые достаточно простые и как они работают понятно из примера Методы которые изменяют данные в блокчейне создают транзакцию которую нужно подписать приватным ключом Для работы с приватными ключами используется Ниже демонстрируется процесс создания нового аккаунта для блокчейна и подпись транзакции приватным ключом Рассмотрим метод он принимает приватный ключ и блок кода который мы хотим выполнить используя данный ключ В базе данных ключ хранится в бинарном виде из которого создается объект ключа при помощи гема Eth Далее этот ключ присваивается в поле экземпляра контракта Подпись транзакций происходит автоматически в геме ethereum rb если в поле контракта задан ключ После вызова нужного метода или нескольких методов обнуляем ключ чтобы случайно не отправить еще транзакций от этого же аккаунта Для примера использования рассмотрим метод завершения Proposal который вызывает метод в смарт контракте Метод возвращает хеш транзакции Логика проверки статуса транзакции аналогична той что мы использовали в js версии Демонстрация приложения доступна по Мы перечислили на счет контракта некоторое кол во эфира если он закончится и у вас есть лишний тестовый эфир можете задонатить сюда сеть Ropsten На наш взгляд оба варианта имеют право на жизнь но в различных случаях В данном конкретном примере версия с Ruby немного притянута за уши и версия использующая MetaMask более логична Но как уже было упомянуто в начале задачей было не дать образец проекта а показать на простой логике примеры взаимодействия с блокчейном при помощи javascript и ruby Надеемся с этой задачей мы справились Следующей задачей ставим себе описание более продвинутой работы с деплоем и тестированием смарт контрактов Ожидайте следующую статью на эту тему Погружение в разработку на Ethereum
