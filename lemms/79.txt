анализировать локальный функция в c 7 josefdzeranov добавление локальный функция в язык c первоначально для я быть излишний прочитать статья в блог я понять что этот фич действительный нужный итак кто сомневаться в надобность локальный функция и кто ещё не знать что это вперёд за знание это новый возможность в c 7 который позволять определять функция внутри другой функция основный идея локальный функция очень похожий на анонимный метод в некоторый случай создание именовать функция слишком дорого с точка зрение когнитивный нагрузка на читатель иногда функциональность по свой суть являться локальный для другой функция и нет смысл загрязнять внешний область видимость отдельный именовать сущность вы мочь подумать что этот возможность избыточный потому что такой же поведение мочь быть достигнуть с анонимный делегат или лямбда выражение но это не всегда так анонимный функция иметь определённый ограничение и они характеристика производительность мочь быть непригодный для ваш сценарий вот простой функция который читать файл по строка вы знаете когда быть выбросить argumentnullexception метод с в тело являться особый они называться и они ленивый lazy это означать что выполнение этот метод происходить по требование и один блок код в они быть выполняться только тогда когда клиент метод вызвать на результирующий итератор в наш случай это означать что ошибка произойти только в метод потому что весь linq оператор тоже ленивый очевидно что такой поведение нежелательно потому что метод не быть иметь достаточный информация о контекст поэтому быть бы неплохо бросить исключение сразу когда клиент вызывать но не тогда когда клиент обрабатывать результат чтобы решить этот проблема мы нужно извлечь логика проверка в отдельный метод это хороший кандидат на анонимный функция но анонимный делегат и лямбда выражение не поддерживать блок итератор лямбда выражение в vb net мочь иметь блок итератор асинхронный метод иметь аналогичный проблема с обработка исключение любой исключение создать метод пометить ключевой слово проявляться в возвратить задача вы мочь подумать что при возникновение ошибка нет большой разница но это далеко от истина неисправный задача faulted task означать что сам метод не смочь выполнить то что он должный быть сделать неисправный задача означать что проблема заключаться в самый метод или в один из блок от который зависеть метод проверка надёжный предварительный условие особенно важный когда результирующий задача передаваться по система в это случай быть бы очень трудно понять когда и что пошло не так локальный функция мочь решить этот проблема я быть очень досадный что нельзя использовать итератор внутри лямбда выражение вот простой пример если вы хотеть получить весь поль в иерархия тип включая закрытый вы нужно пройти иерархия наследование вручную но логика обход специфичный для конкретный метод и должный быть максимальный локализовать анонимный функция по умолчание не мочь ссылаться на сам себя чтобы обойти это ограничение вы должный объявить локальный переменный с тип делегат а затем захватить этот локальный переменный внутри лямбда выражение или анонимный делегат этот подход не очень читабельный и следующий решение с локальный функция кажется более естественный если вы когда либо работать над критичный для производительность приложение то вы знаете что анонимный метод не из дешёвый но модель аллокация для локальный функция существенно отличаться если локальный функция захватывать локальный переменный или аргумент то компилятор c генерировать специальный структура замыкание создавать она экземпляр и передавать она по ссылка в сгенерировать статический метод компилятор генерировать имя с недопустимый символ такой как и чтобы улучшить читаемость я изменить имя и немного упростить код локальный функция мочь захватывать экземплярный состояние локальный переменный или аргумент никакой аллокация в управляемый куча не произойти локальный переменный использовать в локальный функция должный быть определить definitely assigned в место объявление локальный функция есть несколько случай когда произойти создание объект в управляемый куча 1 локальный функция явно или неявно преобразоваться в делегат если локальный функция захватывать поль экземплярный или статический поль но не захватывать локальный переменный или аргумент аллокация замыкание и делегат произойти если локальный функция захватывать локальный аргумент 2 локальный функция захватывать локальный переменный аргумент а анонимный функция захватывать переменный аргумент из тот же область видимость этот более тонкий случай компилятор c генерировать отдельный тип замыкание для каждый лексический область видимость аргумент метод и локальный переменный верхний уровень находиться в один и тот же область верхний уровень в следующий случай компилятор быть генерировать два тип замыкание два разный лямбда выражение использовать один и тот же тип замыкание если они захватывать переменный из один и тот же область видимость сгенерировать метод для лямбда выражение и находиться в один и тот же тип замыкание в некоторый случай такой поведение мочь вызвать некоторый очень серьёзный проблема связанный с память вот пример кажется что переменный должный быть доступный для сборка мусор сразу после вызов делегат но это не так поскольку два лямбда выражение использовать один и тот же тип замыкание это означать что замыкание оставаться живой до тот пора пока делегат доступный из код приложение это мочь продлить время жизнь что по суть являться своеобразный утечка память аналогичный проблема возникать когда локальный функция и лямбда выражение захватывать переменный из один и тот же область видимость даже если они захватывать разный переменный тип замыкание быть общий вызывать выделение объект в управляемый куча быть преобразовать компилятор в как вы мочь видеть весь локальный переменный из верхний область видимость теперь становиться частью класс замыкание что приводить к создание объект замыкание даже когда локальный функция и лямбда выражение захватывать разный переменный ниже привести список наиболее важный аспект локальный функция в c вот результат микробенчмарка чтобы получить этот цифра вы нужно вручную декомпилировать локальный функция в обычный функция причина это простой такой простой функция как fn быть встроить inline в время выполнение и тест не показать реальный стоимость вызов чтобы получить этот число я использовать статический функция отметить атрибут к сожаление вы не мочь использовать атрибут с локальный функциями

