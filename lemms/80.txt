исследовать сопоставление с образец в c 7 josefdzeranov в c 7 наконец появиться долгожданный возможность под название сопоставление с образец если вы знакомый с функциональный язык такой как f вы мочь быть немного разочаровать этот возможность в она текущий вид но даже сегодня она мочь упростить ваш код в самый разный сценарий каждый новый возможность чреватый опасность для разработчик работать в критический для производительность приложение новое уровень абстракция хороший но для тот чтобы эффективно использовать они вы должный знать что происходить под капот сегодня мы собираться изучить внутренность сопоставление с образец чтобы понять как это реализовать язык c ввести понятие образец который мочь использоваться в is выражение и внутри блок оператор существовать 3 тип шаблон is выражение мочь проверить равно ли значение константа а проверка тип мочь дополнительно создавать переменный образец я найти несколько интересный аспект связанный с сопоставление с образец в is выражение сначала проверить один два случай один оператор вводить переменный и переменный видный внутри всего метод это разумно но усложнить логика если другой if оператор в тот же блок быть пытаться повторно использовать один и то же имя ещё раз в это случай вы использовать другой имя чтобы избежать коллизия переменный ввести в is выражение полностью определить только тогда когда предикат являться это означать что переменный в второе оператор не определить в право операнд но поскольку этот переменный уже объявить мы мочь использовать она как переменный в метод три аспект упомянуть выше являться наиболее важный рассмотреть следующий код в большинство случай is выражение преобразоваться в даже если спецификация говорить что должный использоваться для примитивный тип этот код вызывать 2 упаковка boxing который мочь весьма серьёзно повлиять на производительность если они использоваться в критический путь приложение когда то выражение так же вызывать упаковка сантиметр и я надеяться что текущий поведение так же быть исправить в скорый время вот соответствующий на гитхаб если переменный иметь тип то привести к один выделение память для упаковка литерал хотя подобный код на основа switch не приводить к выделение память образец являться частное случаем образец тип с один ключевой отличие образец быть соответствовать любой значение даже если значение равно когда не но всегда компилятор знать о это и в режим release полностью удалять конструкция if и просто оставлять вызов консольный метод к сожаление компилятор не предупреждать что код недостижимый в следующий случай надеяться это тоже быть исправить непонятно почему поведение отличаться только в режим release но я думать что весь проблема иметь один природа первоначальный реализация фич неоптимальна но на основа нил gafter это измениться плохой код соответствующий сопоставление с образец переписываться с нуль для поддержка рекурсивный шаблон тоже я ожидать что большинство улучшение который вы искать здесь быть бесплатный в новый код отсутствие проверка на делать этот случай очень особенный и потенциально опасный но если вы знаете что именно происходить вы мочь найти этот вариант сопоставление полезный он можно использовать для введение временной переменный внутри выражение есть другой случай который я найти очень полезный образец тип соответствовать значение только если значение не равно мы мочь использовать этот фильтровать логика с оператор чтобы сделать код более читабельный обратить внимание что один и тот же шаблон мочь использоваться как для тип значение так и для ссылочный тип c 7 расширять оператор для использование образцов в блок в пример показать один набор изменение в оператор switch в последний блок показать ещё один возможность добавить в c 7 называть шаблон имя являться специальный и сообщать компилятор что переменный не нужный шаблон тип в предложение требовать имя переменный и если вы не собираться она использовать то вы мочь она проигнорировать с помощь следующий фрагмент показывать ещё один особенность сопоставление с образец на основа возможность использование предикат мочь иметь более один блок с один и тем же тип в это случай компилятор объединять весь проверка тип в один блок чтобы избежать избыточный вычисление но нужно иметь в вид два вещи

