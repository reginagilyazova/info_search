исследование кортеж в c 7 josefdzeranov тип быть ввести в net 4 0 с два существенный недостаток чтобы решить этот проблема в c 7 представить новый возможность язык а также новое семейство тип сегодня если вы нужно склеить два значение чтобы вернуть они из функция или поместить два значение в хэш набор вы мочь использовать тип и создать они с помощь удобный синтаксис тип представить в net framework 4 7 но вы мочь использовать они в более ранний версия фреймворка в это случай вы нужно добавить в проект специальный пакет nuget мы скоро увидеть что это не всегда так отсутствие пользовательский имя делать тип не очень полезный я мочь использовать как часть реализация небольшой метод но если я нужно передать он экземпляр я предпочитать именовать тип с описательный имя свойство кортеж в c 7 довольно элегантно решать этот проблема вы мочь указать имя для элемент кортеж и в отличие от анонимный класс этот имя доступный даже в разный сборка компилятор c генерировать специальный атрибут для каждый тип кортеж использовать в сигнатура метод атрибут tupleelementnamesattribute являться специальный и не мочь использоваться непосредственно в код пользователь компилятор выдавать ошибка если вы попытаться он использовать данный атрибут помогать ide и компилятор видеть имя элемент и предупреждать если они использоваться неправильно у компилятор более высокий требование к унаследовать член обычный аргумент метод мочь быть свободно изменить в переопределенный член но имя элемент кортеж в переопределенный член должный точно совпадать с имя из базовый тип c 7 1 появиться один дополнительный усовершенствование вывод имя элемент кортеж аналогичный тот что c делать для анонимный тип кортеж являться изменяемый значимый тип мы знать что изменяемый значимый тип считаться вредный вот небольшой пример они злой природа если вы запустить этот код вы получить бесконечный цикл список list enumerator это изменяемый значимый тип а свойство это означать что возвращать копия исходный итератор на каждый итерация цикл вызывать бесконечный цикл но изменяемый значимый тип опасный только тогда когда дать смешиваться с поведение enumerator содержимый состояние текущий элемент и иметь поведение возможность продвижение итератор путём вызов метод этот комбинация мочь вызывать проблема потому что легко вызвать метод на копия вместо исходный экземпляр что приводить к эффект no op no operation вот набор пример который мочь вызвать неочевидный поведение из за скрытый копия тип значение кортеж обладать состояние но не поведение поэтому привести выше проблема к он не применимый но один проблема с изменчивость весь же оставаться кортеж являться очень полезный в качество ключ в словарь и мочь использоваться в качество ключ благодаря семантика значение но не следовать изменять состояние переменный ключ между различный операция с коллекция несмотря на то что язык c обладать специальный синтаксис для создание экземпляр кортеж деконструкция являться более общий возможность и мочь использоваться с любой тип разбор деконструкция кортеж использовать подход утиный типизация если компилятор мочь найти метод для данный тип экземплярный метод или метод расширение тип являться разбирать после тот как вы начать использовать кортеж вы быстро понять что хотеть повторно использовать тип кортеж с именовать элемент в несколько место исходный код но с это не весь так просто в один c не поддерживать глобальный псевдоним для задать тип вы мочь использовать 'using' alias директива но она создавать псевдоним видимый в один файл в второе вы даже не мочь использовать этот возможность совместно с кортеж сейчас на github в тема идти обсуждение этот проблема поэтому если вы обнаружить что использовать один тип кортеж в несколько место у вы есть два вариант либо копировать в тип по весь кодовый база либо создать именовать тип pascal case например или camel case например с один сторона элемент кортеж должный следовать правило именование для публичный член том е но с другой сторона кортеж это просто хранилище для переменный а переменный именоваться с вы мочь использовать следующий подход но я предпочитать использовать camelcase весь время я найти кортеж очень полезный в повседневный работа я нужно большой один возвращать значение из функция или я нужно поместить пара значение в хэш набор или я нужно изменить словарь и сохранить не один значение а два или ключ становиться более сложный и я нужно расширить он другой поль я даже использовать они чтобы избежать аллокация замыкание с помощь такой метод как который теперь принимать дополнительный аргумент и в многий случай состояние также являться кортеж этот фич очень полезный но я действительно хотеть увидеть несколько улучшение я знать что этот функция спорный но я думать что это быть очень полезно мы мочь дождаться тип но я не уверенный быть ли запись значимый тип или ссылочный типами

