vdom свой рука pnovikov привет у многий frontend разработчик бытовать мнение что технология vdom который в частность использоваться в react js работать как чёрный ящик так же на простор npm есть куча библиотека реализовать этот технология однако вот как по я так в они черта нога сломить сам тема vdom а я заинтересовать некоторый время назад и я начать экспериментировать наощупь сам в конечный итог весь кончиться тем что я сделать свой реализация vdom а и встроить в свой фрейморк для датагрид о наш метр я как нибыть написать это оказаться не просто а очень просто и в этот статья я детально объяснить что к что зачем и почему и как оно работать тоже рассказать нырять под кат и мы предаться интересный опыт я не фронтенд разработчик не бейт я тапка так же не стоить писать взять готовый фреймворк дубина я знать о тот что есть готовый фреймворка но я нужный собственный реализация по ряд сугубо технический причина на хабра но объяснение суть дело в она я не нравиться поэтому давать я на палец раскидать итак положим у вы есть веб страничка ага в она отрисовать некий html элемент вероятно довольно большой чтобы немного добавить контекст сказать что этот элемент отрисовать посредством натягивание шаблон на вить модель ну весь пользоваться фреймворка который делать подобный ведь так handlebars там lodash шаблон angularjs в какой то мера и вот короче представить что модель на который натягиваться шаблон поменяться и вы надо отрисовать этот изменение внутри html элемент возникать вопрос а как это сделать и при это не попасть впросак тут как водиться есть несколько вариант можно прогнать модель дать через шаблонизатор получить html и просто сделать дёшево и сердито но для некоторый задача вполне прокатывать что же здесь ужасный спросить вы а я вы ответить этот вариант плохой прежде всего потому что весь дочерний элемент расположить внутри быть беспощадно убитый браузер и заменить новый следовательно да следовательно вы потерять весь подписка на событие в рамка ваш элемент конечно же который у вы быть вы прийтись переподписывать вновь создать элемент заново тут я честно признаться не в курс как работать сборка мусор в разный js движок но допускать что если ранее в свой код вы сохранить какой то из дочерний элемент например в переменный то этот элемент быть убрать из дерево но не уничтожить привет утечка память мы по ты скучать ну это если предположить что браузер использовать для dom элемент reference counting например кто знать подробность отписать в комментарий пожалуйста окромя это сеять вариант дюже медленный особливо когда дочерний элемент много то есть браузер честно стереть весь что быть отрисовать внутри элемент пересчитать и перерисовать заново вот представить нарисовать у вы карточка пользователь гриша в который 100 разный полый а у вы в дать измениться только дата рождение и что теперь весь фигня гриша давать по новый ради один несчастный кусок текст убить гриша целиком посчитать и нарисовать заново а вы знаете что перерисовка интерфейс в браузер это вообще то долго и если гриша состоять из 150 элемент то ещё куда ни идти а вот если из тысяча вскрытие показывать у гриша обилие мелкий деталь то на отдельный машина перерисовка мочь достигать несколько секунда что дюже снижать отзывчивость интерфейс ну и самый печальный через innerhtml отрисовываться не весь элемент как пример в ie8 у элемент в google chrome через innerhtml плохо рендериться заголовок таблица весь что вы туда вставить через innerhtml быть урезать до обычный текст по неведомый я причина пруфлинк не быть информация из собственный опыт вероятно сейчас это уже починить но осадочек остаться такой образ innerhtml как быстрый и грязный хак ненадёжный в общий случай иметь куча сайда эффект да и вообще мы тут не в 9 класс школа чтобы так писать из плюс реализоваться на коленка откровенно говорить этот вариант решать только последний и самый печальный проблема innerhtml крайний привередливость в создавать элемент но упомянуть он определённо стоить в многое потому что он мы понадобиться для реализация vdom как оно работать да просто работать парсито html и вызывать для каждый узел с последующий установка атрибут потом делать и проходиться по получить элемент вызывать ну в один мы не решить проблема с убиение элемент в второе с парсеринг html вс не так гладко в это мир парсить html это примерно как парсить xml документ и в парсер для клиентский сторона чаща всего употребляться поточный парсер дада это примерно как доказать что употребление поточный парсер xml полезно для здоровье почему да потому что работать быстро и писаться легко не стоить использовать для этот задача классический древесный парсер как для xml оно тут просто не нужно весь в мир html парсер хорошо кроме один нету они бедняжка встроить в браузер в mdn однако он весь ещё экспериментальный и видимо отдать вы на выход дерево ну вот только обходить дерево и вызывать мы на сторона клиент то и не хватать ага слово странный он давать не быть он трогать есть событийный поточный парсер но я сам он не пользовать ибо как идеология мой фреймворка не позволять я использовать сторонний зависимость и вот есть пожалуйста воспринимать он в отрыв от jquery где он объяснуть вс на палец и давать код простенький парсер я он не нравиться тем что работать на регулярный выражение видеть сей зело трудозатраный однако вполне работоспособный долгий время у я каяться использоваться как раз код из этот статья переработать под typescript однако потом я заменить он на поточный парсер на простенький state машина кой я с вы сегодня и поделиться даба минимизировать сравнение строка и сделать поддержка создание виртуальный элемент что в пример джон запиливать быть несколько неудобно и вот мы наконец подойти к самый хитрый подход который решать проблема как с производительность так и с привередливость innerhtml к элемент а именно использовать парсер html мы мочь внезапно распарсить наш html но вызывать для каждый элемент не а просто создание какой либо объект который быть хранить имя тег и атрибут этот самый объект и быть называться а они совокупность или vdom здесь стоить отметить что создать тысяча объект в js через это быстро очень быстро а вот создать тысяча реальный dom узел это медленно из это обстоятельство собсный и проистекать прирост производительность окей создать и что же мы быть с это добром делать штаны можно не снимать а вот бегать прийтись мы быть структура наш vdom дерево с тем что уже отрисовать составлять из это некий подобие diff патч что надо доабвитя что убрать куда докинуть атрибут где поменять контент и накатывать он на существующий dom дерево вот прям так же как это происходить в ваш любим git в время мерджей благо задача построение diff а в программирование довольно известный гуглиться внезапно по слово решаться она динамический программирование алгоритм иметь квадратичный сложность в хороший вуз решение этот задача изучать на один курс но здесь я он тезисный описать и подсказать как адаптировать он под дерево в итог vdom подход не убивать тот элемент дерево который не измениться и не созд том лишний элемент что знатно экономить память и сохранять подписка на событие если элемент не уничтожаться одновременно заставлять ваш cpu большой заниматься сравнение нежели создание html элемент а это да том знатный прирост производительность когда из 1000 элемент на экран измениться только один мы написать небольшой приложение который быть состоять из слева в который вы быть вбивать и или изменять свой html а в окошко справа видеть результат работа никакой дополнительный библиотека только typescript и браузер быть что называться творить магия из воздух вы знаете сначала я хотеть добавить в этот статья много код с построчный разбор оный но памятовать свой предыдущий статья не решиться это делать непосредственно код снижать читаемость и нагонять тоска так что с ваш позволение я просто быть давать ссылка на github и объяснить как и что работать наш vdom быть состоять из тр х главный компонент парсер html непосредственно компаратор и калькулятор батч а так же который собер том это вс добро вместе и заставить работать тут надо сделать оговорочка как я понимать react js работать без парсер html в вид тот что он шаблон jsx tsx уже собираться в соответствующий вызов создание нод это хороший ход улучшать быстродействие но вы знаете создавать свой язык шаблонизация и писать для он компилятор не входить в мой план когда я писать этот статья так что мы быть парсить голый html рука такой реализация гарантировать мы возможность встраивать наш поделка куда угодный ну и позволить избежать чисто педагогический курить зов если вы понимать о число метр я итак поехать javascript не содержимый эффективный инструмент для работа с стек а таковой мы понадобиться поэтому делать без комментарий как вы знаете с точка зрение javascript html документ состоять из нод некоторый из который вполне себя являться html элемент такой как htmlinputelement тег htmldivelement тег а некоторый нет текст комментарий весь доступный тип нод перечислить мы же начать с простой объявить интерфейс том наш конструктор нод чтобы не вхардкоживать в наш парсер html я вызов и использовать один и тот же парсер что для dom что для vdom в мой реализация он выглядеть как видеть мы ограничиваться три тип нод html элемент текст контент и комментарий интерфейс крайне простой и предусматривать возможность создание весь три тип нод а для html элемент ещ и установка аттрибут чтобы далеко не отходить от касса тут же реализовать он для реальный html нод тут же мы продумать как мы быть хранить vdom нода что мы важный знать о нода помимо е тип в случай с html элемент тег да атрибут в случай с комментарий и текст контент плюс к весь прочее мы так же важный список дочерний нод отлично описывать интерфейс и для тип после что реализовать сам конструктор парсер это у мы быть такой штука у который есть ограниченный число она ида том по передать она html символ за символ и в зависимость от текущий символ менять сво состояние при переход из состояние в состояние парсер быть далее ргать метод конструктор нод выполнять соответствующий действие например читать парсер символ никто не трогать оп встретить запоминать где он увидеть менять состояние на слушать внимательно сейчас быть html тег читать далёкий оп встречать пробельный символ и такой ага вот оно и имя тег вспоминать где встретить выгрызать текст оттуда до текущий позиция вот вы и имя тег стать быть надо дёрнуть нод конструктор и вызвать у он передать имя тег далёкий парсер пропускать весь пробельный символ и если видеть то переходить в изначальный состояние а если видеть буква алфавит так же ловить имя атрибут значение атрибут в кавычка дёргать нод конструктор ну и так далее пока не дойти до конец создать тег мы быть хранить в стек каждый раз когда мы доходить до открывать тег клад метр он в стек при создание элемент через конструктор указывать текущий макушка стек как родительский элемент тривиальный уверенный весь хоть раз да делать нечто подобный когда писать калькулятор на один курс университет весь состояние а так же действие при переход мы сложить в который технически представлять из себя огромный hash объект вид состояние описание действие описание действие в наш случай состоять из тр х часть я объединить этот три функция в штука который назвать там же я описать весь возможный состояние парсер сделать снабдить он несколько полезный тестер функция это когда мы смотреть какой у мы символ текущий что быть n символ назад складываться ли следующий за текущий m символ в такой то слово ну и иже с они особливо выделяться функция когда мы менять состояние парсер она запоминать позиция текущий символ с тот мысль чтобы сдвинуться на несколько символ далее мы мочь выгрызть кусок текст между запомнить позиция и текущий положение выгрызание кусок текст от запомнить позиция до текущий производиться функция обычно после вызов state машина подавать парсер вроде о смотреть открывать тег поймать вот он имя почему так сложно ну я человек экономный сделать парсер который не создавать лишний строка без необходимость ну и собственно далёкий я просто перечислить весь возможный состояние парсер и весь возможный действие что называться там есть много нюанс связанный с кавычка вокруг атрибут самозакрывающийся тег символ и в имя атрибут разрешить я опустить здесь детальный разжевывание каждый из этот кейс вс есть в код при желание вы сам это увидеть ещ один особенность тег и парсер вырезать и складывать отдельно даба пользователь парсер сам решить что с они далёкий делать можно например сделать у скрипт а вот что делать с стиль вопрос неясный даже для я единственный что не учесть в мой реализация это хитрый возможный структура этот тег скажем если в е у вы встречаться текст в дух то парсер по ошибка распознать оный как закрытие тег что неприятно однако легко чиниться итак на текущий этап мы иметь годный html парсер который можно передать кусок html я и распарсить он в реальный dom элемент или же в vdom элемент это просто прекрасно теперь представить что у мы уже отрисовать на экран какой то html мы хотеть он незначительно поменять бер метр он вносить корректив скармливать парсер с vdom конструктор получать список vdom нод теперь мы надобный высчитать разница между html есть который отрисовать на экран и тем что мы напарсила наш парсер по суть дело надо взять parent нод внутри который отрисовать наш html взять массив весь он ребёнок и сравнить он с аналогичный массив виртуальный ребёнок который мы создать html парсер и когда я говорить сравнить я иметь в вид не просто ответить на вопрос совпадать или нет но и сгенерировать том наш update batch список какой элемент куда надо добавить а какой откуда удалить чтобы из старое кусок дерево получить новое после что получить пачка изменение просто накатываться на уже отрисовать html не уничтожать уже отрисовать и неизмена нной но умно менять только затронуть нода называться этот операция вот как то так но о вс метр по порядок для начало надо научиться сравнивать html нода и vdom нода делаться это относительно просто как можно заметить каждый раз с нуль сравнивать нода это трудозатратный в многое из за рекурсия на 5 шаг поэтому я сделать кэш компаратор который жить в рамка один update а и хранить результат сравнение нод друг с друг такой образ если тот факт что два нода разный уже когда то быть установленный то он не устанавливаться заново а браться из кэш это сокращение от longest common subsequence по суть представлять себя матрица для решение lcs задача метод динамический программирование мы он да метр на вход два массив один из реальный нод другой из виртуальный так же скармливать кэш сравнение про который я рассказать выше далёкий вызывать и получать массив который по суть говорить что надо сделать с такой то по счёт нода обновить удалить или вставить другой и какой именно нода перед она один дело после вызов lcs урезать одинаковый элемент с начало и с конец массив функция далее на остаться дать стояться матрица динамический программирование затем оный обходить определять какой нода надо а какой тоже описать в видео обратить внимание что на это этап мы не получать список нод который надо результат содержимый только удаление добавление но но удаление добавление нода в один и то же место или добавление удаление это и есть операция как раз и делать что схлопывать ряд стоящий добавление удаление в один операция переформатировать первичный массив batch entry ева получить результат наконец можно вернуть счастливый пользователь lcs и есть самый сложный в vdom е из за что многий он кажется страшный магия как видеть сам алгоритм что называться tricky но вполне себя понимать сложность он кстати квадратичный но бояться нечего если изменение относительно мало и они где то в середина пачка элемент большинство отсекаться на стадия и в результат матрица динамический программирование нечасто превышать по размер 3x3 конечно же если ваш пользователь не перерисовывать 10 тысяча кнопочка стоящий друг под друг на практика такой случай происходить редко так что иметь смысл не строить lcs матрица если у вы 2 или 1 элемент а обработать результат рука гораздо чаща в реальный жизнь встречаться большой вложенность элемент если на то пошло но однако недостаточный чтобы сорвать стек вызов в js у мы далёкий быть рекурсивный обработка вот так и живой метр не знать возможно тот же react js пойти ещ далёкий в оптимизация это процесс я он исходник не читать кто знать отписаться весь мой задача же вписываться в означенный ограничение с огромный запас наконец писать метод update который заменять потомок выбрать мы parent элемент через lcs сравнение на получить от html парсер массив виртуальный нод тут мы очевидно понадобиться штукенция который превращать виртуальный нода в реальный без комментарий и создать кэш сравнение заранее сам update брать потомок parent а брать массив vdom нод создавать lcs получать update batch меланхолично проходить по он собирать весь кто надо добавить в один массив весь кто надо удалить в другой весь кто надо обновить сначала обновлять список аттрибут несложный функция а потом рекурсивный применять тот же самый метод update который мы в настоящий момент и описывать предварительно достать массив потомок из vdom нода донор в итог весь кто надо добавить прогонять через материализатор делать весь кто надо удалить делать упражнение закончить для дебаг я ещ добавить функция который выводить в консоль содержимое update batch а однако на практика е вывод несколько сложный для понимание создавать создавать из который и задействовать наш прекрасный наработка для демонстрация вы прочесть статья о тот как устроенный vdom надеяться после такой экскурс у вы появиться большой понимание зачем оно надо и как оно устроить исчезнуть страх перед неизвестный и вы быть немного большой ориентироваться в происходить внутри модный js фреймворок кома то возможно понравиться компактный html парсер забирать я не возражать весь спасибо за прочтение комментарий приветствуются

