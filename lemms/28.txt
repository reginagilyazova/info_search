rust вектор это значение bmusin в последний время я долго думать над персистентный коллекция и в особенность над тем как они относиться к rust хотеть поделиться с вы свой наблюдение о тот как устроить персистентный вектор быстрый ли они традиционный коллекция смотреть под кат обычно персистентный коллекция считаться необычный способ работа с коллекция вместо тот чтобы добавлять элемент посредством что увеличивать вектор не создавать новый экземпляр вы вызывать метод который оставлять исходный вектор на свой место и возвращать важный заметить что не меняться дать особенность хорошо вписываться в функциональный язык хорошо применяться это и в написание многопоточный програм не быть вдаваться в подробность какой то конкретный решение но большинство из они реализовать на какой либо вид дерево например иметь вектор вид вы мочь сохранять элемент не в один большой блок а в вид дерево лист который являться значение на следующий диаграмма набор значение поделить на два дочерний узел на который указывать родительский узел а теперь представить что мы хотеть поменять один из значение в вектор например мы хотеть поменять на это означать что мы должный изменить правый узел оставлять при это левый узел нетронутый после это мы должный быть пересоздать родительский узел который быть ссылаться на новый правый узел в сбалансированный дерево операция добавление в персистентный вектор стремиться к o log n мы должный склонировать некоторый лист и изменить он после это мы должный скопировать и изменить весь родительский узел на путь до корень несколько замечание в некоторый случай персистентный коллекция давать возможность писать более лёгкий для понимание код это потому что они выступать как обычный значение и не являться уникальный посмотреть на этот работать с число js код если мы менять мы ожидать что не поменяться это потому что явлиться простой значение однако если мы быть использовать массив теперь когда я менять переменный тоже меняться возможно что я это нужно а возможно и нет вещий становиться более запутанный когда вектор находиться внутри объект не понять я неправильно часто бывать удобно когда и являться один и тем же вектор и изменение один быть отразить на друг однако иногда это не то что вы нужно я часто замечать что использование персистентный коллекция позволять сделать мой код чистый и лёгкий для понимание если вы видеть один из мой выступление по то знаете что в они быть упор на следующий особенность дизайн rust простой говорить когда у вы иметься два указатель на один и тот же участок память как и в прошлое пример тогда изменение дать через один из указатель чреватый опасность гонка особенно ярко это проявляться в rust когда вы хотеть обойтись без сборщик мусор ибо при сборщик мусор неизвестно сколько указатель ссылаться на участок память ибо дейстие подобный мочь затронуть большой объект чем вы предполагать порождать баг в частность но не исключительно при одновременный работа несколько поток что же произойти в rust если вы захотеть получить доступ к один вектор через два отдельный указатель давать вернуться к javascript пример но теперь спроецировать они на rust один пример работать так же как и на js однако два пример с вектор не скомпилироваться проблема в тот что как только мы сделать владение значение быть передать другой переменный поэтому она не смочь большой использоваться это вести мы к следующий вывод обычный коллекция rust' который мы использовать каждый день даже большой так делать люба тип в rust не использовать или если ваш код компилироваться вы знаете что ваш вектор не доступный для изменение через разный указатель вы мочь заменить он число и оно быть вести себя так же например я написать реализация персистентный вектор библиотека библиотека предоставлять тип который основать на если вы посмотреть на метор который доступный у вы увидеть что они самый обычный и том далее вот один из пример использование тем не менее являться персистентный структура дать который реализовать как содержимый внутри себя потокобезопасный счётчик ссылка который ссылаться на внутренний дать когда вы вызывать то мы обновлять так что теперь он быть ссылаться на новый вектор оставлять старый на свой место очень крутой метод он проверять значение счётчик если оно равно 1 то давать вы исключительный доступ к содержимое с возможность изменение если же значение счётчик не равно 1 тогда метод склонировать и он содержимое на место и дать вы изменяемый ссылка на этот клон если вы помнить как работать персистентный структура дать то дать ситуация очень удобный для обновление дерево при обход это позволять вы избежать клонирование в тот случай когда на структура дать ссылаться только один ссылка главный отличие между и лежать не в поддерживать операция а в тот когда вы вызывать у это o 1 когда вы клонировать это o n у этот оценка сложность переставить требовать o log n а клонирование o 1 разумеется когда вы вызывать на он быть клонировать часть дать перестраивать затронуть часть дерево в то время как обычно просто писать в конец массив однако этот нотация как весь знать говорить только о асимптотический поведение один из проблема с который я сталкиваться при работа с быть то что довольно сложно соревноваться с стандартный в скорость часто копирование набор дать бывать быстрый чем обновление дерево и выделение память я понять что вы должный приложить много усилие для тот чтобы обосновать использование например вы много раз клонировать вектор и они содержимый в себя большой объ метр дать конечно производительность это ещ не вс если вы много раз клонировать вектор то должный использовать маленький память ибо мочь использовать общий часть структура дать я попытаться показать как система владение в rust предлагать сплав функциональный и императивный стиль посредством использование персистентный коллекция когда вы присваивать один вектор другой вектор если вы хотеть сохранить исходный вектор мы должный c ировать он что делать новый вектор независимый от старое мой наблюдение не новый в 1990 год фил вадлер phil wadler написать статья в который он выдвигать тот же утверждение хотя и с несколько другой сторона он говорить что вы мочь предоставлять персистентный интерфейс например метод который возвращать новый вектор однако если вы использовать линейный тип вы мочь реализовать это как императивный структура дать предоставлять и никто о это не узнать играться с я понять что очень удобно иметь персистентный вектор который предлагать такой же интерфейс как и обычный например быть очень легко изменить основать на вектор библиотека так чтобы она работать в использовать или в императивный режим использовать простой говорить идея в тот чтобы скрывать использовать тип под единообразный интерфейс отвлекаться от основной тема сказать что я хотеть бы видеть некоторый экспериментальный исследование скажем быть бы удобно иметь вектор который бы преобразовываться в персистентный после достижение определённый длина я думать что есть ещё один причина для тот чтобы кто то целенаправленно заняться персистентный коллеция в то время как одновременный предоставление доступ и изменяемость мочь представлять опасность иногда это бывать очень нужно хотя в rust это сейчас неудобно я считать что мы должный исправить текущий положение вещий так же у я есть некоторый мысль на этот счёт который я хотеть отложить до следующий статья rust уже иметь персистентный коллекция клонирование который однако неэффективно

