научиться перехватывать необработанный сообщение или пример тот как sobjectizer обрастать новый фичами eao197 мы очень приятно когда в добавляться новое возможность возникнуть в результат подсказка и или пожелание пользователь sobjectizer а хотя далеко ведь с один сторона у мы как у команда разработчик и старое пользователь sobjectizer а уже есть собственный стереотип о тот как sobjectizer принять использовать и не всегда получаться сразу оценить свежий взгляд с сторона понять что реально хотеть видеть пользователь в фреймворка и почему он не удовлетворить иметься средство с другой сторона sobjectzer не такой уж и маленький фреймворк добавление новый возможность требовать определённый осмотрительность нужно чтобы новый функциональность не конфликтовать с уже иметься фичами и тем более чтобы после добавление что то новое не сломаться то что уже есть и давно работать плюс к тот у мы есть пунктик по повод сохранение совместимость между версия sobjectizer а поэтому мы сильно против кардинальный изменение в общий добавление новое в sobjectizer это всегда приятно с точка зрение увеличение возможность фреймворка и повышение удобство он использование но далеко не всегда это так же приятно и просто с точка зрение реализация под кат небольшой рассказ о тот как в sobjectizer добавляться один новый фич мочь быть кома то из читатель быть интересно посмотреть как старый фреймворк адаптироваться под запрос новый пользователь итак весь начаться с тот что один из пользователь sobjectizer а обратить наш внимание на то что в sobjectizer нет готовый удобный средство для выполнение эпизодический однократный взаимодействие между агент оказаться что иметься в вид вот что допустить агент a хотеть отослать запрос агент b и хотеть получить ответный сообщение от агент b но при это агент a не хотеть ждать ответ долгий чем 5 секунда тривиальный решение в лоб который сразу же приходить в голова мочь выглядеть так к сожаление этот простой версия лишь являться наглядный демонстрация правдивость афоризм о тот что любой сложный задача иметь простой лёгкое для понимание неправильный решение здесь есть сразу несколько проблема один проблема связать с отложить сообщение a reply_timed_out если ответ от агент b вовремя не прийти то с reply_timed_out у мы весь нормальный мы он получать обрабатывать и забывать о немой а вот что быть если ответ от агент b прийти вовремя что произойти с reply_timed_out оно весь равно прийти к агент a ведь никто reply_timed_out не отменять значит как только нить таймер sobjectizer а отсчитать 5 положить секунда сообщение reply_timed_out быть доставить агент a и мы он получить и обработать не смотреть на то что мы оно уже не нужно что неправильно правильно быть бы сделать так чтобы сообщение reply_timed_out к мы не попадать после тот как мы получить reply от агент b самый надёжный способ сделать это это отменить подписка на reply_timed_out почему именно так это тема отдельный большой разговор если кома то интересно можно отдельно поговорить на этот тема пока же ограничиться тем что отписка от отложить сообщение являться железобетонный вариант решение проблема с отложить сообщение два проблема связать с тем что вряд ли агент a нужно быть подобный образ общаться только с агент b скорее всего агент a обмениваться сообщение request reply сразу с несколько агент соответственно когда request улетать одновременно агент b и c то агент a нужно как то понимать от кто прилететь ответ или чей ответ не быть получить в течение 5 секунда два проблема более менее удобно решаться за счёт отказ от использование собственный mbox а агент a в качество обратный адрес простой создавать новый mbox для каждый новое взаимодействие и именно этот новый mbox быть использоваться и для получение ответ и для отложить сообщение именно для это запрос однако как только мы вводить новый mbox мы должный позаботиться о тот чтобы mbox быть удалённый после тот как он переставать быть нужный для это мы должный удалять подписка на этот mbox если подписка не быть удалить то mbox остаться жить а это привести к постоянный рост потреблять память мы же быть создавать новое mbox ы на каждый новый запрос а удаляться этот mbox ы не быть в общий если учесть этот два проблема то простой решение быть преобразовать в не очень простой получаться уже не так просто и компактно как хотеться бы но и это ещё далеко не весь так в это решение нет никакой exception safety нет явный отмена отложить сообщение тогда когда оно уже не нужно но что ещё важный если агент a захотеть иметь не один дефолтной состояние как в пример выше а несколько состояние в каждый из который он нужно реагировать на сообщение по разный то весь стать ещё страшный ну и ещё страшный весь стать если обмен между a и b быть требовать не один ответный сообщение а несколько скажем если вместо reply быть successful_reply и failed_reply то объесть работа для разработчик агент a заметно увеличиться маленький отступление в сторона когда мы стать понятно о чем мы говорить мы сам удивиться ведь проблема действительно очевидный но почему же мы сам с она не сталкиваться по крайний мера не сталкиваться настолько часто чтобы обратить на нея внимание и включить решение для этот проблема в sobjectizer вероятно здесь иметь место два фактор в один мы довольно быстро там количество агент невеликий между они установить стабильный связь поэтому там такой проблема нет в принцип в второе наверное однократный разовый взаимодействие у мы чаща всего применяться между коротко жить агент и для агент который жить всего лишь для обработка один единственный операция этот проблема не актуальный как бы то ни быть невозможно не отметить тот факт что как только твой инструмент начинать пользоваться новое человек так сразу же выясняться что они хотеть использовать инструмент совсем не так как привыкнуть это делать ты сам в итог мы расширить свой надстройка над sobjectizer под название добавить в нея поддержка том наш посредством асинхронный операция привести выше пример мочь быть переписать следующий образ дробный о новый асинхронный операция в so_5_extra можно прочитать но речь сегодня пойти не о тот как сделать сам асинхронный сообщение а о тот что потребоваться сделать в sobjectizer для тот чтобы асинхронный сообщение заработать в so_5_extra в so_5_extra войти два реализация асинхронный операция time_unlimited когда на время выполнение операция не накладываться вообще никакой ограничение и time_limited когда операция нужно завершить за отвести время выше как раз речь идти именно о time_limited операция том к именно с они реализация и быть один из основный загвоздка быть в тот что когда мы начинать time_limited операция то мы должный обязательно получить и обработать отложить сообщение который и ограничивать время асинхронный операция и вот с это обязательно как раз то быть не весь просто дело в тот что один из ключевой фич sobjectizer а являться состояние позволять агент обрабатывать разный набор сообщение в каждый из состояние или же обрабатывать один и тот же сообщение в разный состояние по разный но есть и оборотный сторона если какой то сообщение нужно обработать в весь состояние то нужно явно подписывать обработчик это сообщение для каждый из состояние том е писать что то вроде естественно что это не самый хороший и удобный решение за счёт использование возможность иерархический конечный автомат можно сделать простой удобный и надёжный теперь обработчик по умолчание быть вызваться вне зависимость от тот в какой из состояние находиться агент но к сожаление такой подход требовать чтобы агент изначально быть спроектировать с использование иерархический конечный автомат вряд ли асинхронный операция из so_5_extra быть бы удобно пользоваться если бы они накладывать столь жёсткий требование на пользователь мол хотеть пользоваться асинхронный операция изволить создать в свой агент родительский состояние да и не всегда это в принцип возможно сделать допустить кто то написать вы библиотека агент в который есть базовый тип basic_device_manager вы делать свой собственный класс наследний my_device_manager и вы в my_device_manager нужно использовать асинхронный операция если в basic_device_manager разработчик не сделать что то вроде st_parent то вы туда свой st_parent уже не добавить в общий требоваться сделать что то что позволить бы ловить сообщение который адресоваться агент но который агент не быть обработать такой сообщение ещё иногда называть мы сделать так что теперь разработчик мочь повесить собственный обработчик на сообщение который не быть обработать нормальный обработчик например теперь если агент получать сообщение some_msg из почтовый ящик some_mbox находиться в состояние st_first то для обработка сообщение быть вызвать normal_handler а вот если агент быть находиться в любой друг состояние то для обработка это сообщение вызваться deadletter_handler этот фич как раз и использовать time_limited операция при активация операция вешаться deadletter_handler на сообщение о истечение тайм аут и в какой бы состояние агент не находиться в момент приход это сообщение сообщение быть получить и обработать что и позволять завершить асинхронный операция даже в случай когда разработчик ошибиться и не определить весь нужный он обработчик тайм аут один мысль который возникнуть как только сформулироваться проблема deadletter handler ов быть в тот чтобы снабдить каждый агент некий родительский состояние а весь остальной состояние чтобы автоматически становиться дочерний к он том е быть идея насильно впихнуть в каждый агент некий суперсостояние который просто есть и с это ничто не сделать этот идея быть очень привлекательный с точка зрение текущий механизм хранение и поиск подписка этот механизм не так уж и простой так же этот идея очень красивый с идеологический точка зрение иерархический конечный автомат как они есть но прийтись от нея отказаться мочь быть на время главный причина отказ в тот что объект state_t являться довольно таки тяжеловесный в зависимость от компилятор стандартный библиотека и параметр компиляция state_t в 64 х битовый режим мочь занимать от 150 до 250 байт если насильно добавлять суперсостояние каждый агент то вес каждый агент увеличиваться на полтора два сотня байт вот просто так на ровный место даже если это агент суперсостояние вообще не нужно быть да и есть на самый дело ещё и другой причина суперсостояние для каждый агент это слишком большой нововведение для sobjectizer а чтобы сделать он с бухта барахты не взвесить тщательно весь последствие есть у я лично большой подозрение на тема тот что стоить добавить суперсостояние в sobjectizer и они начать злоупотреблять в общий идея с суперсостояние в работа над версия 5 5 21 не пошлый но зарубка на память остаться возможно она ещё найти свой воплощение если у кто то есть соображение на этот счёт то интересно быть бы услышать и пообсуждать от идея с суперсостояние отказаться но текущий механизм хранение подписка весь таки менять не хотеться поэтому быть найти решение в который весь таки дополнительный объект state_t потребоваться но и весь агент ссылаться на он благодаря это удаться использовать тот же самый инструмент для регистрация deadletter handler ов и для они поиск фактически so_subscribe_deadletter_handler есть ни что иной как ну а поиск deadletter handler а для сообщение это всего лишь но не для текущий состояние агент а для это специальный невидимый состояние там правда есть для случай когда включить режим трассировка механизм доставка сообщение но это совсем уже скучный деталь когда я вычитывать этот статья перед публикация то ловить себя на мысль о тот что рассказываться какой то тривиальщина ну вроде бы весь просто и понятно только вот путь к это просто и понятно оказаться совсем не быстрый не прямая и не очевидный если кома то интересно то след эволюция идея асинхронный операция можно найти в этот минь серия блог пост и хотя как оказаться даже в заключительный пост этот серия быть описать отнюдь не результирующий решение прийтись ещё наткнуться на серьёзный собственный просчёт и поломать голова над тем как воспрепятствовать утечка память при наличие циклический ссылка между объект но это уже совсем другой история хотеться поблагодарить весь кто помогать мы развивать sobjectizer тем кто пользоваться so 5 и высказывать свой соображение и предложение отдельный спасибо здесь тем кто ещё не пользоваться so 5 но помогать совет и не только большущий благодарность в частность да и просто тем кома не лень ставить 1 в новость о sobjectizer на различный ресурс и звёздочка большой вы весь спасибо мы собираться начать работа над следующий версия sobjectizer а под номер 5 5 22 уже в ближний время главный новый фич который мы хотеть увидеть в 5 5 22 это поддержка параллельный состояние для агент агент уже мочь использовать продвинуть возможность иерархический состояние как то вложенность состояние shallow и deep history для состояние обработчик вход выход временной лимит на пребывание в состояние но вот что пока ещё в sobjectizer не быть так это параллельный состояние в свой время мы не стать они делать по какой то причина но практика показать что кома то из пользователь параллельный состояние нужный и облегчать имя жизнь так что быть они делать весь желающий приглашаться к обсуждение любой конструктивный соображение а особенно пример из практика и личный опыт быть мы очень полезный ну и вообще быть бы интересно узнать какой у вы впечатление о sobjectizer е что нравиться что не нравиться что хотеться бы иметь в so 5 что мешать ну и естественно мы готовый ответить на любой вопрос о sobjectizer е

