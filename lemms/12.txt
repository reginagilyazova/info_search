задействовать для простой тест наследование полиморфизм и шаблон почему бы и нет eao197 язык c сложный но он сложность проистекать из сложность задача который решаться с помощь c каждый фич который быть добавить в c быть добавить не просто так а для тот чтобы дать возможность справиться к какой то проблема ну а уж сочетание существующий в c фич делать язык чрезвычайно мощный инструмент конкретный пример тот как это происходить на практика и посвятить дать статья добавить ещё что один из мощный стимул к написание дать статья стать то что очень часто на глаз попадаться объёмный обсуждение на тема ооп не нужно и особенно шаблон дженерик на практика почти никогда не нужный я как далеко не молодой программист начинать в 1990 ом как раз с инструмент в который не быть ни ооп ни шаблон дженерик странно сталкиваться с подобный точка зрение но чем далёкий тем чаща с они сталкиваться особенно с сторона приверженец новый язык программирование вроде go или rust а сложно сказать чем это вызвать мочь быть человек перекормить ооп а это так и быть мочь быть задача за несколько минувший десятилетие сильно поменяться а это так и есть мочь быть и просто вот и вырасти поколение как бы то ни быть можно попробовать на пример из реальный жизнь показать что весь не так однозначно итак о чем пойти речь мы недавно выпустить новый версия свой opensource фреймворка где добавить и этот новый фич нужно быть протестировать совсем несложный тест в один тест нужно быть проверить что программист мочь установить deadletter handler в друг что пользователь мочь отменить deadletter handler тест простой но в они есть один сложность нужно быть проверять один и тот же функциональность в разный условие ну например deadletter handler мочь быть повесить на сообщение из разный тип почтовый ящик сообщение на который вешаться deadletter handler мочь быть обычный иммутабельный сообщение мочь быть обычный мутабельный сообщение мочь быть сигнал пояснить обычный сообщение отличаться от сигнал поэтому доставка сообщение отличаться от доставка сигнал сам deadletter handler мочь быть представить как указатель на метод класс агент так и лямбда функция а поскольку в sobjectizer код реализовать deadletter handler ы активно использовать шаблон то для проверка правильность работа шаблон нужно быть в тест покрыть весь разумный сочетание этот условие пояснить для тот кто не очень хорошо знак с особенность c если например шаблонный функция нигде в код не вызываться то некоторый компилятор вроде старое версия visual c даже не всегда проверять исходный код этот функция на наличие элементарный ошибка поэтому для тот чтобы быть уверенный что с реализация шаблон весь нормальный нужно чтобы шаблонный функция или класс быть проинстанциировать явно или неявно надёжный всего это достигнуть через явный использование шаблонный функция класс в тест конечно же есть очень простой решение который заключаться в тот чтобы создать собственный класс под каждый тестовый случай и выполнить весь соответствующий действие внутри это класс так для сочетание mpmc mbox обычный иммутабельный сообщение указатель на метод получиться бы такой класс а для сочетание mpmc mbox обычный иммутабельный сообщение лямбда функция потребоваться бы очень похожий класс но с небольшой изменение тогда как для случай direct_mbox обычный мутабельный сообщение лямбда функция изменение потребоваться бы большой но весь равно код быть бы довольно похожий надеяться идея понятный всего такой класс потребоваться бы десять штука что сразу же отбивать желание двигаться в это направление том к в такой количество копипаста очень легко ошибиться кстати говорить когда этот тест только появиться то быть забытый пара возможный тестовый случай но когда о это вспомнить то забытый сочетание буквально несколько строчка быть добавить в соответствующий тест а вот если бы прийтись создавать отдельный класс под каждый тестовый случай то для устранение первоначальный просчёт потребоваться бы большой код и внимание поскольку у я есть жёсткий пунктик по повод копипаста в код и неспроста то быть выбрать другой путь через использование шаблон и в один место шаблон шаблон к что затем ещё добавиться и наследование с полиморфизм но начать с простой тест в который достаточно только шаблон итак у мы есть три фактор который нужно комбинировать между себя два из они тип mbox а и тип сообщение сигнал легко представить в вид параметр шаблон не просто с три чем именно реализоваться deadletter handler указатель на функция или лямбда ну и ладный цель же не в тот чтобы избавиться от копипаста совсем цель в тот чтобы обойтись самый необходимый она минимум поэтому быть сделать два шаблонный класс один для случай когда deadletter handler реализоваться указатель на метод два для случай лямбда функция можно заметить что этот шаблонный класс очень похожий на тот пример код который быть показать выше только для простой тест проверять установка deadletter handler а теперь достаточно всего два класс а не десять надеяться с параметр шаблон под название msg_type весь понятно это быть тип сообщение или сигнал который тестовый агент должный отослать и получить в тест для этот цель быть использоваться следующий определение ну и при инстанциирование шаблон pfn_test_case_t и lambda_test_case_t быть использоваться test_message so_5 mutable_msg test_message и test_signal с это весь просто а вот с параметр mbox_case немного сложный хотя если c вы знаете хорошо то ничто сложный там нет вообще этот параметр определять какой именно mbox должный использоваться в тестовый случай mpmc mbox который следовать создавать специально или же direct_mbox который уже есть у каждый агент в наш тест в качество mbox_case использоваться два очень простой тип экземпляр класс direct_mbox_case_t сохранять у себя ссылка на агент для тот чтобы в свой метод mbox возвращать direct_mbox это агент а экземпляр класс mpmc_mbox_case_t у себя в конструктор создавать экземпляр mpmc mbox а и возвращать ссылка на он в свой метод mbox получаться что когда например класс pfn_test_case_t параметризоваться direct_mbox_case_t то в pfn_test_case_t m_mbox_holder храниться ссылка на сам экземпляр pfn_test_case_t и при вызов m_mbox_holder mbox возвращаться direct_mbox самый агент а когда pfn_test_case_t параметризоваться mpmc_mbox_case_t то в pfn_test_case_t m_mbox_holder лежать экземпляр отдельный mpmc mbox который создаваться при конструирование экземпляр pfn_test_case_t ну и тоже самый получаться для lambda_test_case_t итак мы получать возможность создавать вот такой сочетание для тестовый случай ещё по повод параметр mbox_case у мы использоваться класс хотя можно быть параметризовать тестовый класс и функция который бы возвращать mbox_t том е можно быть бы сделать так принципиально бы это ничто не поменять но первое что пришлый в голова это именно класс они и послать в реализация а вот шаблон шаблон о который упоминаться выше потребоваться лишь для тот чтобы чуть чуть упростить процедура создание тестовый агент в общий то без он вполне можно быть бы обойтись и писать что то вроде но хороший ввести вспомогательный шаблонный функция и потом уменьшить себя количество работа и сделать код создание тест более читаемый и вот introduce_test_agent уже и есть тот самый шаблон шаблон том е шаблонный функция один из шаблонный параметр который являться другой шаблон разобрать выше тест быть очень простой там достаточно быть отослать всего один сообщение поэтому и тестовый агент в немой быть простой а вот следующий тест проверять то что пользователь мочь отменить deadletter handler уже сложный для тот чтобы разобраться с он для начало посмотреть как должный работать агент для тестовый случай для простота брать пока только обычный иммутабельный сообщение test_message опять же чтобы быть простой разобраться с последующий код показать как бы выглядеть агент написать в лоб для конкретный тестовый случай самый простой вариант с direct_mbox ом и обычный иммутабельный сообщение test_message том е есть счётчик вход в deadletter_handler атрибут m_deadletters с нулевой начальный значение внутри deadletter_handler этот счётчик проверяться на ноль и инкрементироваться если deadletter_handler быть вызвать повторно то тест провалиться метод deadletter_handler отсылать два сообщение первое должный быть проигнорировать два должный привести к завершение работа тест подписка на сигнал finish идти в so_define_agent ну и самый один экземпляр test_message отсылаться в so_evt_start том е при старт агент однако это не шаблонный класс да ещё и заточить под конкретный тестовый сценарий как сделать из он шаблон который можно быть бы параметризовать два параметр mbox_case и msg_type как в предыдущий простой тест очевидный решение быть бы в тот чтобы взять класс pfn_test_case_t и lambda_test_case_t из простой тест и просто переделать каждый из они под новый логика работа но это решение нельзя назвать хороший по очевидный же причина слишком большой объесть дублироваться код оказываться в каждый из класс соответственно если допустить ошибка в один реализация то она автоматически распространяться на оба класс но она устранение требовать модификация не один класс а оба так же если потребоваться поменять логика поведение то так же потребоваться модифицировать оба класс а не один а логика работа довестись поменять том к изначально использоваться более сложный логика но в процесс написание статья выясниться что можно сделать заметно простой это изменение логика оказаться элементарный и не потребоваться переделывать два независимый друг от друг класс итак мы нужно вынести общий часть из pfn_test_case_t и lambda_test_case_t в какой то общий класс и том к класс агент в sobjectizer е должный наследоваться от so_5 agent_t то скорее всего этот общий класс быть базовый и для pfn_test_case_t и для lambda_test_case_t а вот один ли это быть класс давать посмотреть можно обратить внимание на то что в демонстрационный test_case_specific_agent_t есть как кусок код который зависеть от параметр шаблон так и кусок код который от параметр шаблон не зависеть скажем наличие состояние st_test и обработчик сигнал finish от параметр шаблон не зависеть а вот установка и отмена deadletter handler а отсылка тестовый сообщение зависеть это давать мы возможность разбить общий код на два часть один часть не быть шаблонный для реализация этот часть мы потребоваться вот такой класс можно увидеть что здесь сосредоточить изрядный часть прикладной логика тестовый агент и нет ничто что зависеть бы от параметр шаблон однако уже в nontemplate_basic_part_t нужно выполнить два действие который зависеть от msg_type это отмена deadletter handler а и отсылка ещё один экземпляр msg_type внутри nontemplate_basic_part_t мы знать где и когда этот действие должный быть выполнить но не мочь они выполнить поэтому мы делегировать выполнение этот действие наследник через чистый виртуальный метод do_next_step который и должный быть переопределить в какой то из класс наследник наследник же в который do_next_step определяться быть уже шаблонный класс следующий вид тут мы уже видеть привычный трюк с атрибут m_mbox_holder тип mbox_case а так же мы видеть реализация виртуальный метод do_next_step отмена deadletter handler а и отсылка два экземпляр msg_type и so_evt_start отсылка первое экземпляр msg_type получаться что nontemplate_basic_part_t и template_basic_part_t уже содержимый 95 нужный тестовый агент функциональность остаться всего ничто сделать pfn_test_case_t и lambda_test_case_t в который бы устанавливаться deadletter handler нужный вид вот так это быть выглядеть тут просто классический наследование с перекрытие виртуальный метод предок для тот чтобы расширить он поведение в so_define_agent сперва вызываться so_define_agent из базовый класс после что устанавливаться deadletter handler должный вид вот в итог и получаться старое добрый ооп с наследование реализация и полиморфизм да ещё и обильно сдобрить обобщённый программирование не хотеть чтобы у читатель возникнуть ощущение будто описать подход являться единственно верный в дать ситуация и что нельзя быть сделать по другой наверняка можно быть и наверняка даже в это подход что то можно быть бы сделать ещё простой и лаконичный в конец конец то что быть показать в статья быть написать буквально на коленка за полчаса проверить исправить и забытый а потом ещё раз исправить и ещё раз забытый что лично я убеждать в тот что подобный подход к реализация тест вполне себя оправдать смысл статья должный быть быть в тот чтобы показать как возможность который некоторый разработчик считаться слишком сложный и от использование который стараться держаться далёкий мочь облегчить жизнь буквально на ровный место ооп это всего лишь инструмент не религия не болезнь всего лишь инструмент где то он уместный где то нет скажем если вы нужно делать сложный и большой библиотека то ооп мочь вы пригодиться если делать небольшой и несложный приложение то мочь и не пригодиться а мочь и наоборот тут весь зависеть как от предметный область так и от ваш знание и опыт ну и от религиозный пристрастие конечно же аналогично и с обобщённый программирование это всего лишь инструмент вы никто не заставлять он использовать когда в это нет нужда но вот я лично не очень удобно когда набор доступный я инструмент преднамеренно ограничиваться либо путём изъятие ооп или превращение ооп в какой то жалкий подобие оный либо путём изъятие шаблон дженирик ещё худой когда нет ни тот ни другой поскольку этот инструмент быть создать для упрощение работа программист странно от они отказываться по добрый воля ну а c при весь свой недостаток хороший тем что позволять использовать и то и другой да ещё в самый разный сочетание другой вопрос как научиться использовать и то и другой и ещё куча возможность c по место и в мера но это уже совсем другой история

