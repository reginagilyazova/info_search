fpga для программист конечный автомат verilog golikovandrey когда нужно преодолеть врождённый параллельность fpga и появляться желание заставить схема работать последовательно по алгоритм на помощь приходить конечный автомат про который написать не мало академический и практический труд например очень популярный являться работа всякий раз когда специалист решать обсудить как писать конечный автомат кто то обязательно доставать этот публикация статья стать настолько авторитетный что многие даже не стараться анализировать аргумент автор в частность бытовать мнение что профессионал всегда использовать двухчастный способ описание конечный автомат иметься ввиду описание конечный автомат в 2 блок это утверждение продолжать вызывать жаркое спорый и я хотеть пояснить различие в описание конечный автомат с разный количество блок в беседа с коллега я понять что спорый о тот как надо писать конечный автомат в 1 или 2 3 always блок связать с разный представление осознание реализовать алгоритм разный тип мышление попробовать показать это на пример я полагать что этот статья не один статья о fsm и verilog в ваш жизнь поэтому я не быть объяснять ни что такой конечный автомат ни как он описываться на verilog а перейти сразу к дело представить вы сидеть дом вы нужно сходить в магазин купить хлеб и вернуться обратно реализовать такой поведение просто это алгоритмический последовательность действие она можно описать так для многий такой описание показаться естественный чёткий последовательность действие похожий на строка программа однако тот же алгоритм можно описать и по другой при это интересно хоть кто то сейчас подумать что последний вариант логичный чем один так или иначе оба этот описание иметь представление в вид конечный автомат первое в вид описание с один блок а два с два или три оговориться что описание в 2 и 3 блок это близнец брат отличаться только технический нюанс который мы сейчас не важный показать как описание представляться в вид автомат у мы есть состояние автомат home_state street_state market_state cashier_state есть выход автомат наш действие get_dressed_act undress_act take_bread_act pay_money_act описание с 1 блок выглядеть так теперь описание с 2 блок хотеть обратить внимание на особенность этот 2 описание который и являться причина священный война за число блок 1 блок 2 блок автомат с 1 блок в текущий состояние определять какой действие он собираться делать далёкий не заботиться о тот что он делать сейчас а автомат с 2 блок в текущий состояние определять что он делать сейчас и он не заботить что он быть делать далёкий или делать до это нельзя однозначно сказать какой поведение хороший или правильный весь сильно зависеть от задача от реализовать автомат алгоритм для демонстрация изменить ситуация теперь у вы есть вы ходить на работа в бар в вы ходить как из по выходной так и с в пятница в один реализация с 1 вы надо внимательно следить куда вы собираться идти чтобы случайно не начать или в два реализация с 2 блок вы защитить от это тут весь чётко определить состояние состояние с другой сторона в описание с 2 блок прийти в бар с работа вы не смочь не пить пиво состояние в этот реализация жёстко фиксировать действие а в описание с 1 блок ваш действие определяться в момент выход из прошлое состояние с вы мочь пойти и каждый два поход из в мочь заканчиваться текущий состояние никак вы не ограничивать оба автомат иметь свой место в проект просто нужно правильно определить какой особенность быть полезный в конкретный ситуация если у вы сложный сеть переход и в разный состояние вы попадать многий путь иметь смысл использовать схема с 2 блок у вы не быть шанс забыть задать какой то из выход автомат при очередной переход с другой сторона если вы писать простой автомат с практически линейный структура можно использовать описание с 1 блок фактически вы задавать последовательность на выход а состояние использовать просто для организация последовательный выполнение так как выход автомат не зависеть от текущий состояние не надо быть прописывать они значение в каждый состояние описание быть короче и логичный в статья с который мы начать хорошо показать почему надо использовать описание с 2 и 3 блок а описание с 1 блок отметить как самый плохой автор рекомендовать избегать такой описание поэтому хотеться привести пример реальный интерфейс удобный для описание в 1 блок и защитить данный вид описание для сравнение я привести тот же автомат описать в 3 блок необходимый 3 а не 2 блок потому что мы быть использовать регистровый выходной сигнал и так у мы есть модуль который реализовать запись в асинхронный память на вход модуль принимать строб чтение либо запись дать и адрес для запись адрес для чтение на выход модуль выдавать сигнал завершение чтение или запись и считать дать модуль управлять простой асинхронный память иметь следующий временной диаграм работа основной смысл модуль по строб чтение либо запись развернуть времянка выдержать задать интервал а по завершение выдать 1 тактовый сигнал готовность мы необходимый соблюдать следующий интервал интервал мы быть измерять в количество тактовый входной частота и задать интервал константа read_setup read_pulse read_hold и write_setup write_pulse write_hold описание с 1 блок описание с 3 блок вот результат моделирование работа описание как мы видеть вести они себя одинаково и соответствовать желаемый временной диаграмма память описание в 3 блок получиться в больший число блок иначе блок задание выход сильно бы усложниться заряжать счётчик сохранять дать для запись в память и обратно мы надо в один конкретный такт для это нужно либо добавлять однотактный состояние в автомат либо создавать конструкция выделение этот тактовый я предпочесть два вариант и вынести конструкция в отдельный блок чтобы не усложнять блок задание выход так или иначе в это пример мы видеть насколько большой получаться описание в 3 блок брутто 287 строка против 181 в немой большой место где можно совершить ошибка отлаживаться оно тоже сложный если вы просматривать этот два описание то мочь заметить что в первое описание весь картина работа видный сразу а в второе мы всегда видеть какой то часть полный картина разнести по весь файл разбирать так описать чужой автомат отдельный удовольствие особенно если условие переход зависеть от выход автомат в наш случать состояние задавать счётчик а счётчик задавать условие переход сначала смотреть значение выход в текущий состояние потом лететь в блок переход и смотреть куда мы переходить в дать состояние и при такой значение выход потом опять мотать в блок задание выход смотреть они изменение от новое состояние автомат описать в 2 блок анализироваться чуть простой у он выход и переход часто лежать ряд в один блок но ровно до момент пока мы не захотеть защёлкнуть состояние выход в регистр тут начинать появляться регистр с парный комбинаторный значение они следующий состояние потом начинать добавляться условие защёлкивание и мы возвращаться к исходный упражнение надеяться теперь описание с 1 блок потерять титул самый плохой описание стараться он избегать конечно не стоить всегда использовать только этот вид описание при ветвистый сеть переход 1 блоковый описание правда неудобно быстро разрастаться по объём код и переставать управляться однако выкидывать он из арсенал разработка однозначно не стоит

