асинхронность назад в будущее gridem асинхронность услышать это слово у программист начинать блестеть глаз дыхание становиться поверхностный рука начинать трястись голос заикаться мозг начинать рисовать многочисленный уровень абстракция у менеджер округляться глаз звук становиться нечленораздельный рука сжиматься в кулак а голос переходить на обертон единственный что они объединять это учащённый пульс только причина это различный программист рваться в бой а менеджер пытаться заглянуть в хрустальный шар и осознать риска начинать судорожно придумывать причина увеличение срок в раз и уже потом когда большой часть код написать программист начинать осознавать и познавать весь горечь асинхронность проводить бесконечный ночь в дебаггера отчаянно пытаться понять что же весь таки происходить именно такой картина рисовать мой воспалить воображение при слово асинхронность конечно весь это слишком эмоционально и не всегда правда ведь так возможный вариант некоторый сказать что при правильный подход весь быть работать хорошо однако это можно сказать всегда и везде при всякий удобный и не удобный случай но хороший от это не становиться баг не исправляться а бессонница не проходить так что же такой асинхронность почему она так привлекательный а главный что с она не так асинхронность на текущий момент являться достаточно популярный тема достаточно просмотреть последний статья на хабра чтобы в это убедиться тут ты и обзор различный библиотека и использование язык go и всякий асинхронный фреймворка на js и много что другой обычно асинхронность использоваться для сетевой программирование всякий сокет шмокета читатель писатель и прочий акцептор но бывать ещё забавный и интересный событие особенно в ui здесь я быть рассматривать исключительно сетевой использование однако как быть показать в следующий статья подход можно расширять и углублять в неведомый дать чтобы быть совсем уж конкретный быть писать простой http сервер который на некий люба запрос посылать некий стандартный ответ это чтоб не писать парсер том к к тема асинхронность он иметь ровно такой же отношение как положение звезда к характер человек сантиметр астрология хм синхронный а при чем тут синхронный спросить внимательный читатель открыть статья про асинхронность ну в один надо же с что то начать с что то простой а в второе короче я автор поэтому быть так а потом и сам узнать зачем для тот чтобы не писать низкоуровневый платформозависить код для весь наш цель я быть использовать мощный асинхронный библиотека под название благо стать уже написать про нея достаточно чтобы быть хотя бы немножко в тема опять же для больший наглядность и продакшенность код я сделать обёртка для вызов соответствующий функция из библиотека конечно кома то мочь нравиться портянка наподобие или но ясность и читабельность код при это значительно уменьшаться итак описание сокет и акцептор ничто лишний просто сервер позволять писать и читать в тот число до определённый символ слушать указанный порт и принимать соединение реализация всего это хозяйство привести ниже здесь я использовать синглтон для чтобы не передавать он каждый раз в сокет явно в входной параметр и откуда пользователь знать что там должный быть какой то поэтому я он спрятать далёкий чтобы глаз не мозолить остальной я полагать вполне понятно за исключение быть мочь функция но быть она простой читать байтик до тот пора пока не встретиться заветный окончание это нужно как раз для http том к заранее размер мы увы не мочь задать приходиться ресайзиться давать теперь написать долгожданный сервер вот он сервер готовый недостаток предыдущий сервер очевидный поэтому появляться идея чтобы обрабатывать соединение в друг поток продолжать принимать следующий соединение для это мы понадобиться функция создание новое поток который я внезапно назвать стоить отметить один забавный вещь если убрать то угадать что сделать программа теперь можно и сервер написать казалось бы весь хорошо но не тут то быть на реальный задача под нагрузка это дело ложиться быстро и потом не отжиматься поэтому умный дядька подумать подумать и решить использовать асинхронность в чем проблема предыдущий подход а в тот что поток вместо реальный работа большой часть время ожидать на событие из сеть отжирая ресурс хотеться как то более эффективно использовать поток для выполнение полезный работа поэтому теперь быть реализовывать аналогичный функция но уже асинхронный использовать модель проактор что это означать это означать что мы для весь операция вызывать функция и передавать callback который автомагически позваться по окончание операция том е мы позвать сам как только операция завершиться это отличаться от модель реактор когда мы должный сам вызывать нужный обработчик наблюдать за состояние операция типичный пример реактор epoll kqueue и различный select ы пример проактор на windows я быть использовать кроссплатформенный проактор асинхронный интерфейс стоить остановиться на некоторый вещь если внимательно присмотреться то отличие от синхронный функция только в тот что асинхронный содержимый дополнительный обработчик в качество входной параметр ну что ж вроде пока ничто страшный нет реализация тут должный быть весь понятно за исключение метод для тот чтобы несколько раз вызывать асинхронный чтение на сокет необходимый сохранять состояние для это предназначить специальный класс который сохранять текущий состояние асинхронный операция похожий реализация можно встретить в для различный функция например который требовать несколько вызов более простой но не менее асинхронный операция помимо это необходимый написать аналог и диспетчеризация здесь указываться обработчик который быть запускаться асинхронный в пул поток и собственно создание пул поток с последующий диспетчеризация вот как выглядеть реализация здесь мы использовать для создание поток из синхронный подход реализация сервер вот такой простыня с каждый новый вызов расти вложенность лямбда обычно конечно такой через лямбда не писать том к есть сложность с зацикливание в лямбда необходимый пробрасывать сам себя чтобы внутри самый себя позвать сам себя но тем не менее читабельность код быть примерно одинаковый том е одинаково плохой при сравнение с синхронный код итак давать обсудить плюс и минус асинхронный подход хорошо конечно если весь написать правильно и оно сразу заработать и без баг а вот если это не так в общий счастливый дебаггинга как говориться в такой случай и это я ещё рассмотреть достаточно простой пример где можно отследить последовательность вызов при небольшой усложнение схема обработка например одновременный чтение и запись в сокет сложность код расти как на дрожжи а количество баг начинать растить чуть ли не экспоненциально так стоить ли игра свеча стоить ли заниматься асинхронность на самый дело выход есть coroutines или итак что же мы весь хотеться а хотеться простой использовать плюс асинхронный и синхронный подход одновременно том е чтобы и производительность быть как у асинхронный и простота как у синхронный на бумага звучать замечательный возможно ли это для ответ на вопрос мы понадобиться небольшой введение в сопрограмма вот что такой обычный процедура находиться мы значит в какой то место исполнение и тут раз и позвать процедура для вызов сначала запоминаться текущий место для возврат затем зваться процедура она исполняться завершаться и возвращать управление в то место откуда быть позвать а сопрограмма это то же самый только другой она тоже возвращать управление в то место откуда быть позвать но при это она а останавливаться в некоторый место с который далёкий продолжать работать при повторный запуск том е получаться эдакий пинга понг вызывающий бросать мячик сопрограмма ловить он перебегать в другой место бросать обратно вызывающий тоже что то делать перебегать и снова бросать в предыдущий место уже сопрограмма и так происходить до тот пора пока сопрограмма не завершиться в целое можно сказать что процедура это частный случай сопрограмма как теперь это можно использовать для наш асинхронный задача ну тут наводить на мысль то что сопрограмма сохранять некий контекст исполнение что для асинхронность крайне важный именно это и быть я использовать если сопрограмма потребоваться выполнить асинхронный операция то я просто вызов асинхронный метод и выйти из сопрограмма а обработчик по завершение асинхронный операция просто продолжить исполнение наш сопрограмма с место последний вызов тот самый асинхронный операция том е весь грязный работа по сохранение контекст ложиться на плечо реализация сопрограмма и вот тут как раз и начинаться проблема дело в тот что поддержка сопрограмма на сторона язык и процессор дело давно минувший день для реализация переключение контекст исполнение сегодня необходимый проделать множество операция сохранить состояние регистр переключить стек и заполнить некоторый служебный поль для корректный работа среда исполнение например для исключение и др более тот реализация зависеть не только от архитектура процессор но ещё и от компилятор и операционный система звучать как последний гвоздь в крышка гроб к счастие есть который и реализовать весь что необходимый для поддержка конкретный платформа написать весь на ассемблер в хороший традиция можно конечно использовать но зачем когда есть большой ад и угар итак для наш цель написать свой сопрограмма интерфейс быть такой вот такой нехитрый интерфейс ну и сразу вариант использование должный выдать на экран начать с метод здесь создавать мы контекст и передавать в качество стартовый функция статический метод который просто перенаправлять на метод извлекать текущий экземпляр из весь магия по переключение контекст находиться в приватный метод здесь мы заменять старое значение на новое нужно для рекурсивный переключение между несколько сопрограмма устанавливать всякий флаг и переключать контекст с использование после завершение восстанавливать старое значение и прокидывать исключение в вызывающий функция смотреть теперь на приватный метод который и запускать нужный обработчик отметить один интересный момент если не сохранить обработчик внутри сопрограмма до он вызов то при последующий возврат программа мочь благополучно упасть это связать с тем что вообще говорить обработчик хранить в себя некоторый состояние который мочь быть разрушить в какой то момент теперь остаться рассмотреть остальной функция теперь пришлый очередь реализовать асинхронность на сопрограмма тривиальный вариант реализация привести на следующий диаграмма здесь происходить создание сопрограмма затем сопрограмма запускать асинхронный операция и завершать свой работа с использование функция по завершение операция происходить продолжение работа сопрограмма посредством вызов метод и весь быть бы хорошо если бы не пресловутый многопоточность как это всегда бывать она вносить некоторый турбулентность поэтому привести выше подход не быть работать должное образ что наглядно иллюстрировать следующий диаграмма том е сразу после шедулинга операция мочь быть вызвать обработчик который продолжить исполнение до выход из сопрограмма это понятно не входить в наш план поэтому прийтись усложнить последовательность отличие состоять в тот что мы запускать шедулинга не в сопрограмма а вне она что исключать возможность описать выше при это продолжение сопрограмма мочь случиться в друг поток что являться вполне нормальный поведение для это сопрограмма и предназначить чтобы иметь возможность тусовать они туда сюда сохранять при это контекст исполнение начать с реализация функция здесь мы вместо простой запуск обработчик создавать сопрограмма и запускать обработчик уже внутри нея интерес тут также представлять функция который смотреть не надо ли что зашедулить действие простой смотреть есть ли что то для обработка если есть то выполнять нет тогда сопрограмма закончить свой работа и она можно удалить возникать вопрос а как заполняться а вот так этот функция всегда вызываться внутри сопрограмма здесь передаваться некий обработчик который быть заниматься шедулинг операция том е запуск асинхронность этот обработчик запоминаться чтобы он запустить по выход из сопрограмма после выход сразу запускаться который и запускать наш обработчик ниже привести использование функция на пример возвращать асинхронный обработчик который обрабатывать завершение асинхронный операция внутри обработчик происходить запоминание ошибка чтобы поздний иметь возможность пробросить исключение внутри наш сопрограмма сантиметр вызов внутри а затем продолжение исполнение сопрограмма том е возвращение в метод сразу после вызов диаграмма ниже показывать последовательность вызов и взаимодействие различный сущность остальной функция реализоваться аналогично везде в реализация я использовать соответствующий асинхронный объект и описать в пункт про асинхронность перейти к использование наш функционал тут весь гораздо простой и изящный привести код что то напоминать точно это же практически наш синхронный код тут ровно один отличие в синхронный реализация принятие сокет происходить в главное поток а потому отсутствовать однако если задаться цель можно быть бы этот подход сделать полностью идентичный для это в синхронный реализация также сделать принятие сокет в отдельный поток использовать а функция тогда просто бы ждать завершение весь поток но отличие в реализация носить принципиальный характер получиться код использовать асинхронный сетевой взаимодействие а значит являться гораздо более эффективный реализация собственно на это наш цель достигнуть сделать симбиоз синхронный и асинхронный подход взять из они самый хороший том е простота синхронный и производительность асинхронный описать некоторый улучшение для процесс принятие сокет часто после принятие происходить разветвление исполнение тот кто принимать быть продолжать принимать а новый сокет быть обрабатываться в отдельный контекст исполнение поэтому создать новый метод и тогда наш сервер переписаться в вид что гораздо простой для понимание и использование действительно отличие от чисто асинхронный подход в тот что тут возникать дополнительный накладный расход на создание переключение контекст и смежный атрибутика сначала я быть хотеть проверить предельный нагрузка но потом оказаться что даже в один поток загружаться скорее гигабитный сеть нежели процессор поэтому я провести следующий тест результат привести в таблица отметить что погрешность получить значение связать с колебание значение в ход один испытание скорее всего это связанный с неравномерность нагрузка канал и обработка тем не менее видно что не смотреть на наличие дополнительный переключение контекст а также пробрасывание исключение вместо код возврат исключение генериться каждый раз при закрытие сокет том е каждый раз на новый запрос накладный расход пренебрежимый маленький а если ещё добавить код который бы честно парсила http сообщение а также код который бы не менее честно обрабатывать запрос и делать что нибыть важный и нужный то можно заявить сметь что вначале взять функция который использовать асинхронный вызов любой функция можно превратить в сопрограмма том к функция являться частное случаем сопрограмма далее взять какой либо асинхронный вызов в такой преобразовать сопрограмма такой вызов можно представить в следующий вид рассмотреть случай когда у мы отсутствовать код после вызов такой код с точка зрение сопрограмма эквивалентный следующий том е внутри мы вызывать соответствующий асинхронный функция который мы возвращать управление в сопрограмма по завершение операция и затем вызываться обработчик явно результат ровно один и тот же теперь остаться рассмотреть более общий случай когда у мы присутствовать код после асинхронный вызов такой код эквивалентный использовать то что у мы теперь отсутствовать код после вызов внутри получать том е на один асинхронный вызов стать маленький применять такой подход к каждый асинхронный вызов функция и к каждый функция мы переписать весь код на сопрограмма асинхронность стремительный домкрат врываться в наш программистский жизнь сложность который возникать при написание код способный привести в дрожь даже самый ярый и закалить эксперт однако не стоить списывать с счёт старый добрый синхронный подход в умелый рука асинхронность превращаться в элегантный сопрограмма в следующий статья быть рассмотреть гораздо более сложный пример который раскрыть весь мощь и потенциал сопрограмма до новый встреча в эфир p s весь код можно найти здесь

