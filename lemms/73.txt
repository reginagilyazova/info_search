dive into ico therealal в статья мы рассмотреть технический аспект подготовка и проведение ico это продолжение статья мой коллега и здесь мы поговорить дробный о некоторый технический вопрос связанный с смарт контракт сеть ethereum прежде чем разрабатывать смарт контракт хорошо бы сделать технический проект это принципиальный схема ваш система контракт который отвечать на ключевой технический вопрос показывать реализуемость экономика проект и ваш сценарий ico что обычно включаться в техпроект это необязательно должный быть толстенный формальный документ достаточно четыре пять страница с ключевой момент и пара диаграмма и на этот страница для начало рассмотреть механик владение самый простой вариант реализоваться один владелец токен ico всего подряд обычно так и делать более сложный вариант когда идти в ход мультиподпись можно взять за основа надёжный контракт кошелёк извлечь оттуда мультиподпись и применять она не только для кошелёк и хранение эфир но и для управление сам ico и токен тут ваш фантазия не ограничить вы мочь математически легко реализовать самый разный сценарий хорошо когда ico декомпозировать том е представлять себя не один контракт который считать курс выдавать токен и принимать эфир а система смарт контракт когда каждый контракт заниматься свой дело то есть вы принимать эфир на этап ico который в зависимость от свой логика понимать сколько токен вы нужно выдать он давать соответствующий команда контракт токен владелец токен и в то же время он не держать эфир в себя а переводить он в специальный хранилище который также являться контракт я не видеть никакой криминал в тот чтобы хранить эфир в контракт наоборот это даже более прозрачный поскольку понятно что делать контракт можно легко видеть что эфир там храниться до окончание ico а если не собрать деньга то он гарантированно весь вернуть инвестор и даже владелец не мочь это помешать с другой сторона такой усложнение не бывать бесплатно можно сказать что это порождать дополнительный проблема на этап деплоить и да этот соединение и вызов лишний возможность внести уязвимость очень внимательно следить за право есть стандарт на токен он называться он определять несколько метод который нужно реализовать в контракт если ваш токен реализовать этот стандарт то он мочь выводиться на многие биржа кроме тот erc20 поддерживать и другой кошелёк помимо ethereum wallet такой образ просто реализовать нужный функция вы получать уже готовый инфраструктура для работа именно с ваш токен более тот есть библиотека который закладывать база для токен и сразу реализовать erc20 реализовывать стандарт необязательно если у вы какой то сугубо внутренний ресурсный токен и если не предполагаться что пользователь быть имя обмениваться между себя если они приходить с это токен в парк развлечение и покупать себя билет на аттракцион то наверное он не нужный листинг на биржа кроме тот в контракт можно заложить состояние пауза в случай проблема или странный активность например когда эфир литься а токен не выдаваться тогда надо приостановить ico разобраться и принять решение стоить заложить это состояние в техпроект также вы мочь предусмотреть эмиссия токен в техпроект важный подумать о это до ico поскольку нужно понимать как это быть совместимый с токен смочь ли вы делать потом дополнительный эмиссия обязательно продумать такой схема это граф состояние ваш ico она представлять себя конечный автомат том е состояние в который мочь находиться ico это и есть граф он описывать состояние и говорить при какой условие происходить переход из один в другой ваш ico не должный просто так менять состояние с собирание деньга на успешно собрать давать скорее они выводить вы должный понимать каков переход между состояние в ico это должный понимать и инвестор потому что они видеть что весь по честной и это должный понимать и чётко запрограммировать разработчик для это в solidity есть весь средство есть так называть перечисление с помощь который описываться состояние кроме тот я рекомендовать сделать переход между состояние контролировать код так чтобы недопустимый переход не быть люба функция который доступный снаружи контракт вы мочь задать состояние с помощь так называть модификатор solidity так инвестировать можно только в состояние ico но не пауза и наоборот выводить деньга владелец мочь только при успешно завершить ico когда техпроект готовый заказчик счастливый а разработчик понимать что нужно делать мы переходить к разработка в ethereum есть виртуальный машина ethereum virtual machine evm она выполнять этот самый программа контракт а контракт это так называть байт код который исполняться виртуальный машина в связь с это появляться возможность разрабатывать контракт на несколько язык язык solidity создать специально под задача разработка смарт контракт с нуль он иметь c подобный синтаксис кроме он есть другой язык есть похожий на javascript есть язык похожий на python мой интуитивный мнение состоять в тот что хороший выбрать solidity даже по причина нейрофизиологический характер когда разработчик пользоваться язык который похожий на python он тем не менее писать смарт контракт ethereum но при это у он в голов начинать всплывать семантика и паттерн типичный для python и они неочевидный работать при разработка под blockchain говорить о solidity можно долго поэтому нужный ориентир в один сильно облегчать разработка фреймворк он помогать проводить тестирование контракт деплоить он в основной тестовый локальный блокчейн и даже позволять это делать инкрементальный том е дополнять свой система контракт новый контракт при это фреймворк запомнить весь старое и не быть они заново перевыкладывать почему я призывать переиспользовать библиотека сообщество довольно молодой мало код но весь принцип получить в разработка софт за последний 30 40 год оставаться в сила и в случай blockchain и они мы говорят что если есть код который достаточно хорошо проверить который предполагать сам по себя переиспользование в широкий круг проект то стоить взять он а не изобретать велосипед прежде всего отметить библиотека она находиться на грань де факто стандарт при разработка смарт контракт там не так много контракт и библиотека они относительно невеликий но они покрывать частый случай предоставлять вы из коробка многие вещий владение контракт какой то токен токен который можно создавать сжигать несколько типичный ico кой что связанный с безопасность например защита от reentrancy атака ещё один библиотека рекомендовать использовать она даже если вы не хотеться подключать zeppelin solidity она маленький буквально несколько однострочник она можно скопировать прямо себя в контракт она страховать вы от переполнение это очень актуальный и серьёзный проблема например когда вы иметь дело с беззнаковый число в solidity и по недосмотр вычитать из тройка пятёрка то контракт продолжать работать но как результат вы показываться огромный число это случиться из за переполнение если вы использовать библиотека safemath происходить ошибка том е транзакция завершаться с ошибка а состояние не изменяться существовать много рекомендация я упоминать о конечный автомат желательно он реализовать прописать состояние и модификатор кроме тот переход из один состояние в другой можно реализовать по время при это к каждый функция добавляться модификатор который говорить я быть смотреть на время и если сейчас уже начать ico то я изменить состояние на ico есть шаблон типичный паттерн который начинать формироваться в мир solidity в мир смарт контракт например вы слышать что есть много шаблон в разработка софт тем более какой то корпоративный система здесь к такой можно отнести например известный шаблон withdrawal pattern когда пользователь снимать причитаться он средство сам а не когда вы пытаться послать они он например при неудача ico когда требоваться вернуть деньга инвестор если вы попробовать сделать это сам то скорее всего у вы это по ряд причина не получиться также это чреватый проблема с безопасность если оформить возврат как снятие средство пользователь с соответствующий проверка стать гораздо простой я упоминать о режим пауза нечасто использоваться в ico который мы в последний время видеть но это очень полезный механизм понятный дело он не страховать от 100 проблемный ситуация даже несмотря на пауза можно украсть эфир но существенно снижать возможность атака о замена контракт должный сказать что необязательно идти до конец и делать совершенно динамический контракт код который мочь быть произвольно заменить с помощь например вызов и том далее достаточно чтобы этот частичка этап ico который содержимый в себя нетривиальный накрутить логика мочь быть заменить если обнаруживаться проблема это возможно за счёт тот что токен и деньга у вы отдельно деньга оставаться без изменение в принцип можно заменить этот частичка и связать она с два уже иметься часть совершенно прозрачный при это есть особенность если ico производить инициализация например токен то принять мера чтобы при замена инициализация не стартовать два раз у ваш ico в результат появиться новый адрес это новый контракт возможность замена быть видный в код контракт и нужно понимать что это некий компромисс с один сторона хотеться чтобы весь быть абсолютно неизменяемый это повышать доверие к вы с другой сторона неплохо бы подстраховаться как компромисс вы мочь прописать в код условие который совершенно неизменяемый например прописать в хранилище эфир что минимальный порог сбор средство неизменяемый в принцип тогда инвестор быть знать что не случиться так что собрать 100 тысяча а хотеть собрать 100 миллион но весь равно взять что есть по возможность следовать проверять на разумность параметр который метод ваш контракт получать на вход допустить если у вы токен поддерживать эмиссия и в она параметр задаваться число токен который нужно сгенерировать то вы мочь это число проверить например посмотреть не большой ли оно чем сейчас токен вообще есть это мочь вы подстраховать когда есть опечатка в вводить вручную параметр или например если эмиссия инициировать внешний инфраструктура когда в она происходить сбой она вы мочь заэмитировать миллиард миллиард токен ещё три ссылка на github здесь набор репозиторий с кой какой решение это экспериментальный вещий пробовать они крайне осторожно и обычно там так и написать это альфа версия не хранить на она большой 20 доллар но понятно что весь хороший вещий рождаться из эксперимент мочь быть хороший взять за основа что то готовый чем писать весь самый с нуль какой ide взять для solidity разработка я привыкнуть активно работать в командный строка truffle я запускать из командный строка и на самый дело там требоваться всего три команда что касаться среда разработка я выбрать pycharm есть бесплатный плагин для solidity и это неплохой вещь среда разработка очень помогать вы и pycharm idea хороший ide я бы даже сказать что раз в два хороший конкурент она позволить вы подсветить переменный в контракт весь она использование и это очень помогать когда мы делать аудит когда вы буквально за несколько часы разбираться в незнакомый код с помощь подсказка среда разработка немного о стоимость выполнение смарт контракт стоить быть только вычисление который изменять blockchain том е участвовать в транзакция есть функция с модификатор или они не модифицировать состояние они мочь использоваться без посылка дать в blockchain если бы мы разработать функция который вызываться сугубо локально то она бы не стоить вообще ничто люба код который выполняться действительно в blockchain и модифицировать состояние сохранять или пересылать дать стоить газа легко поставить мысленный эксперимент на этот тема мочь ли я написать код который быть допустить очень долго работать и много что то сохранять если при это участник сеть ethereum приходиться он повторять то ваш код быть работать на миллион компьютер по весь мир значит разработчик ethereum по любой озаботиться чтобы вы за это заплатить и довольно дорого по текущий расценка другой дело что у разный вычисление и строчка разный стоимость цена простой арифметик 3 5 единица газа а модификация состояние обойтись в 20 тысяча единица газа почему потому что блокчейн измениться стать большой на 32 байт из за вы этот байт лечь на миллион компьютер по весь мир тестирование обязательный шаг о это мы говорить 50 летний история программный обеспечение и странно не видеть тест в репозиторий проект который приходить на ico мочь быть они проделать написать но просто не выложить но в любой случай если вы делать тест почему бы они не выложить так вы показывать инвестор что здесь весь хорошо протестировать это не гарантия что нет ошибка но помогать избежать многий проблема тест писаться непосредственно на solidity или на javascript в любой случай с помощь truffle вы мочь запустить весь тест разом и получить сводный отчёт в самый низ у вы должный быть сказать весь тест пройти неудача нет вы показывать и заказчик ico и пользователь и инвестор что вы протестировать самый важный аспект ваш ico токен сам по себя crowdsale хранение деньга даже бонус бонус немаловажный вещь инвестор очень важный знать что они получить свой бонус есть юнит тест они проверять небольшой изолировать фрагмент код и такой тест удобно писать на solidity код именно solidity он просто создавать контракт посылать в он дать и проверять что контракт работать как и ожидаться есть тест написать на javascript обычно здесь проверяться более сложный сценарий когда в взаимодействие участвовать несколько контракт допустить мы создавать набор контракт о который упоминаться ранний тогда участвовать несколько контракт также мочь быть несколько пользователь мы даже именовать они инвестор такой то инвестор такой то есть ещё владелец есть пользователь вообще без право и здесь можно запрограммировать комплексный взаимодействие и проверить что в ход взаимодействие токен выдаваться правильно или проверить что при достижение hard cap инвестор получить свой сдача этот тест называться интеграционный любой обращение к blockchain из javascript асинхронный это добавлять лишний код всякий promise и том далее поэтому я предлагать использовать babel свой род компилятор javascript который весь асинхронность спрятать за конструкция не забывать тестировать исключительный ситуация например мы проверить что владелец после завершение успешный ico выводить деньга мы также должный протестировать что этот товарищ инвестор 2 инвестор 3 аноним с улица не мочь вывести деньга том е при подача запрос на вывод деньга получиться исключительный ситуация контракт не принять запрос резюмировать тестировать стоить есть весь средство для это кстати программист не должный быть тестировщик почему потому что создатель плохо видеть свой ошибка у он в голов уже сложиться какой то модель и он она перенести в код когда программист пытаться проверить свой код он модель неминуемо выскакивать у он в голов и мозг говорить да тут весь нормальный мы делать этот метод так чтобы и хватить туда смотреть послать хороший попить смузи помимо тестирование также нужный аудит аудит заниматься специально обученный человек в ход аудит мочь быть разработать дополнительный тест но аудит это совсем другой ситуация и совсем другой навык если мы говорить о аудит то прежде всего нужно понять какой бывать уязвимость и сколько вы за они заплатить аудитор есть несколько способ оценка например хороший методология она вводить для уязвимость два измерение важность и вероятность влияние уязвимость на проект произведение этот два величина это мочь кома то напомнить матрица оценка риск на практика в отчёт о аудит смарт контракт часто приходиться видеть что притягиваться за ухо степень влияние уязвимость она важность не знать почему это происходить тем не менее критический называться вовсе не критический уязвимость поэтому мы предлагать другой методология который связывать влияние уязвимость на реальный жизнь с ваш проект в случай смарт контракт есть довольно понятный результат эксплуатация уязвимость можно вывести эфир или токен что очень плохо в какой то условие контракт зависнуть или он состояние испортиться настолько что прийтись заменять контракт тут у аудитор и у заказчик аудит мочь быть минимальный количество споровый пара ссылка на отчёт по аудит отчёт это документ который говорить о тот какой уязвимость найти и в идеал что делать далёкий кто то в западный круг писать большой отчёт вы рассказывать что нужно назвать этот функция по другой а хороший перенести этот код куда то в другой место но я просто не видеть смысл так делать если заказчик не быть заниматься серийный разработка смарт контракт если он нужно провести ico один раз и продолжать добывать свой песок в карьера на который он собирать эфир перейти к проблема на который нужно обратить внимание это тема для отдельный статья о безопасность смарт контракт отметить несколько вещий для начало очень внимательно просмотреть функция и убедиться что они закрытый право как надо с самый жёсткий ограничение например функция ничто не менять в блокчейн мочь быть объявить как функция который вообще не читать блокчейн как стоить наложить этот ограничение более тот у административный функция должный проверяться владелец это кажется очевидный но вспомнить parity повториться ещё раз весь дать в блокчейн открытый весь несмотря на модификатор и право доступ к состояние там мочь быть мочь не быть но на самый дело весь можно прочитать из контракт не использовать для авторизация такой параметр транзакция как это открывать уязвимость выбирать из нетривиальный наверное многие слышать про так называть reentrancy attack через который взломать the dao проблема в тот что когда ваш метод контракт ещё работать он мочь делать внешний вызов это касаться только внешний вызов который в свой очередь по цепочка мочь вернуться и обратиться в этот же самый метод или в другой метод контракт и это открывать уязвимость ваш состояние контракт мочь быть ещё не консистентный какой то инвариант в ход работа метод мочь быть временно нарушить и ещё не восстановить для борьба с это есть ряд метод самый хардкорный метод модификатор из библиотечный контракт запрещать reentrancy для контракт почему бы он не использовать он стоить некоторый количество газа он писать состояние но в ряд случай безопасность более важный чем лишний расход газа вспомнить для пример атака front running что если вы зашифровать что то и положить это в blockchain это невозможно расшифровать потому что асимметричный криптография никто не отменять но как только вы пытаться легитимный расшифровать это послать транзакция с пароль то происходить вот что в один пароль получаться одноразовый потому что он прилететь в блокчейн он весь видеть в второе когда транзакция уйти от вы но ещё не стать частью основной ветка и не зафиксировать за вы токен в этот момент кто то мочь увидеть ваш пароль и подсунуть свой транзакция который оказаться ранний ваш хотя по время она произойти поздний не так давно появиться информация ещё о один атака short address attack она быть подверженный некоторый биржа и библиотека который посылать транзакция в ethereum основный api библиотека ethereum web3 не подверженный но быть подверженный софт биржа атака заключаться в тот что пользователь использовать адрес укоротить на один байт когда параметр слепляться в транзакция следующий за это адрес параметр сдвигаться на один байт и когда происходить обращение из виртуальный машина ethereum к это параметр на самый конец calldata evm неявно дописывать ноль число сдвигаться на один байт а такой сдвиг это умножение на 256 то есть пользователь снимать 1 единица эфир когда уже пройти весь проверка безопасность на сторона биржа а на самый дело он перечисляться 256 единица кто то говорить неправильно запрограммировать биржа тут есть проблема и в ethereum виртуальный машина поскольку на мой взгляд при обращение к байт за предел существующий параметр транзакция на самый дело должный происходить не неявный подстановка нуль а ошибка исключительный ситуация так как это случается в управление адресный пространство в обычный приложение на компьютер я уже упоминать о переполнение и ещё раз сказать что есть короткий тип дать допустить число занимать 1 байт в беззнаковый случай это от 0 до 255 включительно важный избежать они переполнение порой оно возникать неявно вы мочь он не заметить например если это параметр цикл который вы подставлять тип с помощь ключевой слово то есть тип там быть неявно выбрать как однобайтовый если вы инициализировать нуль параметр значит никогда не дойти до 256 значит вы потенциально иметь бесконечный цикл и зависнуть контракт он не быть зависать он упасть но если цикл стоить где то в ключевой место то далёкий падение ваш контракт никуда не пойти при различный арифметик мочь быть неявный тип выражение например если вы возводить что то в степень два байтовый число и присваивать результат большой число то без приведение тип у вы результат быть байтовый и опять же возникнуть переполнение bug bounty если переводить дословно это выдача вознаграждение за баг тут применимый тот же методология оценка что и оценка аудит том е оценка уязвимость я бы выделить два вид принципиально разный программа bug bounty один так называть ручной bug bounty хороший ссылка как это дело оформляться по суть это свой род оферта который предлагать давать поискать уязвимость в такой то код оговариваться многие условие например кто один найти тот и молодец и вообще сходить посмотреть там весь классно описать сколько деньга полагаться за какой уязвимость тут понятный механик вы писать специалист по безопасность хакер что найти то то и то то вы проверять и если да то имя выплачиваться вознаграждение есть два вид автоматический bug bounty она привлекательный и для хакер и для заказчик здесь удобно то что нет переговоры нет споровый на тема тот какой это уязвимость сколько за нея деньга в ручной вариант начинаться сомнение что дескать она никогда не заэксплуатировать в такой вид здесь это нет здесь мочь быть два сценарий один удобный для кошелёк хранилище эфир когда просто деплоиться хранилище на он заливаться эфир далее говориться ломать ребята тут единственный что можно добавить комментарий это bug bounty весь можно и нужно ломать и забирать эфир я не уверенный но казалось бы это самый вы снимать потенциальный вопрос о несанкционированный доступ к информация и уголовный статья с хакер который заняться взлом в ваш интерес два сценарий автоматический bug bounty нарушение инвариант у контракт обычно бывать явный или неявный инвариант например у токен есть число который говорить сколько же всего токен и это число должный равняться сумма балансовый держатель токен или например хранилище эфир который работать в ход ico оно мочь вести сумма сколько же эфир собрать и баланс контракт хранилище должный быть большой этот сумма либо равный она если это не так то происходить нарушение инвариант как организоваться такой bug bounty есть контракт который выдавать заинтересовать лицо новый копия контракт с инвариант и они мочь свой действие как то играться с копия и пытаться нарушить инвариант когда он нарушить имя автоматически прилетать деньга они выплачивать родительский контракт удобно это тем что весь этот история автоматический и хакер мочь за пара часы получить вознаграждение за труд а заказчик bug bounty увидеть как взломать он контракт он быть точно это знать потому что быть 100 эфир а стать 0 он увидеть это ведь в blockchain весь публично и оба сторона не нужно тратить время на спорый разработать протестировать провести аудит и bug bounty теперь время деплоить том е выкладывать контракт в блокчейн деплый автоматизироваться truffle в соответствие с прописать вы контракт и связь между они это один команда в консоль здесь есть момент который требовать внимание начать с лимит газа это предел большой который не мочь потребить ни один транзакция поскольку транзакция должный находиться в какой то блок и лимит не так уж велик он меняться динамически это происходить отнюдь не резко и сейчас предел таков что в контракт вы не мочь в один транзакция записать матрица 20 на 20 больший число просто не хватить газа разворачивание контракт том е закидывание кусок код в блокчейн тоже стоить довольно много газа кроме тот если ваш контракт именно создавать другой контракт а не просто использовать они то он содержимый в себя они байт код и он цена приплюсовываться к потребление газа транзакция мы сталкиваться с тем что система контракт накладывать свой проблема на этап деплоить быть случай когда это не влезать в блок и вообще деплый система стоить порядок 1 эфир это значит что на один деплый вынуть да положь 300 доллар это конечно решаться контракт деплоиться по отдельность и затем связываться но понятный дело это лишний работа лишний проблема лишний уязвимость поскольку деплый дорогой стоить задеплоить сначала в testnet это тестовый блокчейн ethereum убедиться что там весь правильно там эфир не стоить почти ничто он довольно легко получить там можно делать ошибка и хороший для начало откатать весь процесс в немой мы говорить о управлять нода о владелец контракт токен нода заранее следовать подготовить иметь на они полностью синхронизировать блокчейн и какой то количество эфир для управлять сигнал том е для вызов транзакция существовать два принципиально разный сценарий деплоить в один случай разработчик приезжать к заказчик показывать вот весь хорошо тест проходить давать деплоиться брать нода деплоиться у он есть другой вариант разработчик проводить деплый у себя в свой окружение и передавать право и владение заказчик в первое случай заранее позаботиться о тот чтобы на нода с который быть деплый быть достаточный количество эфир и синхронизировать блокчейн потому что при деплый на несинхронизированный блокчейн truffle выдать ошибка в второе случай когда деплый происходить у разработчик есть свой плюс для оба сторона разработчик использовать свой окружение том е у они стоить и truffle правильный и geth и ещё много что и делать весь это быстро и комфортно для заказчик профит в тот что у разработчик нет физический доступ к нода в сеть заказчик с точка зрение информационный безопасность физический доступ один из плохой сценарий в свой очередь передача право и владение математически строго гарантироваться и заказчик легко проверить что весь сделать правильно в ход деплоить в любой случай нужно подумать как быть передаваться информация между нода участвовать в деплый например адрес контракт или адрес мультиподпись адрес весь большой они даже не стоить пытаться переписывать или запоминать нужно придумать механизм передача но тут ничто страшный нет они публичный сколько угодный он публиковать есть закрытый ключ по открытый ключ он никто в ближний время получить не смочь по итог деплоить следовать проверить владелец весь контракт что весь правильно и связь контракт что они связать в нужный порядок что ico не быть пытаться кидать токен в фонд эфир например заказчик на свой сторона нужно научиться этот простой процедура добавлять задеплоить контракт себя в кошелёк при добавление указываться он адрес имя для запоминание и abi контракт который можно получить после верификация контракт например на etherscan в он не надо особо вникать важный он скопировать вставить добавить контракт по любой нужно уметь выполнять этот процедура я точно не уверенный то ли кошелёк сохранять в себя информация о контракт то ли он терять она после закрытие но в любой случай нужно понимать что это добавление в кошелёк контракт оно никак не влиять на блокчейн это происходить сугубо у вы локально сделать это вы смочь удобно читать контракт в интерфейс есть возможность прямо посмотреть поль контракт в тот число сложный например массив маппинга кроме тот можно писать в контракт что тоже нужно уметь потому что это посылка управлять сигнал это отсылка транзакция например в административный функция предположим вы хотеть поменять владелец контракт весь довольно просто указывать с кто и на кто указывать с какой аккаунт вы хотеть заплатить эфир за операция с вы спросить пароль от это аккаунт и затем транзакция уйти в сеть если у вы использоваться подмен ico контракт то следовать сразу не забыть проработать сценарий подмена кто что делать чтобы допустить у владелец который вы уже отдать право не быть вопрос чтобы они у себя в офис быстро открыть поменять и чтобы никто судорожно не пытаться понять что делать и не наделать ошибка теперь давать обсудить верификация что это такой зачем она нужный мы говорить что в блокчейн весь публично байт код контракт также публичный однако я упоминать о тот что он выполнять виртуальный машина ethereum а вы не виртуальный машина ethereum и сказать я вы этот машина довольно низкоуровневый она стековый более низкоуровневый чем набор инструкция современный процессор intel и amd то есть по сравнение с набор инструкция amd64 она исполнять код куда более запутанный просто потому что там довольно примитивный операция это более похоже на risc процессор так называть reduced instruction set очень трудно понять по байт код контракт что он делать я трудно разобраться что делать контракт без исходный код инвестор тем более это не значит что можно в контракт писать какой то backdoor потому что они найти не через пять минута а через пять день десять день вернуться к исходный проблема нужно дать понять инвестор что же делать контракт для это иметься механизм верификация для любой контракт люба человек мочь предложить он исходный код этот механизм есть на etherscan он брать исходный код пытаться он скомпилировать получить ровно то же самый что лежать в блокчейн и если это так то можно считать что это именно тот самый исходный код контракт ваш код мочь храниться в несколько файл нужно они скомпоновать запихнуть туда в вид один кусок код кроме тот требоваться передать аргумент конструктор в упаковать вид как они быть послать то есть совсем не user friendly вещь но умеючи это можно сделать в итог когда код проверифицировать в etherscan он быть видный на вкладка исходник контракт предвосхищать вопрос как же так получаться этот самый etherscan единственный доверенный лицо мочь сказать что нет каждый точно так же мочь локально взять код контракт скомпилировать он получить бинарь и сравнить он с тем что лежать в блокчейн и это не очень сложно такой образ верификация для контракт хороший сделать инвестор увидеть код и убедиться что в блокчейн происходить именно то что вы обещать в white paper итак прорезюмировать перед работа над контракт стоить продумать они общий структура и связь в процесс разработка контракт нужно помнить не только о типичный приём и проблема программирование но и о специфика блокчейн обязательно стоить провести доскональный автоматизированный тестирование и аудит контракт а также проверифицировать они код закончить весь это не поздний чем за 3 день до запуск удачный ico

