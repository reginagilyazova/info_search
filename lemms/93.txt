использование boost asio с coroutines ts ysynov использование функция обратный вызов callback популярный подход к построение сетевой приложение с использование библиотека boost asio и не только она проблема это подход являться ухудшение читабельность и поддерживаемость код при усложнение логика протокол обмен дать как альтернатива коллбек сопрограмма coroutines можно применить для написание асинхронный код уровень читабельность который быть близкий к читабельность синхронный код boost asio поддерживать такой подход предоставлять возможность использование библиотека boost coroutine для обработка коллбек boost coroutine реализовать сопрограмма с помощь сохранение контекст выполнение текущий поток этот подход конкурировать за включение в следующий редакция стандарт c с предложение от microsoft который вводить новое ключевой слово co_return co_yield и co_await предложение microsoft получить статус technical specification ts и иметь высокий шанс стать стандарт статья демонстрировать использование boost asio с coroutines ts и boost future в свой статья я хотеть показать как можно обойтись без boost future мы взять за основа асинхронный tcp эхо сервер из boost asio и быть он модифицировать использовать сопрограмма из coroutines ts на момент написание статья coroutines ts реализовать в компилятор visual c 2017 и clang 5 0 мы быть использовать clang необходимый установить флаг компилятор для включение экспериментальный поддержка стандарт c 20 std c 2a и coroutines ts fcoroutines ts также нужно включить заголовочный файл experimental coroutine в оригинальный пример функция для чтение из сокет выглядеть так мы инициировать асинхронный чтение из сокет и задавать коллбек который быть вызвать при получение дать и инициировать они отсылка обратно функция запись в оригинал выглядеть так при успешный запись дать в сокет мы снова инициировать асинхронный чтение по суть логика программа сводиться к цикл псевдокод быть бы удобно закодировать это в вид явный цикл однако в такой случай мы прийтись бы сделать чтение и запись синхронный операция мы это не подходить поскольку мы хотеть обслуживать несколько клиентский сессия в один поток выполнение одновременно на помощь приходить сопрограмма переписать функция do_read в следующий вид использование ключевой слово co_await а также co_yield и co_return превращать функция в сопрограмма такой функция иметь несколько точка suspension point где она выполнение приостанавливаться suspend с сохранение состояние значение локальный переменный поздний выполнение сопрограмма мочь быть возобновить resume начинать с последний остановка ключевой слово co_await в наш функция создавать suspension point после тот как асинхронный чтение инициировать выполнение сопрограмма do_read быть приостановить до завершение чтение возврат из функция при это не происходить но выполнение программа продолжаться начинать с точка вызов сопрограмма когда клиент подключаться вызываться session start где do_read вызываться один раз для этот сессия после начало асинхронный чтение продолжаться выполнение функция start происходить возврат из нея и инициироваться приём следующий соединение далее продолжать выполнение код из asio который вызвать обработчик аргумент async_accept для тот чтобы магия co_await работать он выражение в наш случай функция async_read_some должный возвращать объект класс который соответствовать определённый контракт реализация async_read_some взять из комментарий к статья async_read_some возвращать объект класс awaiter который реализовать контракт требовать co_await если теперь попытаться собрать наш программа то получить ошибка компиляция причина в тот что компилятор требовать чтобы для сопрограмма тоже быть реализовать некоторый контракт это делаться с помощь специализация шаблон std experimental coroutine_traits мы специализировать coroutine_traits для сопрограмма с возращать значение тип void и любой количество и тип параметр сопрограмма do_read подходить под это описание специализация шаблон содержимый тип promise_type с следующий функция теперь можно запустить сервер и проверить он работоспособность открыть несколько подключение с помощь telnet функция запись do_write весь ещё основываться на использование коллбек исправимый это переписать do_write в следующий вид написать awaitable обёртка для запись в сокет последний шаг переписать do_read в вид явный цикл логика программа теперь записать в вид близкий к синхронный код однако она выполняться асинхронный ложка далее гтя являться то что мы прийтись написать дополнительный awaitable класс для возвращать значение do_write это иллюстрировать один из недостаток coroutines ts распространение co_await вверх по стечь асинхронный вызов переделка функция server do_accept в сопрограмма оставить в качество упражнение полный текст программа можно найти на мы рассмотреть использование boost asio с coroutines ts для программирование асинхронный сетевой приложение преимущество такой подход улучшение читабельность код поскольку он становиться близкий по форма к синхронный недостаток необходимость в написание дополнительный обёртка для поддержка модель сопрограмма реализовать в coroutines ts

